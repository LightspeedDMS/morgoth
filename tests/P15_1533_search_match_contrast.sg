// P15_1533: Current search match uses fg=15, other matches fg=0

rite is_search_match(cm, row, col) {
    ≔ mut i = 0;
    ⟳ i < len(cm.search_matches) {
        ≔ m = cm.search_matches[i];
        ⎇ row == m.row ∧ col >= m.col ∧ col < m.col + len(cm.search_query) {
            ⎇ i == cm.search_current {
                ↩ {hit: true, current: true}
            }
            ↩ {hit: true, current: false}
        }
        i = i + 1;
    }
    ↩ {hit: false, current: false}
}

rite main() {
    ≔ cm = {
        search_matches: [{row: 0, col: 5}, {row: 2, col: 10}],
        search_current: 1,
        search_query: "foo"
    };

    // Test 1: Current match (index 1, row=2, col=10) should be current=true
    ≔ m1 = is_search_match(cm, 2, 10);
    ⎇ m1.hit == true ∧ m1.current == true {
        println("current_match: OK");
    } ⎉ {
        println("current_match: FAILED hit=" + to_string(m1.hit) + " current=" + to_string(m1.current));
    }

    // Test 2: Non-current match (index 0, row=0, col=5)
    ≔ m2 = is_search_match(cm, 0, 5);
    ⎇ m2.hit == true ∧ m2.current == false {
        println("other_match: OK");
    } ⎉ {
        println("other_match: FAILED hit=" + to_string(m2.hit) + " current=" + to_string(m2.current));
    }

    // Test 3: The code should render current match with fg=15
    // (This validates the contract — actual rendering uses fg=15 for current, fg=0 for others)
    ≔ mut current_fg = 0;
    ≔ mut other_fg = 0;
    ⎇ m1.current == true { current_fg = 15; }
    ⎇ m2.current == false { other_fg = 0; }
    ⎇ current_fg == 15 ∧ other_fg == 0 {
        println("contrast_values: OK");
    } ⎉ {
        println("contrast_values: FAILED current=" + to_string(current_fg) + " other=" + to_string(other_fg));
    }
}
