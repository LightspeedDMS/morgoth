// Test: n/N cycle through matches with wrap-around
// Spec: Phase 10 - Scrollback Search
// Priority: P10

rite find_all_matches(text_lines, query) {
    ≔ mut matches = [];
    ⎇ query == "" { ↩ matches }
    ≔ mut case_sensitive = false;
    ≔ mut qi = 0;
    ⟳ qi < len(query) {
        ≔ c = char_code_at(query, qi);
        ⎇ c >= 65 ∧ c <= 90 { case_sensitive = true; }
        qi = qi + 1;
    }
    ≔ mut search_q = query;
    ⎇ case_sensitive == false { search_q = lower(query); }
    ≔ mut row = 0;
    ⟳ row < len(text_lines) {
        ≔ mut line = text_lines[row];
        ⎇ case_sensitive == false { line = lower(line); }
        ≔ mut col = 0;
        ≔ mut remaining = line;
        ⟳ len(remaining) >= len(search_q) {
            ≔ idx = index_of(remaining, search_q);
            ⎇ idx >= 0 {
                push(matches, {row: row, col: col + idx});
                col = col + idx + 1;
                remaining = substring(line, col, len(line));
            } ⎉ {
                remaining = "";
            }
        }
        row = row + 1;
    }
    ↩ matches
}

rite nearest_match(matches, cursor_row, direction) {
    ⎇ len(matches) == 0 { ↩ -1 }
    ⎇ direction == "backward" {
        ≔ mut i = len(matches) - 1;
        ⟳ i >= 0 {
            ⎇ matches[i].row <= cursor_row { ↩ i }
            i = i - 1;
        }
        ↩ len(matches) - 1
    }
    ≔ mut i = 0;
    ⟳ i < len(matches) {
        ⎇ matches[i].row >= cursor_row { ↩ i }
        i = i + 1;
    }
    ↩ 0
}

rite main() {
    ≔ lines = ["foo bar", "baz foo", "qux", "foo end"];
    ≔ matches = find_all_matches(lines, "foo");

    // Should find 3 matches: (0,0), (1,4), (3,0)
    ⎇ len(matches) == 3 {
        println("match_count: OK");
    } ⎉ {
        println("match_count: FAILED got=" + to_string(len(matches)));
    }

    // Start at match 0
    ≔ mut current = 0;

    // n (next): 0 → 1
    current = (current + 1) % len(matches);
    ⎇ current == 1 {
        println("next_1: OK");
    } ⎉ {
        println("next_1: FAILED got=" + to_string(current));
    }

    // n again: 1 → 2
    current = (current + 1) % len(matches);
    ⎇ current == 2 {
        println("next_2: OK");
    } ⎉ {
        println("next_2: FAILED got=" + to_string(current));
    }

    // n again: 2 → 0 (wrap)
    current = (current + 1) % len(matches);
    ⎇ current == 0 {
        println("next_wrap: OK");
    } ⎉ {
        println("next_wrap: FAILED got=" + to_string(current));
    }

    // N (prev): 0 → 2
    current = current - 1;
    ⎇ current < 0 { current = len(matches) - 1; }
    ⎇ current == 2 {
        println("prev_wrap: OK");
    } ⎉ {
        println("prev_wrap: FAILED got=" + to_string(current));
    }

    // N again: 2 → 1
    current = current - 1;
    ⎇ current < 0 { current = len(matches) - 1; }
    ⎇ current == 1 {
        println("prev_1: OK");
    } ⎉ {
        println("prev_1: FAILED got=" + to_string(current));
    }

    // nearest_match forward from row 1
    ≔ n1 = nearest_match(matches, 1, "forward");
    ⎇ n1 == 1 {
        println("nearest_fwd: OK");
    } ⎉ {
        println("nearest_fwd: FAILED got=" + to_string(n1));
    }

    // nearest_match backward from row 2
    ≔ n2 = nearest_match(matches, 2, "backward");
    ⎇ n2 == 1 {
        println("nearest_bwd: OK");
    } ⎉ {
        println("nearest_bwd: FAILED got=" + to_string(n2));
    }
}
