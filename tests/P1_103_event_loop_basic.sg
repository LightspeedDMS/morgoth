// Test: Basic event loop structure for Morgoth
// Spec: MORGOTH-SPEC.md § Phase 1.1 - Event Loop
// Priority: P1
//
// Purpose:
// Validates the poll loop pattern that Morgoth uses: polling stdin for user
// input, polling PTY masters for child output, and checking for pending
// signals. Tests the primitives in a loop-like structure.
//
// Expected behavior:
// - Sys·poll_fd on empty PTY with 0 timeout returns false (no data)
// - Sys·poll_fd on PTY master after write to slave returns true
// - Sys·signal_register + signal_pending works in loop context

rite main() {
    // Test 1: Poll empty PTY master with 0ms timeout — no data expected
    // Note: We use an empty PTY rather than fd 0 (stdin) because stdin may be
    // piped in the test harness, and native libc::poll() correctly detects
    // piped stdin as readable. An empty PTY master has no data regardless.
    ≔ empty_pty = Pty·open();
    ≔ empty_ready = Sys·poll_fd(empty_pty.master_fd, 0);
    Sys·close(empty_pty.master_fd);
    Sys·close(empty_pty.slave_fd);
    ⎇ empty_ready == false {
        println("poll_empty_fd: OK");
    } ⎉ {
        println("poll_empty_fd: FAILED");
    }

    // Test 2: Poll PTY master after writing to slave
    ≔ pty = Pty·open();
    Sys·write(pty.slave_fd, "child_data", 10);
    ≔ pty_ready = Sys·poll_fd(pty.master_fd, 0);
    ⎇ pty_ready == true {
        println("poll_pty_after_write: OK");
    } ⎉ {
        println("poll_pty_after_write: FAILED");
    }

    // Test 3: Register SIGWINCH handler
    ≔ reg = Sys·signal_register(SIGWINCH());
    ⎇ reg == 0 {
        println("signal_register_winch: OK");
    } ⎉ {
        println("signal_register_winch: FAILED");
    }

    // Test 4: No signal pending before delivery
    ≔ pending_before = Sys·signal_pending(SIGWINCH());
    ⎇ pending_before == false {
        println("signal_not_pending: OK");
    } ⎉ {
        println("signal_not_pending: FAILED");
    }

    // Test 5: Simulate a loop iteration — send signal, then check
    Sys·signal_send(SIGWINCH());
    ≔ pending_after = Sys·signal_pending(SIGWINCH());
    ⎇ pending_after == true {
        println("signal_pending_in_loop: OK");
    } ⎉ {
        println("signal_pending_in_loop: FAILED");
    }

    // Test 6: Register SIGCHLD for child exit detection
    ≔ reg_chld = Sys·signal_register(SIGCHLD());
    ⎇ reg_chld == 0 {
        println("signal_register_chld: OK");
    } ⎉ {
        println("signal_register_chld: FAILED");
    }

    // Cleanup
    Sys·close(pty.master_fd);
    Sys·close(pty.slave_fd);
}
