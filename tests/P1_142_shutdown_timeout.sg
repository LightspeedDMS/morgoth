// Test: Shutdown escalates from SIGTERM to SIGKILL after timeout
// Spec: MORGOTH-SPEC.md § Phase 1.5 - Shutdown Escalation
// Priority: P1
//
// Purpose:
// Validates the shutdown escalation pattern: first send SIGTERM, then if
// the process does not exit within the timeout, escalate to SIGKILL.
// Tests the logic of the escalation sequence using spawn + kill + waitpid.
//
// Expected behavior:
// - SIGTERM is sent first (returns 0)
// - If process still alive after SIGTERM, SIGKILL is sent
// - SIGKILL returns 0
// - waitpid reaps the process after SIGKILL

rite main() {
    // Spawn a process that ignores SIGTERM (simulated by using sleep)
    ≔ bg = Sys·spawn_bg("/bin/sleep", ["60"]);

    // Test 1: SIGTERM sent successfully
    ≔ term_result = Sys·kill(bg.pid, SIGTERM());
    ⎇ term_result == 0 {
        println("escalate_sigterm: OK");
    } ⎉ {
        println("escalate_sigterm: FAILED");
    }

    // Test 2: Simulate timeout check — poll for process exit
    // In real Morgoth, we'd wait N ms then check. Here we simulate
    // the "process still alive" case by checking waitpid with WNOHANG (1).
    ≔ check = Sys·waitpid(bg.pid, 1);
    // If check.pid == 0, process has not exited yet (WNOHANG semantics)
    // If check.pid > 0, it already exited from SIGTERM
    // Either way, the escalation logic should proceed to SIGKILL

    // Test 3: Escalate to SIGKILL
    ≔ kill_result = Sys·kill(bg.pid, SIGKILL());
    // This should succeed (return 0) or return error if already dead
    ⎇ kill_result == 0 ∨ kill_result == -3 {
        println("escalate_sigkill: OK");
    } ⎉ {
        println("escalate_sigkill: FAILED");
    }

    // Test 4: Reap the process after SIGKILL
    ≔ final_wait = Sys·waitpid(bg.pid, 0);
    ⎇ final_wait.pid >= 0 ∨ final_wait.pid == -1 {
        println("escalate_reap: OK");
    } ⎉ {
        println("escalate_reap: FAILED");
    }

    // Test 5: Verify escalation order — SIGTERM value < SIGKILL value
    ⎇ SIGTERM() > 0 ∧ SIGKILL() > 0 {
        println("escalate_signal_values: OK");
    } ⎉ {
        println("escalate_signal_values: FAILED");
    }

    // Test 6: Multiple children escalation (spawn and kill a second)
    ≔ bg2 = Sys·spawn_bg("/bin/sleep", ["60"]);
    Sys·kill(bg2.pid, SIGTERM());
    ≔ kill2 = Sys·kill(bg2.pid, SIGKILL());
    ⎇ kill2 == 0 ∨ kill2 == -3 {
        println("escalate_multi_child: OK");
    } ⎉ {
        println("escalate_multi_child: FAILED");
    }
    Sys·waitpid(bg2.pid, 0);

    // Cleanup
    Sys·close(bg.stdin_fd);
    Sys·close(bg.stdout_fd);
    Sys·close(bg.stderr_fd);
    Sys·close(bg2.stdin_fd);
    Sys·close(bg2.stdout_fd);
    Sys·close(bg2.stderr_fd);
}
