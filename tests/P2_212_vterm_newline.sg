// Test: VTerm newline, carriage return, and scroll
// Spec: Phase 2.1 - Terminal Emulation
// Priority: P2
//
// Purpose:
// Validates that \n moves cursor down, \r returns to col 0,
// \r\n combo works, and scrolling triggers at bottom of screen.

rite VTerm_new(rows, cols) {
    ≔ total = rows * cols;
    ≔ mut cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, {ch: " ", fg: 7, bg: 0});
        i = i + 1;
    }
    ↩ {
        cells: cells, rows: rows, cols: cols,
        cursor_row: 0, cursor_col: 0,
        attr_fg: 7, attr_bg: 0,
        esc_state: "normal", esc_buf: "",
        scroll_top: 0, scroll_bottom: rows - 1,
        saved_row: 0, saved_col: 0,
        scrollback: [], scrollback_max: 1000, scroll_offset: 0
    }
}

rite vterm_scroll_up(vt) {
    ≔ mut row = vt.scroll_top;
    ⟳ row < vt.scroll_bottom {
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            vt.cells[row * vt.cols + col] = vt.cells[(row + 1) * vt.cols + col];
            col = col + 1;
        }
        row = row + 1;
    }
    ≔ mut col = 0;
    ⟳ col < vt.cols {
        vt.cells[vt.scroll_bottom * vt.cols + col] = {ch: " ", fg: 7, bg: 0};
        col = col + 1;
    }
}

rite vterm_put_char(vt, ch) {
    ⎇ vt.cursor_col >= vt.cols {
        vt.cursor_col = 0;
        vt.cursor_row = vt.cursor_row + 1;
        ⎇ vt.cursor_row > vt.scroll_bottom {
            vterm_scroll_up(vt);
            vt.cursor_row = vt.scroll_bottom;
        }
    }
    ≔ idx = vt.cursor_row * vt.cols + vt.cursor_col;
    ⎇ idx >= 0 ∧ idx < len(vt.cells) {
        vt.cells[idx] = {ch: ch, fg: vt.attr_fg, bg: vt.attr_bg};
    }
    vt.cursor_col = vt.cursor_col + 1;
}

rite vterm_feed(vt, data) {
    ≔ mut i = 0;
    ⟳ i < len(data) {
        ≔ ch = to_string(char_at(data, i));
        ≔ code = char_code_at(data, i);

        ⎇ vt.esc_state == "normal" {
            ⎇ code == 13 { vt.cursor_col = 0; }
            ⎇ code == 10 {
                vt.cursor_row = vt.cursor_row + 1;
                ⎇ vt.cursor_row > vt.scroll_bottom {
                    vterm_scroll_up(vt);
                    vt.cursor_row = vt.scroll_bottom;
                }
            }
            ⎇ code == 8 { ⎇ vt.cursor_col > 0 { vt.cursor_col = vt.cursor_col - 1; } }
            ⎇ code >= 32 { vterm_put_char(vt, ch); }
        }

        i = i + 1;
    }
    vt.scroll_offset = 0;
}

rite main() {
    // Use a 4-row, 5-col VTerm
    ≔ vt = VTerm_new(4, 5);

    // Test 1: \n moves cursor down one row
    vterm_feed(vt, "A");
    vterm_feed(vt, "\n");
    ⎇ vt.cursor_row == 1 {
        println("newline_moves_down: OK");
    } ⎉ {
        println("newline_moves_down: FAILED row=" + to_string(vt.cursor_row));
    }

    // Test 2: \r returns cursor to col 0
    vterm_feed(vt, "BC");
    vterm_feed(vt, "\r");
    ⎇ vt.cursor_col == 0 {
        println("cr_resets_col: OK");
    } ⎉ {
        println("cr_resets_col: FAILED col=" + to_string(vt.cursor_col));
    }

    // Test 3: \r\n combo moves down and resets col
    ≔ vt2 = VTerm_new(4, 5);
    vterm_feed(vt2, "AB\r\nCD");
    ⎇ vt2.cursor_row == 1 ∧ vt2.cursor_col == 2 {
        ⎇ vt2.cells[0].ch == "A" ∧ vt2.cells[1].ch == "B" ∧ vt2.cells[5].ch == "C" ∧ vt2.cells[6].ch == "D" {
            println("cr_lf_combo: OK");
        } ⎉ {
            println("cr_lf_combo: FAILED cells");
        }
    } ⎉ {
        println("cr_lf_combo: FAILED row=" + to_string(vt2.cursor_row) + " col=" + to_string(vt2.cursor_col));
    }

    // Test 4: Scroll triggers when writing past the bottom
    // Use \r\n to properly reset col before each new line
    ≔ vt3 = VTerm_new(4, 5);
    vterm_feed(vt3, "AAAAA\r\nBBBBB\r\nCCCCC\r\nDDDDD");
    // Now at row 3 (bottom), cursor_col = 5. Feed \r\n to trigger scroll.
    vterm_feed(vt3, "\r\n");
    // After scroll, row 0 should now contain what was row 1 ("BBBBB")
    ⎇ vt3.cells[0].ch == "B" ∧ vt3.cursor_row == 3 {
        println("scroll_at_bottom: OK");
    } ⎉ {
        println("scroll_at_bottom: FAILED row0=" + vt3.cells[0].ch + " cursor_row=" + to_string(vt3.cursor_row));
    }
}
