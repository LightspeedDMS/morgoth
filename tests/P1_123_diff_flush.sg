// Test: Dirty cell tracking and differential flush
// Spec: MORGOTH-SPEC.md § Phase 1.3 - Diff Flush
// Priority: P1
//
// Purpose:
// Validates that only cells marked as dirty are emitted during a flush
// operation. After flushing, all dirty flags should be cleared. This is
// critical for Morgoth's rendering performance.
//
// Expected behavior:
// - Initially no cells are dirty
// - Writing to a cell marks it dirty
// - Flush counts only dirty cells
// - After flush, dirty count returns to 0

rite main() {
    ≔ grid_cols = 10;
    ≔ grid_rows = 5;
    ≔ total = grid_rows * grid_cols;  // 50

    // Parallel arrays: grid values and dirty flags
    ≔ mut grid = [0; 50];
    ≔ mut dirty = [0; 50];   // 0 = clean, 1 = dirty
    ≔ SPACE = 32;

    // Initialize grid
    ≔ mut i = 0;
    ⟳ i < total {
        grid[i] = SPACE;
        dirty[i] = 0;
        i = i + 1;
    }

    // Test 1: Initial dirty count is 0
    ≔ mut dirty_count = 0;
    i = 0;
    ⟳ i < total {
        ⎇ dirty[i] == 1 {
            dirty_count = dirty_count + 1;
        }
        i = i + 1;
    }
    ⎇ dirty_count == 0 {
        println("dirty_initial_zero: OK");
    } ⎉ {
        println("dirty_initial_zero: FAILED");
    }

    // Test 2: Writing to cells marks them dirty
    // Simulate writing "ABC" at row 1, cols 2-4
    grid[1 * grid_cols + 2] = 65;  // A
    dirty[1 * grid_cols + 2] = 1;
    grid[1 * grid_cols + 3] = 66;  // B
    dirty[1 * grid_cols + 3] = 1;
    grid[1 * grid_cols + 4] = 67;  // C
    dirty[1 * grid_cols + 4] = 1;

    dirty_count = 0;
    i = 0;
    ⟳ i < total {
        ⎇ dirty[i] == 1 {
            dirty_count = dirty_count + 1;
        }
        i = i + 1;
    }
    ⎇ dirty_count == 3 {
        println("dirty_after_write: OK");
    } ⎉ {
        println("dirty_after_write: FAILED");
    }

    // Test 3: Flush emits only dirty cells (count how many would be emitted)
    ≔ mut flush_count = 0;
    i = 0;
    ⟳ i < total {
        ⎇ dirty[i] == 1 {
            // In real code: emit escape sequence + character
            flush_count = flush_count + 1;
        }
        i = i + 1;
    }
    ⎇ flush_count == 3 {
        println("flush_emits_dirty_only: OK");
    } ⎉ {
        println("flush_emits_dirty_only: FAILED");
    }

    // Test 4: After flush, clear all dirty flags
    i = 0;
    ⟳ i < total {
        dirty[i] = 0;
        i = i + 1;
    }

    dirty_count = 0;
    i = 0;
    ⟳ i < total {
        ⎇ dirty[i] == 1 {
            dirty_count = dirty_count + 1;
        }
        i = i + 1;
    }
    ⎇ dirty_count == 0 {
        println("dirty_after_flush_zero: OK");
    } ⎉ {
        println("dirty_after_flush_zero: FAILED");
    }

    // Test 5: Writing same value should still mark dirty
    // (content-aware diffing is a future optimization)
    grid[0] = SPACE;  // same value
    dirty[0] = 1;     // still dirty
    ⎇ dirty[0] == 1 {
        println("dirty_same_value: OK");
    } ⎉ {
        println("dirty_same_value: FAILED");
    }
}
