// Test: Mixed ASCII and CJK characters at correct cell positions
// Spec: Phase 12 - Unicode Width Handling
// Priority: P12
//
// Purpose:
// Validates that feeding a string with interleaved ASCII and fullwidth CJK
// characters places each character at the correct cell index, with empty
// string placeholders after each fullwidth character.

rite VTerm_new(rows, cols) {
    ≔ total = rows * cols;
    ≔ mut cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, {ch: " ", fg: 7, bg: 0});
        i = i + 1;
    }
    ↩ {
        cells: cells, rows: rows, cols: cols,
        cursor_row: 0, cursor_col: 0,
        attr_fg: 7, attr_bg: 0,
        esc_state: "normal", esc_buf: "",
        scroll_top: 0, scroll_bottom: rows - 1,
        saved_row: 0, saved_col: 0,
        scrollback: [], scrollback_max: 1000, scroll_offset: 0,
        alt_cells: [], alt_cursor_row: 0, alt_cursor_col: 0,
        alt_attr_fg: 7, alt_attr_bg: 0,
        in_alt_screen: false, cursor_visible: true,
        app_cursor_keys: false, auto_wrap: true,
        bracketed_paste: false, mouse_mode: 0,
        mouse_sgr: false, origin_mode: false, title: ""
    }
}

rite vterm_scroll_up(vt) {
    ≔ mut row = vt.scroll_top;
    ⟳ row < vt.scroll_bottom {
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            vt.cells[row * vt.cols + col] = vt.cells[(row + 1) * vt.cols + col];
            col = col + 1;
        }
        row = row + 1;
    }
    ≔ mut col = 0;
    ⟳ col < vt.cols {
        vt.cells[vt.scroll_bottom * vt.cols + col] = {ch: " ", fg: 7, bg: 0};
        col = col + 1;
    }
}

rite vterm_put_char(vt, ch) {
    // Fullwidth char at last column: wrap early
    ⎇ is_fullwidth(ch) == true ∧ vt.cursor_col == vt.cols - 1 ∧ vt.auto_wrap == true {
        vt.cursor_col = vt.cols;
    }
    // Handle line wrap
    ⎇ vt.cursor_col >= vt.cols {
        ⎇ vt.auto_wrap == true {
            vt.cursor_col = 0;
            vt.cursor_row = vt.cursor_row + 1;
            ⎇ vt.cursor_row > vt.scroll_bottom {
                vterm_scroll_up(vt);
                vt.cursor_row = vt.scroll_bottom;
            }
        } ⎉ {
            vt.cursor_col = vt.cols - 1;
        }
    }
    ≔ idx = vt.cursor_row * vt.cols + vt.cursor_col;
    ⎇ idx >= 0 ∧ idx < len(vt.cells) {
        vt.cells[idx] = {ch: ch, fg: vt.attr_fg, bg: vt.attr_bg};
    }
    ⎇ is_fullwidth(ch) == true {
        ≔ idx2 = vt.cursor_row * vt.cols + vt.cursor_col + 1;
        ⎇ idx2 >= 0 ∧ idx2 < len(vt.cells) {
            vt.cells[idx2] = {ch: "", fg: vt.attr_fg, bg: vt.attr_bg};
        }
        vt.cursor_col = vt.cursor_col + 2;
    } ⎉ {
        vt.cursor_col = vt.cursor_col + 1;
    }
}

rite vterm_feed(vt, data) {
    ≔ mut i = 0;
    ⟳ i < len(data) {
        ≔ ch = to_string(char_at(data, i));
        ≔ code = char_code_at(data, i);

        ⎇ vt.esc_state == "csi" {
            ⎇ (code >= 64 ∧ code <= 90) ∨ (code >= 97 ∧ code <= 122) {
                vt.esc_state = "normal";
                vt.esc_buf = "";
            } ⎉ {
                vt.esc_buf = vt.esc_buf + ch;
            }
        } ⎉ {
            ⎇ vt.esc_state == "escape" {
                ⎇ ch == "[" { vt.esc_state = "csi"; vt.esc_buf = ""; }
                ⎉ { vt.esc_state = "normal"; }
            } ⎉ {
                ⎇ code == 27 { vt.esc_state = "escape"; vt.esc_buf = ""; }
                ⎇ code == 13 { vt.cursor_col = 0; }
                ⎇ code == 10 {
                    vt.cursor_row = vt.cursor_row + 1;
                    vt.cursor_col = 0;
                    ⎇ vt.cursor_row > vt.scroll_bottom {
                        vterm_scroll_up(vt);
                        vt.cursor_row = vt.scroll_bottom;
                    }
                }
                ⎇ code >= 32 { vterm_put_char(vt, ch); }
            }
        }

        i = i + 1;
    }
    vt.scroll_offset = 0;
}

rite main() {
    ≔ vt = VTerm_new(3, 20);

    // Feed "Hi中文ok"
    // Expected cell layout:
    //   col 0: H (width 1, cursor advances to 1)
    //   col 1: i (width 1, cursor advances to 2)
    //   col 2: 中 (width 2, cursor advances to 4)
    //   col 3: "" (placeholder for 中)
    //   col 4: 文 (width 2, cursor advances to 6)
    //   col 5: "" (placeholder for 文)
    //   col 6: o (width 1, cursor advances to 7)
    //   col 7: k (width 1, cursor advances to 8)
    vterm_feed(vt, "Hi中文ok");

    // Test 1: H at col 0
    ⎇ vt.cells[0].ch == "H" {
        println("cell_H: OK");
    } ⎉ {
        println("cell_H: FAILED ch=" + vt.cells[0].ch);
    }

    // Test 2: i at col 1
    ⎇ vt.cells[1].ch == "i" {
        println("cell_i: OK");
    } ⎉ {
        println("cell_i: FAILED ch=" + vt.cells[1].ch);
    }

    // Test 3: 中 at col 2
    ⎇ vt.cells[2].ch == "中" {
        println("cell_cjk1: OK");
    } ⎉ {
        println("cell_cjk1: FAILED ch=" + vt.cells[2].ch);
    }

    // Test 4: "" placeholder at col 3
    ⎇ vt.cells[3].ch == "" {
        println("cell_placeholder1: OK");
    } ⎉ {
        println("cell_placeholder1: FAILED ch=" + vt.cells[3].ch);
    }

    // Test 5: 文 at col 4
    ⎇ vt.cells[4].ch == "文" {
        println("cell_cjk2: OK");
    } ⎉ {
        println("cell_cjk2: FAILED ch=" + vt.cells[4].ch);
    }

    // Test 6: "" placeholder at col 5
    ⎇ vt.cells[5].ch == "" {
        println("cell_placeholder2: OK");
    } ⎉ {
        println("cell_placeholder2: FAILED ch=" + vt.cells[5].ch);
    }

    // Test 7: o at col 6
    ⎇ vt.cells[6].ch == "o" {
        println("cell_o: OK");
    } ⎉ {
        println("cell_o: FAILED ch=" + vt.cells[6].ch);
    }

    // Test 8: k at col 7
    ⎇ vt.cells[7].ch == "k" {
        println("cell_k: OK");
    } ⎉ {
        println("cell_k: FAILED ch=" + vt.cells[7].ch);
    }

    // Test 9: cursor_col should be 8 (H=1 + i=1 + 中=2 + 文=2 + o=1 + k=1 = 8)
    ⎇ vt.cursor_col == 8 {
        println("cursor_col: OK");
    } ⎉ {
        println("cursor_col: FAILED col=" + to_string(vt.cursor_col));
    }
}
