// Test: Grid·set with identical content does NOT mark dirty
// Spec: Phase 16 - Performance
// Priority: P16

rite Cell_new(ch, fg, bg, dirty) {
    ↩ {ch: ch, fg: fg, bg: bg, dirty: dirty}
}

rite Grid_new(rows, cols) {
    ≔ total = rows * cols;
    ≔ mut cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, Cell_new(" ", 7, 0, false));
        i = i + 1;
    }
    ↩ {rows: rows, cols: cols, cells: cells}
}

// Smart Grid·set — only marks dirty if content changed
rite Grid_set(grid, row, col, ch, fg, bg) {
    ⎇ row >= 0 ∧ row < grid.rows ∧ col >= 0 ∧ col < grid.cols {
        ≔ idx = row * grid.cols + col;
        ≔ c = grid.cells[idx];
        ⎇ c.ch != ch ∨ c.fg != fg ∨ c.bg != bg {
            grid.cells[idx] = Cell_new(ch, fg, bg, true);
        }
    }
}

rite Grid_get(grid, row, col) {
    ⎇ row >= 0 ∧ row < grid.rows ∧ col >= 0 ∧ col < grid.cols {
        ≔ idx = row * grid.cols + col;
        ↩ grid.cells[idx]
    }
    ↩ Cell_new(" ", 7, 0, false)
}

rite Grid_dirty_count(grid) {
    ≔ mut count = 0;
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ⟳ i < total {
        ⎇ grid.cells[i].dirty == true {
            count = count + 1;
        }
        i = i + 1;
    }
    ↩ count
}

rite main() {
    ≔ grid = Grid_new(4, 10);

    // Test 1: Initially all cells are clean (dirty=false)
    ≔ dc0 = Grid_dirty_count(grid);
    ⎇ dc0 == 0 {
        println("initial_clean: OK");
    } ⎉ {
        println("initial_clean: FAILED count=" + to_string(dc0));
    }

    // Test 2: Setting a different value marks dirty
    Grid_set(grid, 0, 0, "A", 1, 2);
    ≔ c1 = Grid_get(grid, 0, 0);
    ⎇ c1.dirty == true ∧ c1.ch == "A" ∧ c1.fg == 1 ∧ c1.bg == 2 {
        println("set_different_dirty: OK");
    } ⎉ {
        println("set_different_dirty: FAILED dirty=" + to_string(c1.dirty) + " ch=" + c1.ch);
    }

    // Test 3: Setting the SAME value does NOT mark dirty
    // First clear the dirty flag manually
    grid.cells[0].dirty = false;
    Grid_set(grid, 0, 0, "A", 1, 2);
    ≔ c2 = Grid_get(grid, 0, 0);
    ⎇ c2.dirty == false {
        println("set_same_not_dirty: OK");
    } ⎉ {
        println("set_same_not_dirty: FAILED dirty=" + to_string(c2.dirty));
    }

    // Test 4: Changing only fg marks dirty
    Grid_set(grid, 0, 0, "A", 5, 2);
    ≔ c3 = Grid_get(grid, 0, 0);
    ⎇ c3.dirty == true ∧ c3.fg == 5 {
        println("change_fg_dirty: OK");
    } ⎉ {
        println("change_fg_dirty: FAILED dirty=" + to_string(c3.dirty) + " fg=" + to_string(c3.fg));
    }

    // Test 5: Changing only bg marks dirty
    grid.cells[0].dirty = false;
    Grid_set(grid, 0, 0, "A", 5, 9);
    ≔ c4 = Grid_get(grid, 0, 0);
    ⎇ c4.dirty == true ∧ c4.bg == 9 {
        println("change_bg_dirty: OK");
    } ⎉ {
        println("change_bg_dirty: FAILED dirty=" + to_string(c4.dirty) + " bg=" + to_string(c4.bg));
    }

    // Test 6: Changing only ch marks dirty
    grid.cells[0].dirty = false;
    Grid_set(grid, 0, 0, "B", 5, 9);
    ≔ c5 = Grid_get(grid, 0, 0);
    ⎇ c5.dirty == true ∧ c5.ch == "B" {
        println("change_ch_dirty: OK");
    } ⎉ {
        println("change_ch_dirty: FAILED dirty=" + to_string(c5.dirty) + " ch=" + c5.ch);
    }

    // Test 7: Total dirty count after mixed sets
    ≔ grid2 = Grid_new(2, 3);
    Grid_set(grid2, 0, 0, "X", 1, 0);
    Grid_set(grid2, 0, 1, " ", 7, 0); // Same as default — should NOT be dirty
    Grid_set(grid2, 1, 2, "Y", 2, 3);
    ≔ dc7 = Grid_dirty_count(grid2);
    ⎇ dc7 == 2 {
        println("mixed_dirty_count: OK");
    } ⎉ {
        println("mixed_dirty_count: FAILED count=" + to_string(dc7));
    }
}
