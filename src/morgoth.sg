// ============================================================================
// Morgoth — Terminal Multiplexer for Claude Code
// Written in Sigil
//
// Phase 1: Core Implementation
// - Single and multi-pane terminal with PTY management
// - Grid-based layout engine
// - Diff-based rendering with box-drawing borders
// - Leader key input routing
// - Graceful shutdown with signal handling
// ============================================================================

// ============================================================================
// Section 1: Constants
// ============================================================================

≔ VERSION = "0.1.0";
≔ LEADER_KEY = 2;          // Ctrl-B (0x02)
≔ ESC = "\x1b";
≔ CSI = "\x1b[";
≔ DEFAULT_SHELL = "/bin/bash";
≔ POLL_INTERVAL_MS = 16;   // ~60fps target
≔ SHUTDOWN_TIMEOUT_MS = 3000;
≔ HMR_CHECK_INTERVAL = 30; // Check every ~500ms (30 * 16ms)
≔ SELF_PATH = "src/morgoth.sg";

// Box-drawing characters (Unicode)
≔ BOX_H  = "─";
≔ BOX_V  = "│";
≔ BOX_TL = "┌";
≔ BOX_TR = "┐";
≔ BOX_BL = "└";
≔ BOX_BR = "┘";
≔ BOX_TJ = "┬";
≔ BOX_BJ = "┴";
≔ BOX_LJ = "├";
≔ BOX_RJ = "┤";
≔ BOX_X  = "┼";

// ============================================================================
// Section 2: Data Structures
// ============================================================================

// A Cell in the screen buffer
rite Cell·new(ch, fg, bg, dirty) {
    ≔ cell = {
        ch: ch,
        fg: fg,
        bg: bg,
        dirty: dirty
    };
    ↩ cell
}

// A rectangular region on screen
rite Region·new(x, y, w, h) {
    ≔ r = {
        x: x,
        y: y,
        w: w,
        h: h
    };
    ↩ r
}

// A Pane: owns a PTY, a shell process, and a screen region
rite Pane·new(id, region, shell) {
    ≔ pty = Pty·open();
    Pty·set_size(pty.master_fd, region.h - 2, region.w - 2);

    ≔ pid = Sys·spawn_pty(shell, [], pty.slave_fd);

    // VTerm interior dimensions (region minus border)
    ≔ vt = VTerm·new(region.h - 2, region.w - 2);

    ≔ pane = {
        id: id,
        region: region,
        master_fd: pty.master_fd,
        slave_fd: pty.slave_fd,
        pid: pid,
        alive: true,
        title: "bash",
        vterm: vt,
        pane_type: "terminal"
    };
    ↩ pane
}

// A Monitor Pane: no PTY, renders system info
rite MonitorPane·new(id, region) {
    ≔ vt = VTerm·new(region.h - 2, region.w - 2);

    ≔ pane = {
        id: id,
        region: region,
        master_fd: -1,
        slave_fd: -1,
        pid: -1,
        alive: false,
        title: "monitor",
        vterm: vt,
        pane_type: "monitor"
    };
    ↩ pane
}

// ============================================================================
// Section 2b: VTerm — Virtual Terminal Emulator
// ============================================================================

// Create a new VTerm with given interior dimensions
rite VTerm·new(rows, cols) {
    ≔ total = rows * cols;
    ≔ mut cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, {ch: " ", fg: 7, bg: 0});
        i = i + 1;
    }
    ≔ vt = {
        cells: cells,
        rows: rows,
        cols: cols,
        cursor_row: 0,
        cursor_col: 0,
        attr_fg: 7,
        attr_bg: 0,
        esc_state: "normal",
        esc_buf: "",
        scroll_top: 0,
        scroll_bottom: rows - 1,
        saved_row: 0,
        saved_col: 0,
        scrollback: [],
        scrollback_max: 1000,
        scroll_offset: 0,
        alt_cells: [],
        alt_cursor_row: 0,
        alt_cursor_col: 0,
        alt_attr_fg: 7,
        alt_attr_bg: 0,
        in_alt_screen: false,
        cursor_visible: true,
        app_cursor_keys: false,
        auto_wrap: true,
        bracketed_paste: false,
        mouse_mode: 0,
        mouse_sgr: false,
        origin_mode: false,
        title: ""
    };
    ↩ vt
}

// Scroll the VTerm up by one line (evict top line of scroll region)
rite vterm_scroll_up(vt) {
    // Save evicted line to scrollback (only in main screen)
    ⎇ vt.in_alt_screen == false {
        ≔ mut evicted = [];
        ≔ mut ec = 0;
        ⟳ ec < vt.cols {
            ≔ idx = vt.scroll_top * vt.cols + ec;
            push(evicted, vt.cells[idx]);
            ec = ec + 1;
        }
        push(vt.scrollback, evicted);
        // Trim scrollback if over max
        ⎇ len(vt.scrollback) > vt.scrollback_max {
            // Remove oldest by rebuilding (drop first element)
            ≔ mut trimmed = [];
            ≔ mut ti = 1;
            ⟳ ti < len(vt.scrollback) {
                push(trimmed, vt.scrollback[ti]);
                ti = ti + 1;
            }
            vt.scrollback = trimmed;
        }
    }

    // Shift lines up within scroll region
    ≔ mut row = vt.scroll_top;
    ⟳ row < vt.scroll_bottom {
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            ≔ dst = row * vt.cols + col;
            ≔ src = (row + 1) * vt.cols + col;
            vt.cells[dst] = vt.cells[src];
            col = col + 1;
        }
        row = row + 1;
    }
    // Clear the bottom line of scroll region
    ≔ mut col = 0;
    ⟳ col < vt.cols {
        ≔ idx = vt.scroll_bottom * vt.cols + col;
        vt.cells[idx] = {ch: " ", fg: 7, bg: 0};
        col = col + 1;
    }
}

// Resize the VTerm grid in-place, preserving scrollback
rite vterm_resize(vt, new_rows, new_cols) {
    ≔ old_rows = vt.rows;
    ≔ old_cols = vt.cols;

    // 1. Push overflow rows to scrollback (shrink only, main screen only)
    ⎇ new_rows < old_rows ∧ vt.in_alt_screen == false {
        ≔ overflow = old_rows - new_rows;
        ≔ mut i = 0;
        ⟳ i < overflow {
            ≔ mut row_cells = [];
            ≔ mut c = 0;
            ⟳ c < old_cols {
                push(row_cells, vt.cells[i * old_cols + c]);
                c = c + 1;
            }
            push(vt.scrollback, row_cells);
            i = i + 1;
        }
        ⟳ len(vt.scrollback) > vt.scrollback_max {
            ≔ mut trimmed = [];
            ≔ mut ti = 1;
            ⟳ ti < len(vt.scrollback) {
                push(trimmed, vt.scrollback[ti]);
                ti = ti + 1;
            }
            vt.scrollback = trimmed;
        }
    }

    // 2. Build new flat cell array
    ≔ mut new_cells = [];
    ≔ mut r = 0;
    ⟳ r < new_rows {
        ≔ old_r = r + (old_rows - new_rows);
        ≔ mut c = 0;
        ⟳ c < new_cols {
            ⎇ old_r >= 0 ∧ old_r < old_rows ∧ c < old_cols {
                push(new_cells, vt.cells[old_r * old_cols + c]);
            } ⎉ {
                push(new_cells, {ch: " ", fg: 7, bg: 0});
            }
            c = c + 1;
        }
        r = r + 1;
    }

    // 3. Update state
    vt.cells = new_cells;
    vt.rows = new_rows;
    vt.cols = new_cols;
    vt.scroll_top = 0;
    vt.scroll_bottom = new_rows - 1;
    vt.scroll_offset = 0;

    // 4. Clamp cursor
    ⎇ vt.cursor_row >= new_rows { vt.cursor_row = new_rows - 1; }
    ⎇ vt.cursor_col >= new_cols { vt.cursor_col = new_cols - 1; }

    // 5. Discard alt screen (rebuilt on next enter)
    vt.alt_cells = [];
}

// Write a printable character at the cursor position
// ch should be a string (use to_string(char_at(...)) when feeding)
rite vterm_put_char(vt, ch) {
    // Fullwidth char at last column: wrap early (can't split across lines)
    ⎇ is_fullwidth(ch) == true ∧ vt.cursor_col == vt.cols - 1 ∧ vt.auto_wrap == true {
        vt.cursor_col = vt.cols;
    }
    // Handle line wrap (respects auto_wrap flag)
    ⎇ vt.cursor_col >= vt.cols {
        ⎇ vt.auto_wrap == true {
            vt.cursor_col = 0;
            vt.cursor_row = vt.cursor_row + 1;
            ⎇ vt.cursor_row > vt.scroll_bottom {
                vterm_scroll_up(vt);
                vt.cursor_row = vt.scroll_bottom;
            }
        } ⎉ {
            // No wrap: stay at last column
            vt.cursor_col = vt.cols - 1;
        }
    }

    ≔ idx = vt.cursor_row * vt.cols + vt.cursor_col;
    ⎇ idx >= 0 ∧ idx < len(vt.cells) {
        vt.cells[idx] = {ch: ch, fg: vt.attr_fg, bg: vt.attr_bg};
    }
    // Fullwidth characters occupy 2 columns
    ⎇ is_fullwidth(ch) == true {
        ⎇ vt.cursor_col + 1 < vt.cols {
            ≔ idx2 = vt.cursor_row * vt.cols + vt.cursor_col + 1;
            ⎇ idx2 >= 0 ∧ idx2 < len(vt.cells) {
                vt.cells[idx2] = {ch: "", fg: vt.attr_fg, bg: vt.attr_bg};
            }
        }
        vt.cursor_col = vt.cursor_col + 2;
    } ⎉ {
        vt.cursor_col = vt.cursor_col + 1;
    }
}

// Parse CSI parameters string into array of ints
rite vterm_parse_params(buf) {
    ≔ mut params = [];
    ⎇ buf != "" {
        ≔ parts = split(buf, ";");
        ≔ mut i = 0;
        ⟳ i < len(parts) {
            ⎇ parts[i] == "" {
                push(params, 0);
            } ⎉ {
                push(params, to_int(parts[i]));
            }
            i = i + 1;
        }
    }
    params
}

// Dispatch a CSI command
rite vterm_csi_dispatch(vt, cmd, buf) {
    // DEC private mode: CSI ? prefix
    ≔ mut dec_handled = false;
    ⎇ len(buf) > 0 ∧ starts_with(buf, "?") == true {
        ≔ stripped = substring(buf, 1, len(buf));
        vterm_dec_private_dispatch(vt, cmd, stripped);
        dec_handled = true;
    }

  ⎇ dec_handled == false {
    ≔ params = vterm_parse_params(buf);
    ≔ mut n = 0;
    ⎇ len(params) > 0 {
        n = params[0];
    }

    // SGR - Set Graphics Rendition
    ⎇ cmd == "m" {
        ⎇ len(params) == 0 {
            // CSI m = reset
            vt.attr_fg = 7;
            vt.attr_bg = 0;
        } ⎉ {
            ≔ mut pi = 0;
            ⟳ pi < len(params) {
                ≔ p = params[pi];
                ⎇ p == 0 {
                    vt.attr_fg = 7;
                    vt.attr_bg = 0;
                }
                ⎇ p == 1 {
                    // Bold — brighten fg by adding 8
                    ⎇ vt.attr_fg < 8 {
                        vt.attr_fg = vt.attr_fg + 8;
                    }
                }
                // Italic (3) and underline (4) — accept silently
                ⎇ p == 3 ∨ p == 4 {
                    // Visual attributes not tracked separately
                }
                // Inverse video (7) — swap fg/bg
                ⎇ p == 7 {
                    ≔ tmp_fg = vt.attr_fg;
                    vt.attr_fg = vt.attr_bg;
                    vt.attr_bg = tmp_fg;
                }
                // Reverse inverse (27) — swap back
                ⎇ p == 27 {
                    ≔ tmp_fg = vt.attr_fg;
                    vt.attr_fg = vt.attr_bg;
                    vt.attr_bg = tmp_fg;
                }
                // Standard foreground: 30-37
                ⎇ p >= 30 ∧ p <= 37 {
                    vt.attr_fg = p - 30;
                }
                // Default foreground (39)
                ⎇ p == 39 {
                    vt.attr_fg = 7;
                }
                // Standard background: 40-47
                ⎇ p >= 40 ∧ p <= 47 {
                    vt.attr_bg = p - 40;
                }
                // Default background (49)
                ⎇ p == 49 {
                    vt.attr_bg = 0;
                }
                // 256-color foreground: 38;5;N
                ⎇ p == 38 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 5 ∧ pi + 2 < len(params) {
                    vt.attr_fg = params[pi + 2];
                    pi = pi + 2;
                }
                // 256-color background: 48;5;N
                ⎇ p == 48 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 5 ∧ pi + 2 < len(params) {
                    vt.attr_bg = params[pi + 2];
                    pi = pi + 2;
                }
                // True color foreground: 38;2;R;G;B (packed int: 256 + R*65536 + G*256 + B)
                ⎇ p == 38 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 2 ∧ pi + 4 < len(params) {
                    vt.attr_fg = 256 + params[pi + 2] * 65536 + params[pi + 3] * 256 + params[pi + 4];
                    pi = pi + 4;
                }
                // True color background: 48;2;R;G;B (packed int: 256 + R*65536 + G*256 + B)
                ⎇ p == 48 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 2 ∧ pi + 4 < len(params) {
                    vt.attr_bg = 256 + params[pi + 2] * 65536 + params[pi + 3] * 256 + params[pi + 4];
                    pi = pi + 4;
                }
                // Bright foreground: 90-97
                ⎇ p >= 90 ∧ p <= 97 {
                    vt.attr_fg = p - 90 + 8;
                }
                // Bright background: 100-107
                ⎇ p >= 100 ∧ p <= 107 {
                    vt.attr_bg = p - 100 + 8;
                }
                pi = pi + 1;
            }
        }
    }

    // CUP - Cursor Position: CSI row;col H
    ⎇ cmd == "H" ∨ cmd == "f" {
        ≔ mut row = 1;
        ≔ mut col = 1;
        ⎇ len(params) >= 1 ∧ params[0] > 0 {
            row = params[0];
        }
        ⎇ len(params) >= 2 ∧ params[1] > 0 {
            col = params[1];
        }
        vt.cursor_row = row - 1;
        vt.cursor_col = col - 1;
        // Clamp
        ⎇ vt.cursor_row >= vt.rows {
            vt.cursor_row = vt.rows - 1;
        }
        ⎇ vt.cursor_col >= vt.cols {
            vt.cursor_col = vt.cols - 1;
        }
    }

    // ED - Erase Display: CSI n J
    ⎇ cmd == "J" {
        ⎇ n == 0 {
            // Erase from cursor to end
            ≔ mut r = vt.cursor_row;
            ⟳ r < vt.rows {
                ≔ mut c_start = 0;
                ⎇ r == vt.cursor_row {
                    c_start = vt.cursor_col;
                }
                ≔ mut c = c_start;
                ⟳ c < vt.cols {
                    vt.cells[r * vt.cols + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
                r = r + 1;
            }
        }
        ⎇ n == 1 {
            // Erase from start to cursor
            ≔ mut r = 0;
            ⟳ r <= vt.cursor_row {
                ≔ mut c_end = vt.cols;
                ⎇ r == vt.cursor_row {
                    c_end = vt.cursor_col + 1;
                }
                ≔ mut c = 0;
                ⟳ c < c_end {
                    vt.cells[r * vt.cols + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
                r = r + 1;
            }
        }
        ⎇ n == 2 ∨ n == 3 {
            // Erase all
            ≔ mut ei = 0;
            ⟳ ei < len(vt.cells) {
                vt.cells[ei] = {ch: " ", fg: 7, bg: 0};
                ei = ei + 1;
            }
        }
    }

    // EL - Erase Line: CSI n K
    ⎇ cmd == "K" {
        ≔ row_start = vt.cursor_row * vt.cols;
        ⎇ n == 0 {
            // Erase from cursor to end of line
            ≔ mut c = vt.cursor_col;
            ⟳ c < vt.cols {
                vt.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                c = c + 1;
            }
        }
        ⎇ n == 1 {
            // Erase from start of line to cursor
            ≔ mut c = 0;
            ⟳ c <= vt.cursor_col {
                vt.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                c = c + 1;
            }
        }
        ⎇ n == 2 {
            // Erase entire line
            ≔ mut c = 0;
            ⟳ c < vt.cols {
                vt.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                c = c + 1;
            }
        }
    }

    // CUU - Cursor Up: CSI n A
    ⎇ cmd == "A" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_row = vt.cursor_row - amount;
        ⎇ vt.cursor_row < 0 {
            vt.cursor_row = 0;
        }
    }

    // CUD - Cursor Down: CSI n B
    ⎇ cmd == "B" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_row = vt.cursor_row + amount;
        ⎇ vt.cursor_row >= vt.rows {
            vt.cursor_row = vt.rows - 1;
        }
    }

    // CUF - Cursor Forward: CSI n C
    ⎇ cmd == "C" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_col = vt.cursor_col + amount;
        ⎇ vt.cursor_col >= vt.cols {
            vt.cursor_col = vt.cols - 1;
        }
    }

    // CUB - Cursor Back: CSI n D
    ⎇ cmd == "D" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_col = vt.cursor_col - amount;
        ⎇ vt.cursor_col < 0 {
            vt.cursor_col = 0;
        }
    }

    // CHA - Cursor Horizontal Absolute: CSI n G
    ⎇ cmd == "G" {
        ≔ mut col = 1;
        ⎇ n > 0 {
            col = n;
        }
        vt.cursor_col = col - 1;
        ⎇ vt.cursor_col >= vt.cols {
            vt.cursor_col = vt.cols - 1;
        }
    }

    // VPA - Vertical Position Absolute: CSI n d
    ⎇ cmd == "d" {
        ≔ mut row = 1;
        ⎇ n > 0 {
            row = n;
        }
        vt.cursor_row = row - 1;
        ⎇ vt.cursor_row >= vt.rows {
            vt.cursor_row = vt.rows - 1;
        }
    }

    // DECSTBM - Set Top/Bottom Margins: CSI top;bottom r
    ⎇ cmd == "r" {
        ≔ mut top = 1;
        ≔ mut bottom = vt.rows;
        ⎇ len(params) >= 1 ∧ params[0] > 0 {
            top = params[0];
        }
        ⎇ len(params) >= 2 ∧ params[1] > 0 {
            bottom = params[1];
        }
        vt.scroll_top = top - 1;
        vt.scroll_bottom = bottom - 1;
        // Clamp
        ⎇ vt.scroll_top < 0 {
            vt.scroll_top = 0;
        }
        ⎇ vt.scroll_bottom >= vt.rows {
            vt.scroll_bottom = vt.rows - 1;
        }
        // Move cursor to home
        vt.cursor_row = 0;
        vt.cursor_col = 0;
    }

    // Save cursor: CSI s
    ⎇ cmd == "s" {
        vt.saved_row = vt.cursor_row;
        vt.saved_col = vt.cursor_col;
    }

    // Restore cursor: CSI u
    ⎇ cmd == "u" {
        vt.cursor_row = vt.saved_row;
        vt.cursor_col = vt.saved_col;
    }

    // IL - Insert Lines: CSI n L
    ⎇ cmd == "L" {
        ≔ mut count = 1;
        ⎇ n > 0 { count = n; }
        // Shift lines down from cursor row, clear inserted lines
        ≔ mut ci = 0;
        ⟳ ci < count {
            ≔ mut row = vt.scroll_bottom;
            ⟳ row > vt.cursor_row {
                ≔ mut col = 0;
                ⟳ col < vt.cols {
                    vt.cells[row * vt.cols + col] = vt.cells[(row - 1) * vt.cols + col];
                    col = col + 1;
                }
                row = row - 1;
            }
            // Clear the inserted line
            ≔ mut col = 0;
            ⟳ col < vt.cols {
                vt.cells[vt.cursor_row * vt.cols + col] = {ch: " ", fg: 7, bg: 0};
                col = col + 1;
            }
            ci = ci + 1;
        }
    }

    // DL - Delete Lines: CSI n M
    ⎇ cmd == "M" {
        ≔ mut count = 1;
        ⎇ n > 0 { count = n; }
        ≔ mut ci = 0;
        ⟳ ci < count {
            ≔ mut row = vt.cursor_row;
            ⟳ row < vt.scroll_bottom {
                ≔ mut col = 0;
                ⟳ col < vt.cols {
                    vt.cells[row * vt.cols + col] = vt.cells[(row + 1) * vt.cols + col];
                    col = col + 1;
                }
                row = row + 1;
            }
            // Clear the bottom line
            ≔ mut col = 0;
            ⟳ col < vt.cols {
                vt.cells[vt.scroll_bottom * vt.cols + col] = {ch: " ", fg: 7, bg: 0};
                col = col + 1;
            }
            ci = ci + 1;
        }
    }

    // ICH - Insert Characters: CSI n @
    ⎇ cmd == "@" {
        ≔ mut count = 1;
        ⎇ n > 0 { count = n; }
        ≔ row_base = vt.cursor_row * vt.cols;
        // Shift chars right from end of line
        ≔ mut col = vt.cols - 1;
        ⟳ col >= vt.cursor_col + count {
            vt.cells[row_base + col] = vt.cells[row_base + col - count];
            col = col - 1;
        }
        // Clear inserted positions
        ≔ mut ci = 0;
        ⟳ ci < count ∧ vt.cursor_col + ci < vt.cols {
            vt.cells[row_base + vt.cursor_col + ci] = {ch: " ", fg: 7, bg: 0};
            ci = ci + 1;
        }
    }

    // DCH - Delete Characters: CSI n P
    ⎇ cmd == "P" {
        ≔ mut count = 1;
        ⎇ n > 0 { count = n; }
        ≔ row_base = vt.cursor_row * vt.cols;
        // Shift chars left
        ≔ mut col = vt.cursor_col;
        ⟳ col + count < vt.cols {
            vt.cells[row_base + col] = vt.cells[row_base + col + count];
            col = col + 1;
        }
        // Clear vacated positions at end
        ≔ mut ci = 0;
        ⟳ ci < count {
            ≔ clear_col = vt.cols - 1 - ci;
            ⎇ clear_col >= 0 {
                vt.cells[row_base + clear_col] = {ch: " ", fg: 7, bg: 0};
            }
            ci = ci + 1;
        }
    }

    // ECH - Erase Characters: CSI n X
    ⎇ cmd == "X" {
        ≔ mut count = 1;
        ⎇ n > 0 { count = n; }
        ≔ row_base = vt.cursor_row * vt.cols;
        ≔ mut ci = 0;
        ⟳ ci < count ∧ vt.cursor_col + ci < vt.cols {
            vt.cells[row_base + vt.cursor_col + ci] = {ch: " ", fg: 7, bg: 0};
            ci = ci + 1;
        }
    }

    // CNL - Cursor Next Line: CSI n E
    ⎇ cmd == "E" {
        ≔ mut amount = 1;
        ⎇ n > 0 { amount = n; }
        vt.cursor_row = vt.cursor_row + amount;
        ⎇ vt.cursor_row >= vt.rows { vt.cursor_row = vt.rows - 1; }
        vt.cursor_col = 0;
    }

    // CPL - Cursor Previous Line: CSI n F
    ⎇ cmd == "F" {
        ≔ mut amount = 1;
        ⎇ n > 0 { amount = n; }
        vt.cursor_row = vt.cursor_row - amount;
        ⎇ vt.cursor_row < 0 { vt.cursor_row = 0; }
        vt.cursor_col = 0;
    }
  }
}

// Enter alternate screen buffer
rite vterm_enter_alt_screen(vt) {
    // Save main screen cells
    ≔ mut saved = [];
    ≔ mut i = 0;
    ⟳ i < len(vt.cells) {
        push(saved, {ch: vt.cells[i].ch, fg: vt.cells[i].fg, bg: vt.cells[i].bg});
        i = i + 1;
    }
    vt.alt_cells = saved;
    // Save cursor and attributes
    vt.alt_cursor_row = vt.cursor_row;
    vt.alt_cursor_col = vt.cursor_col;
    vt.alt_attr_fg = vt.attr_fg;
    vt.alt_attr_bg = vt.attr_bg;
    // Clear screen
    ≔ mut ci = 0;
    ⟳ ci < len(vt.cells) {
        vt.cells[ci] = {ch: " ", fg: 7, bg: 0};
        ci = ci + 1;
    }
    vt.cursor_row = 0;
    vt.cursor_col = 0;
    vt.in_alt_screen = true;
}

// Leave alternate screen buffer
rite vterm_leave_alt_screen(vt) {
    // Restore main screen cells
    ⎇ len(vt.alt_cells) > 0 {
        ≔ mut i = 0;
        ⟳ i < len(vt.alt_cells) ∧ i < len(vt.cells) {
            vt.cells[i] = vt.alt_cells[i];
            i = i + 1;
        }
    }
    // Restore cursor and attributes
    vt.cursor_row = vt.alt_cursor_row;
    vt.cursor_col = vt.alt_cursor_col;
    vt.attr_fg = vt.alt_attr_fg;
    vt.attr_bg = vt.alt_attr_bg;
    vt.alt_cells = [];
    vt.in_alt_screen = false;
}

// Set a DEC private mode on or off
rite vterm_set_dec_mode(vt, mode, enabled) {
    // ?1 - Application cursor keys
    ⎇ mode == 1 {
        vt.app_cursor_keys = enabled;
    }
    // ?6 - Origin mode
    ⎇ mode == 6 {
        vt.origin_mode = enabled;
    }
    // ?7 - Auto-wrap
    ⎇ mode == 7 {
        vt.auto_wrap = enabled;
    }
    // ?25 - Cursor visible
    ⎇ mode == 25 {
        vt.cursor_visible = enabled;
    }
    // ?1000 - Mouse tracking (normal)
    ⎇ mode == 1000 {
        ⎇ enabled == true {
            vt.mouse_mode = 1000;
        } ⎉ {
            vt.mouse_mode = 0;
        }
    }
    // ?1002 - Mouse button tracking
    ⎇ mode == 1002 {
        ⎇ enabled == true {
            vt.mouse_mode = 1002;
        } ⎉ {
            vt.mouse_mode = 0;
        }
    }
    // ?1003 - Mouse any-event tracking
    ⎇ mode == 1003 {
        ⎇ enabled == true {
            vt.mouse_mode = 1003;
        } ⎉ {
            vt.mouse_mode = 0;
        }
    }
    // ?1006 - SGR mouse mode
    ⎇ mode == 1006 {
        vt.mouse_sgr = enabled;
    }
    // ?1049 - Alternate screen buffer (save/restore)
    ⎇ mode == 1049 {
        ⎇ enabled == true {
            vterm_enter_alt_screen(vt);
        } ⎉ {
            vterm_leave_alt_screen(vt);
        }
    }
    // ?2004 - Bracketed paste
    ⎇ mode == 2004 {
        vt.bracketed_paste = enabled;
    }
}

// Dispatch DEC private mode sequence (after ? stripped)
rite vterm_dec_private_dispatch(vt, cmd, buf) {
    ≔ params = vterm_parse_params(buf);
    ≔ mut enabled = false;
    ⎇ cmd == "h" {
        enabled = true;
    }
    ≔ mut i = 0;
    ⟳ i < len(params) {
        vterm_set_dec_mode(vt, params[i], enabled);
        i = i + 1;
    }
}

// Reverse index: move cursor up; if at scroll_top, shift lines down
rite vterm_reverse_index(vt) {
    ⎇ vt.cursor_row == vt.scroll_top {
        // Shift lines down within scroll region
        ≔ mut row = vt.scroll_bottom;
        ⟳ row > vt.scroll_top {
            ≔ mut col = 0;
            ⟳ col < vt.cols {
                ≔ dst = row * vt.cols + col;
                ≔ src = (row - 1) * vt.cols + col;
                vt.cells[dst] = vt.cells[src];
                col = col + 1;
            }
            row = row - 1;
        }
        // Clear the top line of scroll region
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            vt.cells[vt.scroll_top * vt.cols + col] = {ch: " ", fg: 7, bg: 0};
            col = col + 1;
        }
    } ⎉ {
        ⎇ vt.cursor_row > 0 {
            vt.cursor_row = vt.cursor_row - 1;
        }
    }
}

// Dispatch an OSC sequence
rite vterm_osc_dispatch(vt, buf) {
    // Find the first semicolon to separate command from payload
    ≔ mut sep_idx = -1;
    ≔ mut si = 0;
    ⟳ si < len(buf) {
        ⎇ to_string(char_at(buf, si)) == ";" {
            ⎇ sep_idx == -1 {
                sep_idx = si;
            }
        }
        si = si + 1;
    }
    ⎇ sep_idx >= 0 {
        ≔ cmd_str = substring(buf, 0, sep_idx);
        ≔ payload = substring(buf, sep_idx + 1, len(buf));
        // OSC 0 and OSC 2 set title
        ⎇ cmd_str == "0" ∨ cmd_str == "2" {
            vt.title = payload;
        }
    }
}

// Feed a string of data through the VTerm state machine
rite vterm_feed(vt, data) {
    ≔ mut i = 0;
    ⟳ i < len(data) {
        ≔ ch = to_string(char_at(data, i));
        ≔ code = char_code_at(data, i);

        // State machine: exactly ONE handler fires per byte (⎇/⎉ chain)
        ⎇ vt.esc_state == "csi" {
            ⎇ (code >= 64 ∧ code <= 90) ∨ (code >= 97 ∧ code <= 122) {
                vterm_csi_dispatch(vt, ch, vt.esc_buf);
                vt.esc_state = "normal";
                vt.esc_buf = "";
            } ⎉ {
                vt.esc_buf = vt.esc_buf + ch;
            }
        } ⎉ { ⎇ vt.esc_state == "osc" {
            ⎇ code == 7 {
                vterm_osc_dispatch(vt, vt.esc_buf);
                vt.esc_state = "normal";
                vt.esc_buf = "";
            } ⎉ { ⎇ code == 27 {
                vt.esc_state = "osc_esc";
            } ⎉ {
                vt.esc_buf = vt.esc_buf + ch;
            } }
        } ⎉ { ⎇ vt.esc_state == "osc_esc" {
            ⎇ ch == "\\" {
                vterm_osc_dispatch(vt, vt.esc_buf);
                vt.esc_state = "normal";
                vt.esc_buf = "";
            } ⎉ {
                vterm_osc_dispatch(vt, vt.esc_buf);
                vt.esc_state = "escape";
                vt.esc_buf = "";
            }
        } ⎉ { ⎇ vt.esc_state == "dcs" {
            ⎇ code == 27 {
                vt.esc_state = "dcs_esc";
            }
        } ⎉ { ⎇ vt.esc_state == "dcs_esc" {
            ⎇ ch == "\\" {
                vt.esc_state = "normal";
                vt.esc_buf = "";
            } ⎉ {
                vt.esc_state = "dcs";
            }
        } ⎉ { ⎇ vt.esc_state == "charset" {
            vt.esc_state = "normal";
        } ⎉ { ⎇ vt.esc_state == "escape" {
            ⎇ ch == "[" {
                vt.esc_state = "csi";
                vt.esc_buf = "";
            } ⎉ { ⎇ ch == "]" {
                vt.esc_state = "osc";
                vt.esc_buf = "";
            } ⎉ { ⎇ ch == "P" {
                vt.esc_state = "dcs";
                vt.esc_buf = "";
            } ⎉ { ⎇ ch == "(" ∨ ch == ")" ∨ ch == "*" ∨ ch == "+" {
                vt.esc_state = "charset";
            } ⎉ { ⎇ ch == "7" {
                vt.saved_row = vt.cursor_row;
                vt.saved_col = vt.cursor_col;
                vt.esc_state = "normal";
            } ⎉ { ⎇ ch == "8" {
                vt.cursor_row = vt.saved_row;
                vt.cursor_col = vt.saved_col;
                vt.esc_state = "normal";
            } ⎉ { ⎇ ch == "M" {
                vterm_reverse_index(vt);
                vt.esc_state = "normal";
            } ⎉ {
                // Unknown escape sequence, reset
                vt.esc_state = "normal";
            } } } } } } }
        } ⎉ {
            // Normal state
            ⎇ code == 27 {
                vt.esc_state = "escape";
                vt.esc_buf = "";
            }
            ⎇ code == 13 { vt.cursor_col = 0; }
            ⎇ code == 10 {
                vt.cursor_col = 0;  // LF implies CR for internal feeds
                vt.cursor_row = vt.cursor_row + 1;
                ⎇ vt.cursor_row > vt.scroll_bottom {
                    vterm_scroll_up(vt);
                    vt.cursor_row = vt.scroll_bottom;
                }
            }
            ⎇ code == 8 {
                ⎇ vt.cursor_col > 0 { vt.cursor_col = vt.cursor_col - 1; }
            }
            ⎇ code == 9 {
                vt.cursor_col = ((vt.cursor_col / 8) + 1) * 8;
                ⎇ vt.cursor_col >= vt.cols { vt.cursor_col = vt.cols - 1; }
            }
            ⎇ code >= 32 { vterm_put_char(vt, ch); }
        } } } } } } }

        i = i + 1;
    }
    // Reset scroll offset on new data
    vt.scroll_offset = 0;
}

// Blit VTerm cells to the main Grid at the given region (inside borders)
rite vterm_blit(vt, grid, region) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;

    // Check if scrolled back
    ⎇ vt.scroll_offset > 0 ∧ len(vt.scrollback) > 0 {
        // Render from scrollback
        ≔ mut sb_start = len(vt.scrollback) - vt.scroll_offset;
        ⎇ sb_start < 0 {
            sb_start = 0;
        }
        ≔ mut row = 0;
        ⟳ row < vt.rows {
            ≔ sb_idx = sb_start + row;
            ⎇ sb_idx < len(vt.scrollback) {
                // Render scrollback line
                ≔ line = vt.scrollback[sb_idx];
                ≔ mut col = 0;
                ⟳ col < vt.cols ∧ col < len(line) {
                    Grid·set(grid, inner_y + row, inner_x + col, line[col].ch, line[col].fg, line[col].bg);
                    col = col + 1;
                }
            } ⎉ {
                // Render from live buffer (for lines beyond scrollback)
                ≔ live_row = row - (len(vt.scrollback) - sb_start);
                ⎇ live_row >= 0 ∧ live_row < vt.rows {
                    ≔ mut col = 0;
                    ⟳ col < vt.cols {
                        ≔ idx = live_row * vt.cols + col;
                        Grid·set(grid, inner_y + row, inner_x + col, vt.cells[idx].ch, vt.cells[idx].fg, vt.cells[idx].bg);
                        col = col + 1;
                    }
                }
            }
            row = row + 1;
        }
    } ⎉ {
        // Live view — render directly from VTerm cells
        ≔ mut row = 0;
        ⟳ row < vt.rows {
            ≔ mut col = 0;
            ⟳ col < vt.cols {
                ≔ idx = row * vt.cols + col;
                ⎇ idx < len(vt.cells) {
                    Grid·set(grid, inner_y + row, inner_x + col, vt.cells[idx].ch, vt.cells[idx].fg, vt.cells[idx].bg);
                }
                col = col + 1;
            }
            row = row + 1;
        }
    }
}

// ============================================================================
// Section 2c: Configuration
// ============================================================================

// Load config from ~/.morgoth/config.json, return defaults if missing
rite load_config() {
    ≔ home = env("HOME");
    ≔ config_path = home + "/.morgoth/config.json";

    ≔ mut cfg = {
        shell: "/bin/bash",
        scrollback_lines: 1000,
        leader_key: 2,
        hmr: true,
        max_panes: 12
    };

    ⎇ fs_exists(config_path) == true {
        ≔ raw = fs_read(config_path);
        ≔ j = json_parse(raw);

        // grid and panes keys are ignored (Phase 9: profiles replace static config)
        ≔ j_shell = map_get(j, "shell");
        ⎇ j_shell != null { cfg.shell = j_shell; }
        ≔ j_scrollback = map_get(j, "scrollback_lines");
        ⎇ j_scrollback != null { cfg.scrollback_lines = j_scrollback; }
        ≔ j_leader = map_get(j, "leader_key");
        ⎇ j_leader != null { cfg.leader_key = j_leader; }
        ≔ j_hmr = map_get(j, "hmr");
        ⎇ j_hmr != null { cfg.hmr = j_hmr; }
        ≔ j_max = map_get(j, "max_panes");
        ⎇ j_max != null { cfg.max_panes = j_max; }

    }

    ↩ cfg
}

// Load startup pane types from profile (or default to single terminal)
rite load_profile() {
    ≔ home = env("HOME");
    ≔ profile_path = home + "/.morgoth/profiles/default.json";
    ≔ mut panes = [];
    push(panes, "terminal");
    ⎇ fs_exists(profile_path) == true {
        ≔ raw = fs_read(profile_path);
        ≔ j = json_parse(raw);
        ≔ j_panes = map_get(j, "panes");
        ⎇ j_panes != null ∧ len(j_panes) > 0 {
            panes = j_panes;
        }
    }
    ↩ panes
}

// Save current pane layout to profile
rite save_profile(panes) {
    ≔ home = env("HOME");
    ≔ dir_path = home + "/.morgoth/profiles";
    ⎇ fs_exists(dir_path) == false {
        fs_mkdir(dir_path);
    }
    ≔ mut types = [];
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        push(types, panes[i].pane_type);
        i = i + 1;
    }
    ≔ profile = { panes: types };
    ≔ json = json_stringify(profile);
    fs_write(dir_path + "/default.json", json);
}

// ============================================================================
// Section 3: Layout Engine
// ============================================================================

// Auto-size grid dimensions to minimize aspect ratio distortion
// Uses ceiling division: (n + d - 1) / d since Sigil int division truncates
rite recompute_grid(num_panes, screen_h, screen_w) {
    ≔ usable_h = screen_h - 1;
    ≔ mut best_rows = 1;
    ≔ mut best_cols = num_panes;
    ≔ mut best_diff = 999999;
    ≔ mut r = 1;
    ⟳ r * r <= num_panes {
        ≔ c = (num_panes + r - 1) / r;
        ≔ pane_h = usable_h / r;
        ≔ pane_w = screen_w / c;
        ≔ mut diff = pane_w - pane_h * 2;
        ⎇ diff < 0 { diff = 0 - diff; }
        ⎇ diff < best_diff {
            best_diff = diff;
            best_rows = r;
            best_cols = c;
        }
        r = r + 1;
    }
    ↩ { rows: best_rows, cols: best_cols }
}

// Relayout all panes: recompute grid, resize vterms, propagate PTY sizes, redraw
rite relayout_panes(panes, screen_w, screen_h, screen, focus) {
    ≔ grid = recompute_grid(len(panes), screen_h, screen_w);
    ≔ regions = layout_grid(grid.rows, grid.cols, screen_w, screen_h);
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        panes[i].region = regions[i];
        vterm_resize(panes[i].vterm, regions[i].h - 2, regions[i].w - 2);
        ⎇ panes[i].alive == true {
            Pty·set_size(panes[i].master_fd, regions[i].h - 2, regions[i].w - 2);
        }
        vterm_blit(panes[i].vterm, screen, panes[i].region);
        ≔ mut t = panes[i].title;
        ⎇ i == focus { t = "[" + t + "]"; }
        render_border(screen, panes[i].region, t);
        i = i + 1;
    }
    flush_dirty(screen);
    ↩ { grid_rows: grid.rows, grid_cols: grid.cols }
}

// Calculate grid layout regions for a rows x cols grid
// screen_w, screen_h = total terminal dimensions
// Returns array of Region structs (row-major order)
// Bottom row reserved for status bar
rite layout_grid(rows, cols, screen_w, screen_h) {
    ≔ usable_h = screen_h - 1;  // Reserve status bar

    ≔ base_h = usable_h / rows;
    ≔ remainder_h = usable_h % rows;

    ≔ base_w = screen_w / cols;
    ≔ remainder_w = screen_w % cols;

    ≔ regions = [];
    ≔ mut y_offset = 0;

    ≔ mut r = 0;
    ⟳ r < rows {
        ≔ mut h = base_h;
        // Give remainder to last row
        ⎇ r == rows - 1 {
            h = base_h + remainder_h;
        }

        ≔ mut x_offset = 0;
        ≔ mut c = 0;
        ⟳ c < cols {
            ≔ mut w = base_w;
            // Give remainder to last column
            ⎇ c == cols - 1 {
                w = base_w + remainder_w;
            }

            push(regions, Region·new(x_offset, y_offset, w, h));

            x_offset = x_offset + w;
            c = c + 1;
        }

        y_offset = y_offset + h;
        r = r + 1;
    }

    regions
}

// ============================================================================
// Section 4: Screen Buffer (Grid)
// ============================================================================

// Create a flat cell buffer for the screen
rite Grid·new(rows, cols) {
    ≔ total = rows * cols;
    ≔ cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, Cell·new(" ", 7, 0, true));
        i = i + 1;
    }
    ≔ grid = {
        rows: rows,
        cols: cols,
        cells: cells
    };
    ↩ grid
}

// Set a cell at (row, col) in the grid
rite Grid·set(grid, row, col, ch, fg, bg) {
    ⎇ row >= 0 ∧ row < grid.rows ∧ col >= 0 ∧ col < grid.cols {
        ≔ idx = row * grid.cols + col;
        grid.cells[idx] = Cell·new(ch, fg, bg, true);
    }
}

// Get a cell at (row, col)
rite Grid·get(grid, row, col) {
    ≔ mut result = Cell·new(" ", 7, 0, false);
    ⎇ row >= 0 ∧ row < grid.rows ∧ col >= 0 ∧ col < grid.cols {
        ≔ idx = row * grid.cols + col;
        result = grid.cells[idx];
    }
    result
}

// Count dirty cells
rite Grid·dirty_count(grid) {
    ≔ mut count = 0;
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ⟳ i < total {
        ⎇ grid.cells[i].dirty == true {
            count = count + 1;
        }
        i = i + 1;
    }
    count
}

// Clear all dirty flags
rite Grid·clear_dirty(grid) {
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ⟳ i < total {
        grid.cells[i] = Cell·new(grid.cells[i].ch, grid.cells[i].fg, grid.cells[i].bg, false);
        i = i + 1;
    }
}

// ============================================================================
// Section 5: Rendering
// ============================================================================

// Draw a border around a region in the grid
rite render_border(grid, region, title) {
    ≔ x = region.x;
    ≔ y = region.y;
    ≔ w = region.w;
    ≔ h = region.h;

    // Top edge
    Grid·set(grid, y, x, BOX_TL, 6, 0);
    ≔ mut c = 1;
    ⟳ c < w - 1 {
        Grid·set(grid, y, x + c, BOX_H, 6, 0);
        c = c + 1;
    }
    Grid·set(grid, y, x + w - 1, BOX_TR, 6, 0);

    // Bottom edge
    Grid·set(grid, y + h - 1, x, BOX_BL, 6, 0);
    c = 1;
    ⟳ c < w - 1 {
        Grid·set(grid, y + h - 1, x + c, BOX_H, 6, 0);
        c = c + 1;
    }
    Grid·set(grid, y + h - 1, x + w - 1, BOX_BR, 6, 0);

    // Side edges
    ≔ mut r = 1;
    ⟳ r < h - 1 {
        Grid·set(grid, y + r, x, BOX_V, 6, 0);
        Grid·set(grid, y + r, x + w - 1, BOX_V, 6, 0);
        r = r + 1;
    }

    // Title in top border (if provided and fits)
    ⎇ title != "" {
        ≔ max_title_cols = w - 4;
        ⎇ max_title_cols > 0 {
            ≔ mut ti = 0;
            ≔ mut tw = 0;
            ⟳ ti < len(title) ∧ tw < max_title_cols {
                ≔ tch = to_string(char_at(title, ti));
                Grid·set(grid, y, x + 2 + tw, tch, 15, 0);
                ⎇ is_fullwidth(tch) == true {
                    // Placeholder for second column of fullwidth char
                    ⎇ tw + 1 < max_title_cols {
                        Grid·set(grid, y, x + 2 + tw + 1, "", 15, 0);
                    }
                    tw = tw + 2;
                } ⎉ {
                    tw = tw + 1;
                }
                ti = ti + 1;
            }
        }
    }
}

// Write text content into the interior of a region
rite render_content(grid, region, text) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_w = region.w - 2;
    ≔ inner_h = region.h - 2;

    ≔ mut row = 0;
    ≔ mut col = 0;
    ≔ mut i = 0;
    ⟳ i < len(text) ∧ row < inner_h {
        ≔ ch = to_string(char_at(text, i));
        ⎇ ch == "\n" {
            row = row + 1;
            col = 0;
        } ⎉ {
            ⎇ col < inner_w {
                Grid·set(grid, inner_y + row, inner_x + col, ch, 7, 0);
                col = col + 1;
            }
        }
        i = i + 1;
    }
}

// Build dynamic status bar text
rite build_status_text(focus, panes, mode) {
    ≔ ptype = panes[focus].pane_type;
    ≔ idx = to_string(focus + 1) + "/" + to_string(len(panes));
    ≔ mut text = " Morgoth v" + VERSION + " | [" + idx + "] " + ptype;
    ⎇ mode == "copy" {
        text = text + " | hjkl move  Space select  / search  Enter copy  q exit";
    } ⎉ { ⎇ mode == "search" {
        text = text + " | type to search  Enter accept  Esc cancel";
    } ⎉ {
        text = text + " | c: new  x: close  z: zoom  /: search  q: quit";
    } }
    ↩ text
}

// Render status bar at the bottom of the grid
rite render_status_bar(grid, text) {
    ≔ row = grid.rows - 1;
    ≔ mut c = 0;
    // Fill with inverse video spaces
    ⟳ c < grid.cols {
        Grid·set(grid, row, c, " ", 0, 7);
        c = c + 1;
    }
    // Write status text
    ≔ mut i = 0;
    ⟳ i < len(text) ∧ i < grid.cols {
        Grid·set(grid, row, i, to_string(char_at(text, i)), 0, 7);
        i = i + 1;
    }
}

// Flush only dirty cells to stdout using ANSI escape sequences
// Batches consecutive cells on the same row to avoid redundant cursor positioning
// which can interfere with multi-byte UTF-8 character rendering.
rite flush_dirty(grid) {
    ≔ mut buf = "";
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ≔ mut last_row = -1;
    ≔ mut last_col = -1;
    ≔ mut last_fg = -1;
    ≔ mut last_bg = -1;
    ⟳ i < total {
        ⎇ grid.cells[i].dirty == true ∧ grid.cells[i].ch != "" {
            ≔ row = i / grid.cols;
            ≔ col = i % grid.cols;
            // Only reposition cursor if not consecutive with previous cell
            ⎇ row != last_row ∨ col != last_col + 1 {
                buf = buf + CSI + to_string(row + 1) + ";" + to_string(col + 1) + "H";
            }
            // Only emit color codes if they changed
            ⎇ grid.cells[i].fg != last_fg {
                ≔ fg = grid.cells[i].fg;
                ⎇ fg >= 256 {
                    ≔ raw_fg = fg - 256;
                    buf = buf + CSI + "38;2;" + to_string(raw_fg / 65536) + ";" + to_string((raw_fg % 65536) / 256) + ";" + to_string(raw_fg % 256) + "m";
                } ⎉ {
                    buf = buf + CSI + "38;5;" + to_string(fg) + "m";
                }
                last_fg = grid.cells[i].fg;
            }
            ⎇ grid.cells[i].bg != last_bg {
                ≔ bg = grid.cells[i].bg;
                ⎇ bg >= 256 {
                    ≔ raw_bg = bg - 256;
                    buf = buf + CSI + "48;2;" + to_string(raw_bg / 65536) + ";" + to_string((raw_bg % 65536) / 256) + ";" + to_string(raw_bg % 256) + "m";
                } ⎉ {
                    buf = buf + CSI + "48;5;" + to_string(bg) + "m";
                }
                last_bg = grid.cells[i].bg;
            }
            // Write character
            buf = buf + grid.cells[i].ch;
            last_row = row;
            last_col = col;
        }
        i = i + 1;
    }
    // Reset colors
    buf = buf + CSI + "0m";
    ⎇ buf != CSI + "0m" {
        Sys·write(1, buf, len(buf));
    }
    Grid·clear_dirty(grid);
}

// ============================================================================
// Section 6b: Copy Mode Functions
// ============================================================================

rite extract_text_lines(vt) {
    ≔ mut lines = [];
    // Scrollback lines (each is array of {ch, fg, bg} cells)
    ≔ mut si = 0;
    ⟳ si < len(vt.scrollback) {
        ≔ mut line = "";
        ≔ mut ci = 0;
        ⟳ ci < len(vt.scrollback[si]) {
            ⎇ vt.scrollback[si][ci].ch != "" {
                line = line + vt.scrollback[si][ci].ch;
            }
            ci = ci + 1;
        }
        push(lines, line);
        si = si + 1;
    }
    // Visible lines from flat cells array
    ≔ mut row = 0;
    ⟳ row < vt.rows {
        ≔ mut line = "";
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            ≔ idx = row * vt.cols + col;
            ⎇ idx < len(vt.cells) ∧ vt.cells[idx].ch != "" {
                line = line + vt.cells[idx].ch;
            }
            col = col + 1;
        }
        push(lines, line);
        row = row + 1;
    }
    ↩ lines
}

rite extract_selection(cm) {
    ≔ mut sr = cm.select_start_row;
    ≔ mut sc = cm.select_start_col;
    ≔ mut er = cm.cursor_row;
    ≔ mut ec = cm.cursor_col;
    // Normalize: start before end
    ⎇ sr > er ∨ (sr == er ∧ sc > ec) {
        ≔ tr = sr;
        ≔ tc = sc;
        sr = er;
        sc = ec;
        er = tr;
        ec = tc;
    }
    ≔ mut result = "";
    ⎇ cm.line_mode == true {
        ≔ mut r = sr;
        ⟳ r <= er {
            ⎇ r > sr { result = result + "\n"; }
            result = result + cm.text_lines[r];
            r = r + 1;
        }
    } ⎉ {
        ⎇ sr == er {
            result = substring(cm.text_lines[sr], sc, ec + 1);
        } ⎉ {
            result = substring(cm.text_lines[sr], sc, len(cm.text_lines[sr]));
            ≔ mut r = sr + 1;
            ⟳ r < er {
                result = result + "\n" + cm.text_lines[r];
                r = r + 1;
            }
            result = result + "\n" + substring(cm.text_lines[er], 0, ec + 1);
        }
    }
    ↩ result
}

rite write_clipboard(text) {
    ≔ encoded = base64_encode(text);
    ≔ osc = ESC + "]52;c;" + encoded + ESC + "\\";
    Sys·write(1, osc, len(osc));
}

// Search functions
rite find_all_matches(text_lines, query) {
    ≔ mut matches = [];
    ⎇ query == "" { ↩ matches }
    ≔ mut case_sensitive = false;
    ≔ mut qi = 0;
    ⟳ qi < len(query) {
        ≔ c = char_code_at(query, qi);
        ⎇ c >= 65 ∧ c <= 90 { case_sensitive = true; }
        qi = qi + 1;
    }
    ≔ mut search_q = query;
    ⎇ case_sensitive == false { search_q = lower(query); }
    ≔ mut row = 0;
    ⟳ row < len(text_lines) {
        ≔ mut line = text_lines[row];
        ⎇ case_sensitive == false { line = lower(line); }
        ≔ mut col = 0;
        ≔ mut remaining = line;
        ⟳ len(remaining) >= len(search_q) {
            ≔ idx = index_of(remaining, search_q);
            ⎇ idx >= 0 {
                push(matches, {row: row, col: col + idx});
                col = col + idx + 1;
                remaining = substring(line, col, len(line));
            } ⎉ {
                remaining = "";
            }
        }
        row = row + 1;
    }
    ↩ matches
}

rite nearest_match(matches, cursor_row, direction) {
    ⎇ len(matches) == 0 { ↩ -1 }
    ⎇ direction == "backward" {
        ≔ mut i = len(matches) - 1;
        ⟳ i >= 0 {
            ⎇ matches[i].row <= cursor_row { ↩ i }
            i = i - 1;
        }
        ↩ len(matches) - 1
    }
    ≔ mut i = 0;
    ⟳ i < len(matches) {
        ⎇ matches[i].row >= cursor_row { ↩ i }
        i = i + 1;
    }
    ↩ 0
}

rite is_search_match(cm, row, col) {
    ≔ qlen = len(cm.search_query);
    ⎇ qlen == 0 { ↩ {hit: false, current: false} }
    ≔ mut i = 0;
    ⟳ i < len(cm.search_matches) {
        ≔ m = cm.search_matches[i];
        ⎇ row == m.row ∧ col >= m.col ∧ col < m.col + qlen {
            ↩ {hit: true, current: i == cm.search_current}
        }
        i = i + 1;
    }
    ↩ {hit: false, current: false}
}

// Cursor movement
rite copy_move_up(cm) {
    ⎇ cm.cursor_row > 0 {
        cm.cursor_row = cm.cursor_row - 1;
        copy_clamp_col(cm);
    }
}

rite copy_move_down(cm) {
    ⎇ cm.cursor_row < len(cm.text_lines) - 1 {
        cm.cursor_row = cm.cursor_row + 1;
        copy_clamp_col(cm);
    }
}

rite copy_move_left(cm) {
    ⎇ cm.cursor_col > 0 { cm.cursor_col = cm.cursor_col - 1; }
}

rite copy_move_right(cm) {
    ≔ line_len = len(cm.text_lines[cm.cursor_row]);
    ⎇ cm.cursor_col < line_len - 1 {
        cm.cursor_col = cm.cursor_col + 1;
    }
}

rite copy_word_forward(cm) {
    ≔ line = cm.text_lines[cm.cursor_row];
    ≔ mut col = cm.cursor_col;
    // Skip non-space
    ⟳ col < len(line) ∧ to_string(char_at(line, col)) != " " {
        col = col + 1;
    }
    // Skip space
    ⟳ col < len(line) ∧ to_string(char_at(line, col)) == " " {
        col = col + 1;
    }
    ⎇ col >= len(line) ∧ cm.cursor_row < len(cm.text_lines) - 1 {
        cm.cursor_row = cm.cursor_row + 1;
        cm.cursor_col = 0;
    } ⎉ {
        ⎇ col < len(line) { cm.cursor_col = col; }
    }
}

rite copy_word_backward(cm) {
    ≔ mut col = cm.cursor_col;
    ⎇ col > 0 { col = col - 1; }
    ≔ line = cm.text_lines[cm.cursor_row];
    // Skip space backward
    ⟳ col > 0 ∧ to_string(char_at(line, col)) == " " {
        col = col - 1;
    }
    // Skip non-space backward
    ⟳ col > 0 ∧ to_string(char_at(line, col - 1)) != " " {
        col = col - 1;
    }
    cm.cursor_col = col;
}

rite copy_clamp_col(cm) {
    ⎇ len(cm.text_lines) > 0 ∧ cm.cursor_row < len(cm.text_lines) {
        ≔ ll = len(cm.text_lines[cm.cursor_row]);
        ⎇ ll > 0 ∧ cm.cursor_col >= ll {
            cm.cursor_col = ll - 1;
        }
        ⎇ ll == 0 {
            cm.cursor_col = 0;
        }
    }
}

rite copy_adjust_viewport(cm, inner_h) {
    ⎇ cm.cursor_row < cm.viewport_row {
        cm.viewport_row = cm.cursor_row;
    }
    ⎇ cm.cursor_row >= cm.viewport_row + inner_h {
        cm.viewport_row = cm.cursor_row - inner_h + 1;
    }
}

// Selection highlight check
rite is_selected(cm, row, col) {
    ⎇ cm.selecting == false { ↩ false }
    ≔ mut sr = cm.select_start_row;
    ≔ mut sc = cm.select_start_col;
    ≔ mut er = cm.cursor_row;
    ≔ mut ec = cm.cursor_col;
    ⎇ sr > er ∨ (sr == er ∧ sc > ec) {
        ≔ tr = sr;
        ≔ tc = sc;
        sr = er;
        sc = ec;
        er = tr;
        ec = tc;
    }
    ⎇ cm.line_mode == true {
        ↩ row >= sr ∧ row <= er
    }
    ⎇ row < sr ∨ row > er { ↩ false }
    ⎇ row == sr ∧ row == er { ↩ col >= sc ∧ col <= ec }
    ⎇ row == sr { ↩ col >= sc }
    ⎇ row == er { ↩ col <= ec }
    ↩ true
}

// Render copy mode overlay
rite render_copy_mode(grid, region, cm) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_h = region.h - 2;
    ≔ inner_w = region.w - 2;

    ≔ mut row = 0;
    ⟳ row < inner_h {
        ≔ text_row = cm.viewport_row + row;
        ≔ mut col = 0;
        ⟳ col < inner_w {
            ≔ mut ch = " ";
            ≔ mut fg = 7;
            ≔ mut bg = 0;
            ⎇ text_row < len(cm.text_lines) {
                ⎇ col < len(cm.text_lines[text_row]) {
                    ch = to_string(char_at(cm.text_lines[text_row], col));
                }
            }
            // Selection highlight (reverse video)
            ⎇ is_selected(cm, text_row, col) == true {
                ≔ tmp = fg;
                fg = bg;
                bg = tmp;
            }
            // Search match highlight
            ≔ minfo = is_search_match(cm, text_row, col);
            ⎇ minfo.hit == true {
                ⎇ minfo.current == true {
                    fg = 0;
                    bg = 3;
                } ⎉ {
                    fg = 0;
                    bg = 6;
                }
            }
            // Cursor (bright white on black)
            ⎇ text_row == cm.cursor_row ∧ col == cm.cursor_col {
                fg = 0;
                bg = 15;
            }
            Grid·set(grid, inner_y + row, inner_x + col, ch, fg, bg);
            col = col + 1;
        }
        row = row + 1;
    }
    // Search prompt on last inner row
    ⎇ cm.search_active == true {
        ≔ mut prompt = "/" + cm.search_query;
        ⎇ len(cm.search_matches) > 0 {
            prompt = prompt + " [" + to_string(cm.search_current + 1) + "/" + to_string(len(cm.search_matches)) + "]";
        } ⎉ {
            ⎇ cm.search_query != "" {
                prompt = prompt + " [Pattern not found]";
            }
        }
        ≔ mut pi = 0;
        ⟳ pi < inner_w {
            ≔ mut pch = " ";
            ⎇ pi < len(prompt) {
                pch = to_string(char_at(prompt, pi));
            }
            Grid·set(grid, inner_y + inner_h - 1, inner_x + pi, pch, 15, 0);
            pi = pi + 1;
        }
    }
}

// ============================================================================
// Section 6: Input Handling
// ============================================================================

// Copy mode state
rite CopyModeState·new() {
    ↩ {
        active: false,
        cursor_row: 0,
        cursor_col: 0,
        viewport_row: 0,
        selecting: false,
        select_start_row: 0,
        select_start_col: 0,
        line_mode: false,
        text_lines: [],
        search_active: false,
        search_query: "",
        search_matches: [],
        search_current: -1,
        search_saved_row: 0,
        search_saved_col: 0,
        search_saved_viewport: 0
    }
}

// Input state machine
rite InputState·new() {
    ≔ state = {
        leader_active: false,
        mouse_mode: true,
        escape_buf: "",
        in_escape: false,
        last_escape_buf: "",
        confirming_close: false,
        copy_mode: CopyModeState·new()
    };
    ↩ state
}

// Process a single input byte, returns action string
// Actions: "passthrough", "leader_activate", "focus_next", "focus_prev",
//          "quit", "none", "mouse:X:Y"
rite process_input(input_state, byte, pane_count) {
    // Copy mode intercept — before any other input handling
    ⎇ input_state.copy_mode.active == true {
        ≔ cm = input_state.copy_mode;
        // Search input intercept — captures all input when search is active
        ⎇ cm.search_active == true {
            ⎇ byte == 27 {
                // ESC: cancel search, restore position
                cm.search_active = false;
                cm.search_query = "";
                cm.search_matches = [];
                cm.search_current = -1;
                cm.cursor_row = cm.search_saved_row;
                cm.cursor_col = cm.search_saved_col;
                cm.viewport_row = cm.search_saved_viewport;
                ↩ "copy_render"
            } ⎉ { ⎇ byte == 13 {
                // Enter: accept search, keep position
                cm.search_active = false;
                ↩ "copy_render"
            } ⎉ { ⎇ byte == 127 ∨ byte == 8 {
                // Backspace: remove last char
                ⎇ len(cm.search_query) > 0 {
                    cm.search_query = substring(cm.search_query, 0, len(cm.search_query) - 1);
                }
                cm.search_matches = find_all_matches(cm.text_lines, cm.search_query);
                cm.search_current = nearest_match(cm.search_matches, cm.cursor_row, "backward");
                ⎇ cm.search_current >= 0 {
                    cm.cursor_row = cm.search_matches[cm.search_current].row;
                    cm.cursor_col = cm.search_matches[cm.search_current].col;
                }
                ↩ "copy_render"
            } ⎉ { ⎇ byte == 14 {
                // Ctrl-N: next match during search
                ⎇ len(cm.search_matches) > 0 {
                    cm.search_current = (cm.search_current + 1) % len(cm.search_matches);
                    cm.cursor_row = cm.search_matches[cm.search_current].row;
                    cm.cursor_col = cm.search_matches[cm.search_current].col;
                }
                ↩ "copy_render"
            } ⎉ { ⎇ byte == 16 {
                // Ctrl-P: previous match during search
                ⎇ len(cm.search_matches) > 0 {
                    cm.search_current = cm.search_current - 1;
                    ⎇ cm.search_current < 0 { cm.search_current = len(cm.search_matches) - 1; }
                    cm.cursor_row = cm.search_matches[cm.search_current].row;
                    cm.cursor_col = cm.search_matches[cm.search_current].col;
                }
                ↩ "copy_render"
            } ⎉ { ⎇ byte >= 32 ∧ byte < 127 {
                // Printable: append to query
                cm.search_query = cm.search_query + from_char_code(byte);
                cm.search_matches = find_all_matches(cm.text_lines, cm.search_query);
                cm.search_current = nearest_match(cm.search_matches, cm.cursor_row, "backward");
                ⎇ cm.search_current >= 0 {
                    cm.cursor_row = cm.search_matches[cm.search_current].row;
                    cm.cursor_col = cm.search_matches[cm.search_current].col;
                }
                ↩ "copy_render"
            } } } } } }
            ↩ "none"
        }
        // Normal copy mode keys
        ⎇ byte == 47 {
            // '/' — enter search
            cm.search_active = true;
            cm.search_query = "";
            cm.search_matches = [];
            cm.search_current = -1;
            cm.search_saved_row = cm.cursor_row;
            cm.search_saved_col = cm.cursor_col;
            cm.search_saved_viewport = cm.viewport_row;
            ↩ "copy_render"
        }
        ⎇ byte == 110 {
            // 'n' — next match
            ⎇ len(cm.search_matches) > 0 {
                cm.search_current = (cm.search_current + 1) % len(cm.search_matches);
                cm.cursor_row = cm.search_matches[cm.search_current].row;
                cm.cursor_col = cm.search_matches[cm.search_current].col;
            }
            ↩ "copy_render"
        }
        ⎇ byte == 78 {
            // 'N' — previous match
            ⎇ len(cm.search_matches) > 0 {
                cm.search_current = cm.search_current - 1;
                ⎇ cm.search_current < 0 { cm.search_current = len(cm.search_matches) - 1; }
                cm.cursor_row = cm.search_matches[cm.search_current].row;
                cm.cursor_col = cm.search_matches[cm.search_current].col;
            }
            ↩ "copy_render"
        }
        ⎇ byte == 104 { copy_move_left(cm); ↩ "copy_render" }
        ⎇ byte == 106 { copy_move_down(cm); ↩ "copy_render" }
        ⎇ byte == 107 { copy_move_up(cm); ↩ "copy_render" }
        ⎇ byte == 108 { copy_move_right(cm); ↩ "copy_render" }
        ⎇ byte == 48 {
            cm.cursor_col = 0;
            ↩ "copy_render"
        }
        ⎇ byte == 36 {
            ⎇ cm.cursor_row < len(cm.text_lines) {
                ≔ ll = len(cm.text_lines[cm.cursor_row]);
                ⎇ ll > 0 { cm.cursor_col = ll - 1; }
            }
            ↩ "copy_render"
        }
        ⎇ byte == 103 {
            cm.cursor_row = 0;
            cm.cursor_col = 0;
            ↩ "copy_render"
        }
        ⎇ byte == 71 {
            cm.cursor_row = len(cm.text_lines) - 1;
            cm.cursor_col = 0;
            ↩ "copy_render"
        }
        ⎇ byte == 21 {
            ≔ mut half = (cm.cursor_row - cm.viewport_row) / 2;
            ⎇ half < 1 { half = 5; }
            cm.cursor_row = cm.cursor_row - half;
            ⎇ cm.cursor_row < 0 { cm.cursor_row = 0; }
            copy_clamp_col(cm);
            ↩ "copy_render"
        }
        ⎇ byte == 4 {
            ≔ mut half = (len(cm.text_lines) - cm.viewport_row) / 2;
            ⎇ half < 1 { half = 5; }
            cm.cursor_row = cm.cursor_row + half;
            ⎇ cm.cursor_row >= len(cm.text_lines) {
                cm.cursor_row = len(cm.text_lines) - 1;
            }
            copy_clamp_col(cm);
            ↩ "copy_render"
        }
        ⎇ byte == 119 { copy_word_forward(cm); ↩ "copy_render" }
        ⎇ byte == 98  { copy_word_backward(cm); ↩ "copy_render" }
        ⎇ byte == 32 {
            ⎇ cm.selecting == true {
                cm.selecting = false;
            } ⎉ {
                cm.selecting = true;
                cm.select_start_row = cm.cursor_row;
                cm.select_start_col = cm.cursor_col;
            }
            ↩ "copy_render"
        }
        ⎇ byte == 86 {
            cm.line_mode = cm.line_mode == false;
            ⎇ cm.line_mode == true ∧ cm.selecting == false {
                cm.selecting = true;
                cm.select_start_row = cm.cursor_row;
                cm.select_start_col = 0;
            } ⎉ {
                ⎇ cm.line_mode == true ∧ cm.selecting == true {
                    cm.select_start_col = 0;
                }
            }
            ↩ "copy_render"
        }
        ⎇ byte == 13  { ↩ "copy_yank" }
        ⎇ byte == 113 { ↩ "copy_exit" }
        ⎇ byte == 27  { ↩ "copy_exit" }
        ↩ "none"
    }

    // Confirmation intercept — before any other input handling
    ⎇ input_state.confirming_close == true {
        input_state.confirming_close = false;
        ⎇ byte == 121 { ↩ "close_confirm"; }
        ↩ "close_cancel"
    }

    ≔ mut action = "passthrough";

    // In escape sequence
    ⎇ input_state.in_escape == true {
        input_state.escape_buf = input_state.escape_buf + from_char_code(byte);
        action = "none";
        // Check for mouse SGR: ESC[<Btn;X;YM or m (buf starts with "[<")
        ⎇ (byte == 77 ∨ byte == 109) ∧ len(input_state.escape_buf) > 2 ∧ starts_with(input_state.escape_buf, "[<") == true {
            action = "mouse:" + input_state.escape_buf;
            input_state.in_escape = false;
            input_state.escape_buf = "";
        } ⎉ {
            // Check for end of non-mouse escape sequence (terminal byte 64-126, need >=2 chars to skip CSI introducer [)
            ⎇ byte >= 64 ∧ byte <= 126 ∧ len(input_state.escape_buf) >= 2 {
                input_state.last_escape_buf = input_state.escape_buf;
                input_state.in_escape = false;
                input_state.escape_buf = "";
                action = "forward_esc";
            }
        }
    } ⎉ {
        // ESC byte starts escape sequence
        ⎇ byte == 27 {
            input_state.in_escape = true;
            input_state.escape_buf = "";
            action = "none";
        } ⎉ {
            // Leader mode handling
            ⎇ input_state.leader_active == true {
                input_state.leader_active = false;
                action = "none";
                ⎇ byte == 110 { action = "focus_next"; }
                ⎇ byte == 112 { action = "focus_prev"; }
                ⎇ byte == 113 { action = "quit"; }
                ⎇ byte == 107 { action = "scroll_up"; }
                ⎇ byte == 106 { action = "scroll_down"; }
                ⎇ byte == 99  { action = "create_terminal"; }
                ⎇ byte == 109 { action = "create_monitor"; }
                ⎇ byte == 120 { action = "close_pane"; }
                ⎇ byte == 122 { action = "zoom_toggle"; }
                ⎇ byte == 83  { action = "save_profile"; }
                ⎇ byte == 91  { action = "copy_enter"; }
                ⎇ byte == 47  { action = "search_enter"; }
            } ⎉ {
                // Leader key (Ctrl-B)
                ⎇ byte == LEADER_KEY {
                    input_state.leader_active = true;
                    action = "leader_activate";
                }
                // else: action stays "passthrough"
            }
        }
    }

    action
}

// Find which pane a mouse click at (mx, my) belongs to
rite find_pane_at(panes, mx, my) {
    ≔ mut result = -1;
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ≔ r = panes[i].region;
        ⎇ mx >= r.x ∧ mx < r.x + r.w ∧ my >= r.y ∧ my < r.y + r.h {
            result = i;
        }
        i = i + 1;
    }
    result
}

// ============================================================================
// Section 7: Terminal Control
// ============================================================================

rite terminal_init() {
    // Save terminal state before switching to raw mode
    ≔ saved = term_get_termios(0);
    term_set_raw_mode(0);
    // Enter alt screen
    Sys·write(1, ESC + "[?1049h", 8);
    // Enable mouse tracking (SGR mode)
    Sys·write(1, ESC + "[?1006h", 8);
    Sys·write(1, ESC + "[?1003h", 8);
    // Hide cursor
    Sys·write(1, ESC + "[?25l", 6);
    // Clear screen
    Sys·write(1, ESC + "[2J", 4);
    ↩ saved;
}

rite terminal_shutdown(saved_termios) {
    // Show cursor
    Sys·write(1, ESC + "[?25h", 6);
    // Disable mouse tracking
    Sys·write(1, ESC + "[?1003l", 8);
    Sys·write(1, ESC + "[?1006l", 8);
    // Leave alt screen
    Sys·write(1, ESC + "[?1049l", 8);
    // Restore original terminal state (cooked mode)
    term_restore_termios(0, saved_termios);
}

// ============================================================================
// Section 8: Shutdown
// ============================================================================

rite shutdown_panes(panes) {
    // Phase 1: Send SIGTERM to all children
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            Sys·kill(panes[i].pid, SIGTERM());
        }
        i = i + 1;
    }

    // Phase 2: Wait briefly for graceful exit
    // In real mode, we'd loop checking waitpid with WNOHANG
    // For now, do a single waitpid pass
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            ≔ wait = Sys·waitpid(panes[i].pid, WNOHANG());
            ⎇ wait.pid > 0 {
                panes[i].alive = false;
            }
        }
        i = i + 1;
    }

    // Phase 3: SIGKILL any remaining
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            Sys·kill(panes[i].pid, SIGKILL());
            Sys·waitpid(panes[i].pid, 0);
            panes[i].alive = false;
        }
        i = i + 1;
    }

    // Close all PTY fds
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].master_fd >= 0 {
            Sys·close(panes[i].master_fd);
            Sys·close(panes[i].slave_fd);
        }
        i = i + 1;
    }
}

// ============================================================================
// Section 8b: System Monitor Plugin
// ============================================================================

// Format large numbers with K/M suffixes
rite format_number(n) {
    ≔ mut result = to_string(n);
    ⎇ n >= 1000000 {
        ≔ m = n / 1000;
        result = to_string(m / 1000) + "." + to_string((m % 1000) / 100) + "M";
    } ⎉ {
        ⎇ n >= 1000 {
            result = to_string(n / 1000) + "." + to_string((n % 1000) / 100) + "K";
        }
    }
    result
}

// Load Claude Code stats from ~/.claude/stats-cache.json
rite monitor_load_stats() {
    ≔ home = env("HOME");
    ≔ stats_path = home + "/.claude/stats-cache.json";
    ≔ mut result = null;
    ⎇ fs_exists(stats_path) == true {
        ≔ raw = fs_read(stats_path);
        result = json_parse(raw);
    }
    result
}

// Render monitor data into a VTerm
rite monitor_render(vt, stats) {
    // Clear VTerm
    ≔ mut ei = 0;
    ⟳ ei < len(vt.cells) {
        vt.cells[ei] = {ch: " ", fg: 7, bg: 0};
        ei = ei + 1;
    }
    vt.cursor_row = 0;
    vt.cursor_col = 0;

    ⎇ stats == null {
        // No data available
        vterm_feed(vt, " Claude Code Monitor\n");
        vterm_feed(vt, " No data available\n");
    } ⎉ {
        // Header
        vterm_feed(vt, " Claude Code Monitor\n");

        // Separator
        ≔ mut si = 0;
        ≔ mut sep = " ";
        ⟳ si < vt.cols - 2 {
            sep = sep + BOX_H;
            si = si + 1;
        }
        vterm_feed(vt, sep + "\n");

        // Total sessions/messages
        ≔ mut sessions_str = "?";
        ≔ ts = map_get(stats, "totalSessions");
        ⎇ ts != null {
            sessions_str = to_string(ts);
        }
        ≔ mut msgs_str = "?";
        ≔ tm = map_get(stats, "totalMessages");
        ⎇ tm != null {
            msgs_str = format_number(tm);
        }

        vterm_feed(vt, " Sessions: " + sessions_str + "\n");
        vterm_feed(vt, " Messages: " + msgs_str + "\n");
        vterm_feed(vt, "\n");

        // Model usage
        ≔ mu = map_get(stats, "modelUsage");
        ⎇ mu != null {
            vterm_feed(vt, " Model Usage\n");
            vterm_feed(vt, sep + "\n");
            ≔ model_keys = map_keys(mu);
            ≔ mut mi = 0;
            ⟳ mi < len(model_keys) {
                ≔ model_name = model_keys[mi];
                ≔ model = map_get(mu, model_name);
                ⎇ model != null {
                    ≔ in_tok = map_get(model, "inputTokens");
                    ≔ out_tok = map_get(model, "outputTokens");
                    ≔ mut total_tok = 0;
                    ⎇ in_tok != null { total_tok = total_tok + in_tok; }
                    ⎇ out_tok != null { total_tok = total_tok + out_tok; }
                    vterm_feed(vt, " " + model_name + " " + format_number(total_tok) + "\n");
                }
                mi = mi + 1;
            }
        }
    }
}

// ============================================================================
// Section 9: Main Event Loop
// ============================================================================

rite main() {
    // Load configuration
    ≔ cfg = load_config();

    // Load startup pane types from profile (or default single terminal)
    ≔ pane_types = load_profile();
    ≔ grid = recompute_grid(len(pane_types), 24, 80);
    ≔ mut grid_rows = grid.rows;
    ≔ mut grid_cols = grid.cols;

    // Query real terminal dimensions
    ≔ winsize = term_get_winsize(1);
    ≔ mut screen_w = winsize.cols;
    ≔ mut screen_h = winsize.rows;

    // Recompute grid with actual terminal dimensions
    ≔ real_grid = recompute_grid(len(pane_types), screen_h, screen_w);
    grid_rows = real_grid.rows;
    grid_cols = real_grid.cols;

    // Initialize terminal (returns saved termios handle for restore on shutdown)
    ≔ saved_termios = terminal_init();

    // Register signal handlers
    Sys·signal_register(SIGWINCH());
    Sys·signal_register(SIGTERM());
    Sys·signal_register(SIGINT());
    Sys·signal_register(SIGCHLD());

    // Calculate layout
    ≔ mut regions = layout_grid(grid_rows, grid_cols, screen_w, screen_h);

    // Create panes from profile types
    ≔ mut panes = [];
    ≔ mut i = 0;
    ⟳ i < len(pane_types) {
        ⎇ pane_types[i] == "monitor" {
            push(panes, MonitorPane·new(i, regions[i]));
        } ⎉ {
            push(panes, Pane·new(i, regions[i], cfg.shell));
        }
        i = i + 1;
    }

    // Create screen buffer
    ≔ mut screen = Grid·new(screen_h, screen_w);

    // Input state
    ≔ input = InputState·new();
    ≔ mut focus = 0;
    ≔ mut running = true;
    ≔ mut zoomed = false;

    // HMR state
    ≔ mut hmr_counter = 0;
    ≔ mut hmr_last_mtime = 0;
    ⎇ cfg.hmr == true ∧ fs_exists(SELF_PATH) == true {
        hmr_last_mtime = fs_mtime(SELF_PATH);
    }

    // Monitor refresh counter
    ≔ mut monitor_counter = 0;

    // Initial render
    i = 0;
    ⟳ i < len(panes) {
        ≔ mut title = panes[i].title;
        ⎇ i == focus {
            title = "[" + title + "]";
        }
        render_border(screen, panes[i].region, title);
        i = i + 1;
    }
    render_status_bar(screen, build_status_text(focus, panes, "normal"));
    flush_dirty(screen);

    // Main event loop
    ⟳ running == true {
        // Check for signals
        ⎇ Sys·signal_pending(SIGTERM()) == true ∨ Sys·signal_pending(SIGINT()) == true {
            running = false;
        }

        // Check for SIGWINCH (terminal resize)
        ⎇ Sys·signal_pending(SIGWINCH()) == true {
            // Re-query terminal size
            ≔ new_ws = term_get_winsize(1);
            screen_w = new_ws.cols;
            screen_h = new_ws.rows;

            // Reset zoom on resize
            zoomed = false;

            // Recreate screen buffer and relayout all panes
            screen = Grid·new(screen_h, screen_w);
            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
            grid_rows = gl.grid_rows;
            grid_cols = gl.grid_cols;
            render_status_bar(screen, build_status_text(focus, panes, "normal"));
            flush_dirty(screen);
        }

        // Poll stdin for user input
        ⎇ Sys·poll_fd(0, 0) == true {
            ≔ input_data = Sys·read_string(0, 256);
            ⎇ input_data != "" {
                // Process each byte
                ≔ mut bi = 0;
                ⟳ bi < len(input_data) {
                    ≔ byte = char_code_at(input_data, bi);
                    ≔ action = process_input(input, byte, len(panes));

                    // Action dispatch: exactly ONE handler fires (⎇/⎉ chain)
                    ⎇ action == "quit" {
                        running = false;
                    } ⎉ { ⎇ action == "focus_next" {
                        focus = (focus + 1) % len(panes);
                        ≔ mut pi = 0;
                        ⟳ pi < len(panes) {
                            ≔ mut t = panes[pi].title;
                            ⎇ pi == focus {
                                t = "[" + t + "]";
                            }
                            render_border(screen, panes[pi].region, t);
                            pi = pi + 1;
                        }
                        render_status_bar(screen, build_status_text(focus, panes, "normal"));
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "focus_prev" {
                        ⎇ focus == 0 {
                            focus = len(panes) - 1;
                        } ⎉ {
                            focus = focus - 1;
                        }
                        ≔ mut pi = 0;
                        ⟳ pi < len(panes) {
                            ≔ mut t = panes[pi].title;
                            ⎇ pi == focus {
                                t = "[" + t + "]";
                            }
                            render_border(screen, panes[pi].region, t);
                            pi = pi + 1;
                        }
                        render_status_bar(screen, build_status_text(focus, panes, "normal"));
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "scroll_up" {
                        ≔ vt = panes[focus].vterm;
                        ⎇ vt.scroll_offset < len(vt.scrollback) {
                            vt.scroll_offset = vt.scroll_offset + 1;
                        }
                        vterm_blit(vt, screen, panes[focus].region);
                        ≔ sb_title = "[" + to_string(vt.scroll_offset) + "/" + to_string(len(vt.scrollback)) + "]";
                        render_border(screen, panes[focus].region, sb_title);
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "scroll_down" {
                        ≔ vt = panes[focus].vterm;
                        ⎇ vt.scroll_offset > 0 {
                            vt.scroll_offset = vt.scroll_offset - 1;
                        }
                        vterm_blit(vt, screen, panes[focus].region);
                        ⎇ vt.scroll_offset > 0 {
                            ≔ sb_title = "[" + to_string(vt.scroll_offset) + "/" + to_string(len(vt.scrollback)) + "]";
                            render_border(screen, panes[focus].region, sb_title);
                        } ⎉ {
                            render_border(screen, panes[focus].region, "[" + panes[focus].title + "]");
                        }
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "passthrough" {
                        ⎇ panes[focus].master_fd >= 0 {
                            ≔ ch = to_string(char_at(input_data, bi));
                            Sys·write(panes[focus].master_fd, ch, 1);
                        }
                    } ⎉ { ⎇ action == "forward_esc" {
                        ⎇ panes[focus].master_fd >= 0 {
                            ≔ esc_seq = from_char_code(27) + input.last_escape_buf;
                            Sys·write(panes[focus].master_fd, esc_seq, len(esc_seq));
                        }
                    } ⎉ { ⎇ action == "create_terminal" {
                        ⎇ len(panes) < cfg.max_panes {
                            ≔ tmp_region = Region·new(0, 0, 40, 12);
                            push(panes, Pane·new(len(panes) - 1, tmp_region, cfg.shell));
                            focus = len(panes) - 1;
                            screen = Grid·new(screen_h, screen_w);
                            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                            grid_rows = gl.grid_rows;
                            grid_cols = gl.grid_cols;
                            zoomed = false;
                            render_status_bar(screen, build_status_text(focus, panes, "normal"));
                            flush_dirty(screen);
                        }
                    } ⎉ { ⎇ action == "create_monitor" {
                        ⎇ len(panes) < cfg.max_panes {
                            ≔ tmp_region = Region·new(0, 0, 40, 12);
                            push(panes, MonitorPane·new(len(panes) - 1, tmp_region));
                            focus = len(panes) - 1;
                            screen = Grid·new(screen_h, screen_w);
                            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                            grid_rows = gl.grid_rows;
                            grid_cols = gl.grid_cols;
                            zoomed = false;
                            render_status_bar(screen, build_status_text(focus, panes, "normal"));
                            flush_dirty(screen);
                        }
                    } ⎉ { ⎇ action == "close_pane" {
                        ⎇ len(panes) > 1 {
                            input.confirming_close = true;
                            render_status_bar(screen, " [close? y/n]");
                            flush_dirty(screen);
                        }
                    } ⎉ { ⎇ action == "close_confirm" {
                        // Kill the focused pane's process and close fds
                        ⎇ panes[focus].alive == true {
                            Sys·kill(panes[focus].pid, SIGTERM());
                            Sys·waitpid(panes[focus].pid, 0);
                        }
                        ⎇ panes[focus].master_fd >= 0 {
                            Sys·close(panes[focus].master_fd);
                            Sys·close(panes[focus].slave_fd);
                        }
                        // Rebuild panes array excluding closed index
                        ≔ mut new_panes = [];
                        ≔ mut ci = 0;
                        ⟳ ci < len(panes) {
                            ⎇ ci != focus {
                                push(new_panes, panes[ci]);
                            }
                            ci = ci + 1;
                        }
                        panes = new_panes;
                        // Adjust focus
                        ⎇ focus >= len(panes) {
                            focus = len(panes) - 1;
                        }
                        // Relayout
                        screen = Grid·new(screen_h, screen_w);
                        ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                        grid_rows = gl.grid_rows;
                        grid_cols = gl.grid_cols;
                        zoomed = false;
                        render_status_bar(screen, build_status_text(focus, panes, "normal"));
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "close_cancel" {
                        render_status_bar(screen, build_status_text(focus, panes, "normal"));
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "zoom_toggle" {
                        ⎇ zoomed == true {
                            // Unzoom: relayout all panes
                            zoomed = false;
                            screen = Grid·new(screen_h, screen_w);
                            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                            grid_rows = gl.grid_rows;
                            grid_cols = gl.grid_cols;
                            render_status_bar(screen, build_status_text(focus, panes, "normal"));
                            flush_dirty(screen);
                        } ⎉ {
                            // Zoom: focused pane fills entire screen minus status bar
                            zoomed = true;
                            ≔ zoom_region = Region·new(0, 0, screen_w, screen_h - 1);
                            panes[focus].region = zoom_region;
                            vterm_resize(panes[focus].vterm, screen_h - 3, screen_w - 2);
                            ⎇ panes[focus].alive == true {
                                Pty·set_size(panes[focus].master_fd, screen_h - 3, screen_w - 2);
                            }
                            screen = Grid·new(screen_h, screen_w);
                            vterm_blit(panes[focus].vterm, screen, panes[focus].region);
                            ≔ mut zt = panes[focus].title;
                            zt = "[" + zt + " (zoom)]";
                            render_border(screen, panes[focus].region, zt);
                            render_status_bar(screen, build_status_text(focus, panes, "normal"));
                            flush_dirty(screen);
                        }
                    } ⎉ { ⎇ action == "copy_enter" {
                        ≔ cm = input.copy_mode;
                        cm.text_lines = extract_text_lines(panes[focus].vterm);
                        cm.active = true;
                        cm.cursor_row = len(cm.text_lines) - 1;
                        cm.cursor_col = 0;
                        cm.viewport_row = len(cm.text_lines) - (panes[focus].region.h - 2);
                        ⎇ cm.viewport_row < 0 { cm.viewport_row = 0; }
                        cm.selecting = false;
                        cm.line_mode = false;
                        render_copy_mode(screen, panes[focus].region, cm);
                        render_border(screen, panes[focus].region, "[COPY]");
                        render_status_bar(screen, build_status_text(focus, panes, "copy"));
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "copy_render" {
                        ≔ cm = input.copy_mode;
                        ≔ inner_h = panes[focus].region.h - 2;
                        copy_adjust_viewport(cm, inner_h);
                        render_copy_mode(screen, panes[focus].region, cm);
                        ⎇ cm.search_active == true {
                            ≔ cr_title = "[SEARCH] " + panes[focus].title;
                            render_border(screen, panes[focus].region, cr_title);
                            render_status_bar(screen, build_status_text(focus, panes, "search"));
                        } ⎉ {
                            render_border(screen, panes[focus].region, "[COPY]");
                            render_status_bar(screen, build_status_text(focus, panes, "copy"));
                        }
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "copy_yank" {
                        ≔ cm = input.copy_mode;
                        ≔ mut yank_msg = build_status_text(focus, panes, "normal");
                        ⎇ cm.selecting == true {
                            ≔ text = extract_selection(cm);
                            write_clipboard(text);
                            // Count lines in selection
                            ≔ mut sr = cm.select_start_row;
                            ≔ mut er = cm.cursor_row;
                            ⎇ sr > er { ≔ tmp = sr; sr = er; er = tmp; }
                            ≔ nlines = er - sr + 1;
                            yank_msg = " Copied " + to_string(nlines) + " line";
                            ⎇ nlines != 1 { yank_msg = yank_msg + "s"; }
                        }
                        cm.active = false;
                        cm.text_lines = [];
                        // Flush: blit current vterm state
                        vterm_blit(panes[focus].vterm, screen, panes[focus].region);
                        ≔ mut ct = panes[focus].title;
                        ct = "[" + ct + "]";
                        render_border(screen, panes[focus].region, ct);
                        render_status_bar(screen, yank_msg);
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "copy_exit" {
                        ≔ cm = input.copy_mode;
                        cm.active = false;
                        cm.text_lines = [];
                        // Flush: blit current vterm state
                        vterm_blit(panes[focus].vterm, screen, panes[focus].region);
                        ≔ mut ct = panes[focus].title;
                        ct = "[" + ct + "]";
                        render_border(screen, panes[focus].region, ct);
                        render_status_bar(screen, build_status_text(focus, panes, "normal"));
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "save_profile" {
                        save_profile(panes);
                        render_status_bar(screen, " Profile saved");
                        flush_dirty(screen);
                    } ⎉ { ⎇ action == "search_enter" {
                        ≔ cm = input.copy_mode;
                        cm.text_lines = extract_text_lines(panes[focus].vterm);
                        cm.active = true;
                        cm.cursor_row = len(cm.text_lines) - 1;
                        cm.cursor_col = 0;
                        ≔ se_inner_h = panes[focus].region.h - 2;
                        ⎇ len(cm.text_lines) > se_inner_h {
                            cm.viewport_row = len(cm.text_lines) - se_inner_h;
                        } ⎉ {
                            cm.viewport_row = 0;
                        }
                        cm.search_active = true;
                        cm.search_query = "";
                        cm.search_matches = [];
                        cm.search_current = -1;
                        cm.search_saved_row = cm.cursor_row;
                        cm.search_saved_col = cm.cursor_col;
                        cm.search_saved_viewport = cm.viewport_row;
                        render_copy_mode(screen, panes[focus].region, cm);
                        ≔ se_title = "[SEARCH] " + panes[focus].title;
                        render_border(screen, panes[focus].region, se_title);
                        render_status_bar(screen, build_status_text(focus, panes, "search"));
                        flush_dirty(screen);
                    } } } } } } } } } } } } } } } } } } }

                    bi = bi + 1;
                }
            }
        }

        // Poll each pane's PTY for output
        i = 0;
        ⟳ i < len(panes) {
            ⎇ panes[i].alive == true {
                ⎇ Sys·poll_fd(panes[i].master_fd, 0) == true {
                    ≔ pty_data = Sys·read_string(panes[i].master_fd, 4096);
                    ⎇ pty_data != "" {
                        // Feed PTY output through VTerm emulator (all panes, even during zoom)
                        vterm_feed(panes[i].vterm, pty_data);
                        // Update pane title from VTerm if set by OSC
                        ⎇ panes[i].vterm.title != "" {
                            panes[i].title = panes[i].vterm.title;
                        }
                        // Only render if not zoomed or this is the focused pane, and not in copy mode for focused
                        ⎇ (zoomed == false ∨ i == focus) ∧ (input.copy_mode.active == false ∨ i != focus) {
                            vterm_blit(panes[i].vterm, screen, panes[i].region);
                            ≔ mut bt = panes[i].title;
                            ⎇ i == focus {
                                ⎇ zoomed == true {
                                    bt = "[" + bt + " (zoom)]";
                                } ⎉ {
                                    bt = "[" + bt + "]";
                                }
                            }
                            render_border(screen, panes[i].region, bt);
                            flush_dirty(screen);
                        }
                    }
                }
            }
            i = i + 1;
        }

        // Monitor pane refresh (~2 seconds at 16ms)
        monitor_counter = monitor_counter + 1;
        ⎇ monitor_counter >= 120 {
            monitor_counter = 0;
            ≔ mut mi = 0;
            ⟳ mi < len(panes) {
                ⎇ panes[mi].pane_type == "monitor" {
                    ≔ stats = monitor_load_stats();
                    monitor_render(panes[mi].vterm, stats);
                    // Only render if not zoomed or this is the focused pane, and not in copy mode for focused
                    ⎇ (zoomed == false ∨ mi == focus) ∧ (input.copy_mode.active == false ∨ mi != focus) {
                        vterm_blit(panes[mi].vterm, screen, panes[mi].region);
                        ≔ mut mt = panes[mi].title;
                        ⎇ mi == focus {
                            mt = "[" + mt + "]";
                        }
                        render_border(screen, panes[mi].region, mt);
                        flush_dirty(screen);
                    }
                }
                mi = mi + 1;
            }
        }

        // HMR: check for source file changes every ~500ms
        ⎇ cfg.hmr == true {
            hmr_counter = hmr_counter + 1;
            ⎇ hmr_counter >= HMR_CHECK_INTERVAL {
                hmr_counter = 0;
                ⎇ fs_exists(SELF_PATH) == true {
                    ≔ hmr_current_mtime = fs_mtime(SELF_PATH);
                    ⎇ hmr_current_mtime != hmr_last_mtime ∧ hmr_current_mtime > 0 {
                        hmr_last_mtime = hmr_current_mtime;
                        Dev·reload(SELF_PATH);
                    }
                }
            }
        }

        // Sleep to avoid busy-waiting
        sleep(POLL_INTERVAL_MS);
    }

    // Shutdown
    shutdown_panes(panes);
    terminal_shutdown(saved_termios);
}
