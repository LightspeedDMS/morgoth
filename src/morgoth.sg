// ============================================================================
// Morgoth — Terminal Multiplexer for Claude Code
// Written in Sigil
//
// Phase 1: Core Implementation
// - Single and multi-pane terminal with PTY management
// - Grid-based layout engine
// - Diff-based rendering with box-drawing borders
// - Leader key input routing
// - Graceful shutdown with signal handling
// ============================================================================

// ============================================================================
// Section 1: Constants
// ============================================================================

≔ VERSION = "0.1.0";
≔ LEADER_KEY = 2;          // Ctrl-B (0x02)
≔ ESC = "\x1b";
≔ CSI = "\x1b[";
≔ DEFAULT_SHELL = "/bin/bash";
≔ POLL_INTERVAL_MS = 16;   // ~60fps target
≔ SHUTDOWN_TIMEOUT_MS = 3000;
≔ HMR_CHECK_INTERVAL = 30; // Check every ~500ms (30 * 16ms)
≔ SELF_PATH = "src/morgoth.sg";

// Box-drawing characters (Unicode)
≔ BOX_H  = "─";
≔ BOX_V  = "│";
≔ BOX_TL = "┌";
≔ BOX_TR = "┐";
≔ BOX_BL = "└";
≔ BOX_BR = "┘";
≔ BOX_TJ = "┬";
≔ BOX_BJ = "┴";
≔ BOX_LJ = "├";
≔ BOX_RJ = "┤";
≔ BOX_X  = "┼";

// ============================================================================
// Section 2: Data Structures
// ============================================================================

// A Cell in the screen buffer
rite Cell·new(ch, fg, bg, dirty) {
    ≔ cell = {
        ch: ch,
        fg: fg,
        bg: bg,
        dirty: dirty
    };
    ↩ cell
}

// A rectangular region on screen
rite Region·new(x, y, w, h) {
    ≔ r = {
        x: x,
        y: y,
        w: w,
        h: h
    };
    ↩ r
}

// A Pane: owns a PTY, a shell process, and a screen region
rite Pane·new(id, region) {
    ≔ pty = Pty·open();
    Pty·set_size(pty.master_fd, region.h, region.w);

    ≔ pid = Sys·spawn_pty(DEFAULT_SHELL, [], pty.slave_fd);

    // VTerm interior dimensions (region minus border)
    ≔ vt = VTerm·new(region.h - 2, region.w - 2);

    ≔ pane = {
        id: id,
        region: region,
        master_fd: pty.master_fd,
        slave_fd: pty.slave_fd,
        pid: pid,
        alive: true,
        title: "bash",
        vterm: vt
    };
    ↩ pane
}

// ============================================================================
// Section 2b: VTerm — Virtual Terminal Emulator
// ============================================================================

// Create a new VTerm with given interior dimensions
rite VTerm·new(rows, cols) {
    ≔ total = rows * cols;
    ≔ mut cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, {ch: " ", fg: 7, bg: 0});
        i = i + 1;
    }
    ≔ vt = {
        cells: cells,
        rows: rows,
        cols: cols,
        cursor_row: 0,
        cursor_col: 0,
        attr_fg: 7,
        attr_bg: 0,
        esc_state: "normal",
        esc_buf: "",
        scroll_top: 0,
        scroll_bottom: rows - 1,
        saved_row: 0,
        saved_col: 0,
        scrollback: [],
        scrollback_max: 1000,
        scroll_offset: 0
    };
    ↩ vt
}

// Scroll the VTerm up by one line (evict top line of scroll region)
rite vterm_scroll_up(vt) {
    // Save evicted line to scrollback
    ≔ mut evicted = [];
    ≔ mut ec = 0;
    ⟳ ec < vt.cols {
        ≔ idx = vt.scroll_top * vt.cols + ec;
        push(evicted, vt.cells[idx]);
        ec = ec + 1;
    }
    push(vt.scrollback, evicted);
    // Trim scrollback if over max
    ⎇ len(vt.scrollback) > vt.scrollback_max {
        // Remove oldest by rebuilding (drop first element)
        ≔ mut trimmed = [];
        ≔ mut ti = 1;
        ⟳ ti < len(vt.scrollback) {
            push(trimmed, vt.scrollback[ti]);
            ti = ti + 1;
        }
        vt.scrollback = trimmed;
    }

    // Shift lines up within scroll region
    ≔ mut row = vt.scroll_top;
    ⟳ row < vt.scroll_bottom {
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            ≔ dst = row * vt.cols + col;
            ≔ src = (row + 1) * vt.cols + col;
            vt.cells[dst] = vt.cells[src];
            col = col + 1;
        }
        row = row + 1;
    }
    // Clear the bottom line of scroll region
    ≔ mut col = 0;
    ⟳ col < vt.cols {
        ≔ idx = vt.scroll_bottom * vt.cols + col;
        vt.cells[idx] = {ch: " ", fg: 7, bg: 0};
        col = col + 1;
    }
}

// Write a printable character at the cursor position
// ch should be a string (use to_string(char_at(...)) when feeding)
rite vterm_put_char(vt, ch) {
    // Handle line wrap
    ⎇ vt.cursor_col >= vt.cols {
        vt.cursor_col = 0;
        vt.cursor_row = vt.cursor_row + 1;
        ⎇ vt.cursor_row > vt.scroll_bottom {
            vterm_scroll_up(vt);
            vt.cursor_row = vt.scroll_bottom;
        }
    }

    ≔ idx = vt.cursor_row * vt.cols + vt.cursor_col;
    ⎇ idx >= 0 ∧ idx < len(vt.cells) {
        vt.cells[idx] = {ch: ch, fg: vt.attr_fg, bg: vt.attr_bg};
    }
    vt.cursor_col = vt.cursor_col + 1;
}

// Parse CSI parameters string into array of ints
rite vterm_parse_params(buf) {
    ⎇ buf == "" {
        ↩ []
    }
    ≔ parts = split(buf, ";");
    ≔ mut params = [];
    ≔ mut i = 0;
    ⟳ i < len(parts) {
        ⎇ parts[i] == "" {
            push(params, 0);
        } ⎉ {
            push(params, to_int(parts[i]));
        }
        i = i + 1;
    }
    ↩ params
}

// Dispatch a CSI command
rite vterm_csi_dispatch(vt, cmd, buf) {
    ≔ params = vterm_parse_params(buf);
    ≔ n = 0;
    ⎇ len(params) > 0 {
        n = params[0];
    }

    // SGR - Set Graphics Rendition
    ⎇ cmd == "m" {
        ⎇ len(params) == 0 {
            // CSI m = reset
            vt.attr_fg = 7;
            vt.attr_bg = 0;
        } ⎉ {
            ≔ mut pi = 0;
            ⟳ pi < len(params) {
                ≔ p = params[pi];
                ⎇ p == 0 {
                    vt.attr_fg = 7;
                    vt.attr_bg = 0;
                }
                ⎇ p == 1 {
                    // Bold — brighten fg by adding 8
                    ⎇ vt.attr_fg < 8 {
                        vt.attr_fg = vt.attr_fg + 8;
                    }
                }
                // Standard foreground: 30-37
                ⎇ p >= 30 ∧ p <= 37 {
                    vt.attr_fg = p - 30;
                }
                // Standard background: 40-47
                ⎇ p >= 40 ∧ p <= 47 {
                    vt.attr_bg = p - 40;
                }
                // 256-color foreground: 38;5;N
                ⎇ p == 38 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 5 ∧ pi + 2 < len(params) {
                    vt.attr_fg = params[pi + 2];
                    pi = pi + 2;
                }
                // 256-color background: 48;5;N
                ⎇ p == 48 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 5 ∧ pi + 2 < len(params) {
                    vt.attr_bg = params[pi + 2];
                    pi = pi + 2;
                }
                // True color foreground: 38;2;R;G;B (approximate to 256)
                ⎇ p == 38 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 2 ∧ pi + 4 < len(params) {
                    // Map to closest 256 color (16 + 36*r + 6*g + b, each 0-5)
                    ≔ r = params[pi + 2] * 5 / 255;
                    ≔ g = params[pi + 3] * 5 / 255;
                    ≔ b = params[pi + 4] * 5 / 255;
                    vt.attr_fg = 16 + 36 * r + 6 * g + b;
                    pi = pi + 4;
                }
                // True color background: 48;2;R;G;B
                ⎇ p == 48 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 2 ∧ pi + 4 < len(params) {
                    ≔ r = params[pi + 2] * 5 / 255;
                    ≔ g = params[pi + 3] * 5 / 255;
                    ≔ b = params[pi + 4] * 5 / 255;
                    vt.attr_bg = 16 + 36 * r + 6 * g + b;
                    pi = pi + 4;
                }
                // Bright foreground: 90-97
                ⎇ p >= 90 ∧ p <= 97 {
                    vt.attr_fg = p - 90 + 8;
                }
                // Bright background: 100-107
                ⎇ p >= 100 ∧ p <= 107 {
                    vt.attr_bg = p - 100 + 8;
                }
                pi = pi + 1;
            }
        }
    }

    // CUP - Cursor Position: CSI row;col H
    ⎇ cmd == "H" ∨ cmd == "f" {
        ≔ mut row = 1;
        ≔ mut col = 1;
        ⎇ len(params) >= 1 ∧ params[0] > 0 {
            row = params[0];
        }
        ⎇ len(params) >= 2 ∧ params[1] > 0 {
            col = params[1];
        }
        vt.cursor_row = row - 1;
        vt.cursor_col = col - 1;
        // Clamp
        ⎇ vt.cursor_row >= vt.rows {
            vt.cursor_row = vt.rows - 1;
        }
        ⎇ vt.cursor_col >= vt.cols {
            vt.cursor_col = vt.cols - 1;
        }
    }

    // ED - Erase Display: CSI n J
    ⎇ cmd == "J" {
        ⎇ n == 0 {
            // Erase from cursor to end
            ≔ mut r = vt.cursor_row;
            ⟳ r < vt.rows {
                ≔ mut c_start = 0;
                ⎇ r == vt.cursor_row {
                    c_start = vt.cursor_col;
                }
                ≔ mut c = c_start;
                ⟳ c < vt.cols {
                    vt.cells[r * vt.cols + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
                r = r + 1;
            }
        }
        ⎇ n == 1 {
            // Erase from start to cursor
            ≔ mut r = 0;
            ⟳ r <= vt.cursor_row {
                ≔ mut c_end = vt.cols;
                ⎇ r == vt.cursor_row {
                    c_end = vt.cursor_col + 1;
                }
                ≔ mut c = 0;
                ⟳ c < c_end {
                    vt.cells[r * vt.cols + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
                r = r + 1;
            }
        }
        ⎇ n == 2 ∨ n == 3 {
            // Erase all
            ≔ mut ei = 0;
            ⟳ ei < len(vt.cells) {
                vt.cells[ei] = {ch: " ", fg: 7, bg: 0};
                ei = ei + 1;
            }
        }
    }

    // EL - Erase Line: CSI n K
    ⎇ cmd == "K" {
        ≔ row_start = vt.cursor_row * vt.cols;
        ⎇ n == 0 {
            // Erase from cursor to end of line
            ≔ mut c = vt.cursor_col;
            ⟳ c < vt.cols {
                vt.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                c = c + 1;
            }
        }
        ⎇ n == 1 {
            // Erase from start of line to cursor
            ≔ mut c = 0;
            ⟳ c <= vt.cursor_col {
                vt.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                c = c + 1;
            }
        }
        ⎇ n == 2 {
            // Erase entire line
            ≔ mut c = 0;
            ⟳ c < vt.cols {
                vt.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                c = c + 1;
            }
        }
    }

    // CUU - Cursor Up: CSI n A
    ⎇ cmd == "A" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_row = vt.cursor_row - amount;
        ⎇ vt.cursor_row < 0 {
            vt.cursor_row = 0;
        }
    }

    // CUD - Cursor Down: CSI n B
    ⎇ cmd == "B" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_row = vt.cursor_row + amount;
        ⎇ vt.cursor_row >= vt.rows {
            vt.cursor_row = vt.rows - 1;
        }
    }

    // CUF - Cursor Forward: CSI n C
    ⎇ cmd == "C" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_col = vt.cursor_col + amount;
        ⎇ vt.cursor_col >= vt.cols {
            vt.cursor_col = vt.cols - 1;
        }
    }

    // CUB - Cursor Back: CSI n D
    ⎇ cmd == "D" {
        ≔ mut amount = 1;
        ⎇ n > 0 {
            amount = n;
        }
        vt.cursor_col = vt.cursor_col - amount;
        ⎇ vt.cursor_col < 0 {
            vt.cursor_col = 0;
        }
    }

    // CHA - Cursor Horizontal Absolute: CSI n G
    ⎇ cmd == "G" {
        ≔ mut col = 1;
        ⎇ n > 0 {
            col = n;
        }
        vt.cursor_col = col - 1;
        ⎇ vt.cursor_col >= vt.cols {
            vt.cursor_col = vt.cols - 1;
        }
    }

    // VPA - Vertical Position Absolute: CSI n d
    ⎇ cmd == "d" {
        ≔ mut row = 1;
        ⎇ n > 0 {
            row = n;
        }
        vt.cursor_row = row - 1;
        ⎇ vt.cursor_row >= vt.rows {
            vt.cursor_row = vt.rows - 1;
        }
    }

    // DECSTBM - Set Top/Bottom Margins: CSI top;bottom r
    ⎇ cmd == "r" {
        ≔ mut top = 1;
        ≔ mut bottom = vt.rows;
        ⎇ len(params) >= 1 ∧ params[0] > 0 {
            top = params[0];
        }
        ⎇ len(params) >= 2 ∧ params[1] > 0 {
            bottom = params[1];
        }
        vt.scroll_top = top - 1;
        vt.scroll_bottom = bottom - 1;
        // Clamp
        ⎇ vt.scroll_top < 0 {
            vt.scroll_top = 0;
        }
        ⎇ vt.scroll_bottom >= vt.rows {
            vt.scroll_bottom = vt.rows - 1;
        }
        // Move cursor to home
        vt.cursor_row = 0;
        vt.cursor_col = 0;
    }

    // Save cursor: CSI s
    ⎇ cmd == "s" {
        vt.saved_row = vt.cursor_row;
        vt.saved_col = vt.cursor_col;
    }

    // Restore cursor: CSI u
    ⎇ cmd == "u" {
        vt.cursor_row = vt.saved_row;
        vt.cursor_col = vt.saved_col;
    }
}

// Feed a string of data through the VTerm state machine
rite vterm_feed(vt, data) {
    ≔ mut i = 0;
    ⟳ i < len(data) {
        ≔ ch = to_string(char_at(data, i));
        ≔ code = char_code_at(data, i);

        ⎇ vt.esc_state == "normal" {
            // ESC character
            ⎇ code == 27 {
                vt.esc_state = "escape";
                vt.esc_buf = "";
            }
            // Carriage return
            ⎇ code == 13 {
                vt.cursor_col = 0;
            }
            // Line feed
            ⎇ code == 10 {
                vt.cursor_row = vt.cursor_row + 1;
                ⎇ vt.cursor_row > vt.scroll_bottom {
                    vterm_scroll_up(vt);
                    vt.cursor_row = vt.scroll_bottom;
                }
            }
            // Backspace
            ⎇ code == 8 {
                ⎇ vt.cursor_col > 0 {
                    vt.cursor_col = vt.cursor_col - 1;
                }
            }
            // Tab
            ⎇ code == 9 {
                vt.cursor_col = ((vt.cursor_col / 8) + 1) * 8;
                ⎇ vt.cursor_col >= vt.cols {
                    vt.cursor_col = vt.cols - 1;
                }
            }
            // Printable characters (>= 32)
            ⎇ code >= 32 {
                vterm_put_char(vt, ch);
            }
        }

        ⎇ vt.esc_state == "escape" {
            ⎇ ch == "[" {
                vt.esc_state = "csi";
                vt.esc_buf = "";
            } ⎉ {
                // Unrecognized escape — drop and return to normal
                vt.esc_state = "normal";
            }
        }

        ⎇ vt.esc_state == "csi" {
            // Check if this is a terminal character (letter)
            ⎇ (code >= 64 ∧ code <= 90) ∨ (code >= 97 ∧ code <= 122) {
                // Dispatch the CSI command
                vterm_csi_dispatch(vt, ch, vt.esc_buf);
                vt.esc_state = "normal";
                vt.esc_buf = "";
            } ⎉ {
                // Accumulate parameter characters
                vt.esc_buf = vt.esc_buf + ch;
            }
        }

        i = i + 1;
    }
    // Reset scroll offset on new data
    vt.scroll_offset = 0;
}

// Blit VTerm cells to the main Grid at the given region (inside borders)
rite vterm_blit(vt, grid, region) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;

    // Check if scrolled back
    ⎇ vt.scroll_offset > 0 ∧ len(vt.scrollback) > 0 {
        // Render from scrollback
        ≔ mut sb_start = len(vt.scrollback) - vt.scroll_offset;
        ⎇ sb_start < 0 {
            sb_start = 0;
        }
        ≔ mut row = 0;
        ⟳ row < vt.rows {
            ≔ sb_idx = sb_start + row;
            ⎇ sb_idx < len(vt.scrollback) {
                // Render scrollback line
                ≔ line = vt.scrollback[sb_idx];
                ≔ mut col = 0;
                ⟳ col < vt.cols ∧ col < len(line) {
                    Grid·set(grid, inner_y + row, inner_x + col, line[col].ch, line[col].fg, line[col].bg);
                    col = col + 1;
                }
            } ⎉ {
                // Render from live buffer (for lines beyond scrollback)
                ≔ live_row = row - (len(vt.scrollback) - sb_start);
                ⎇ live_row >= 0 ∧ live_row < vt.rows {
                    ≔ mut col = 0;
                    ⟳ col < vt.cols {
                        ≔ idx = live_row * vt.cols + col;
                        Grid·set(grid, inner_y + row, inner_x + col, vt.cells[idx].ch, vt.cells[idx].fg, vt.cells[idx].bg);
                        col = col + 1;
                    }
                }
            }
            row = row + 1;
        }
    } ⎉ {
        // Live view — render directly from VTerm cells
        ≔ mut row = 0;
        ⟳ row < vt.rows {
            ≔ mut col = 0;
            ⟳ col < vt.cols {
                ≔ idx = row * vt.cols + col;
                ⎇ idx < len(vt.cells) {
                    Grid·set(grid, inner_y + row, inner_x + col, vt.cells[idx].ch, vt.cells[idx].fg, vt.cells[idx].bg);
                }
                col = col + 1;
            }
            row = row + 1;
        }
    }
}

// ============================================================================
// Section 2c: Configuration
// ============================================================================

// Load config from ~/.morgoth/config.json, return defaults if missing
rite load_config() {
    ≔ home = env("HOME");
    ≔ config_path = home + "/.morgoth/config.json";

    ≔ mut cfg = {
        grid_rows: 2,
        grid_cols: 3,
        shell: "/bin/bash",
        scrollback_lines: 1000,
        leader_key: 2,
        hmr: true,
        pane_types: ["terminal", "terminal", "terminal", "terminal", "terminal", "terminal"]
    };

    ⎇ fs_exists(config_path) == true {
        ≔ raw = fs_read(config_path);
        ≔ j = json_parse(raw);

        // Extract grid config
        ⎇ j.grid != null {
            ⎇ j.grid.rows != null { cfg.grid_rows = j.grid.rows; }
            ⎇ j.grid.cols != null { cfg.grid_cols = j.grid.cols; }
        }
        ⎇ j.shell != null { cfg.shell = j.shell; }
        ⎇ j.scrollback_lines != null { cfg.scrollback_lines = j.scrollback_lines; }
        ⎇ j.leader_key != null { cfg.leader_key = j.leader_key; }
        ⎇ j.hmr != null { cfg.hmr = j.hmr; }

        // Extract pane types
        ⎇ j.panes != null {
            ≔ mut types = [];
            ≔ mut i = 0;
            ⟳ i < len(j.panes) {
                ⎇ j.panes[i].type != null {
                    push(types, j.panes[i].type);
                } ⎉ {
                    push(types, "terminal");
                }
                i = i + 1;
            }
            cfg.pane_types = types;
        }
    }

    ↩ cfg
}

// ============================================================================
// Section 3: Layout Engine
// ============================================================================

// Calculate grid layout regions for a rows x cols grid
// screen_w, screen_h = total terminal dimensions
// Returns array of Region structs (row-major order)
// Bottom row reserved for status bar
rite layout_grid(rows, cols, screen_w, screen_h) {
    ≔ usable_h = screen_h - 1;  // Reserve status bar

    ≔ base_h = usable_h / rows;
    ≔ remainder_h = usable_h % rows;

    ≔ base_w = screen_w / cols;
    ≔ remainder_w = screen_w % cols;

    ≔ regions = [];
    ≔ y_offset = 0;

    ≔ mut r = 0;
    ⟳ r < rows {
        ≔ h = base_h;
        // Give remainder to last row
        ⎇ r == rows - 1 {
            h = base_h + remainder_h;
        }

        ≔ x_offset = 0;
        ≔ mut c = 0;
        ⟳ c < cols {
            ≔ w = base_w;
            // Give remainder to last column
            ⎇ c == cols - 1 {
                w = base_w + remainder_w;
            }

            push(regions, Region·new(x_offset, y_offset, w, h));

            x_offset = x_offset + w;
            c = c + 1;
        }

        y_offset = y_offset + h;
        r = r + 1;
    }

    ↩ regions
}

// ============================================================================
// Section 4: Screen Buffer (Grid)
// ============================================================================

// Create a flat cell buffer for the screen
rite Grid·new(rows, cols) {
    ≔ total = rows * cols;
    ≔ cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, Cell·new(" ", 7, 0, true));
        i = i + 1;
    }
    ≔ grid = {
        rows: rows,
        cols: cols,
        cells: cells
    };
    ↩ grid
}

// Set a cell at (row, col) in the grid
rite Grid·set(grid, row, col, ch, fg, bg) {
    ⎇ row >= 0 ∧ row < grid.rows ∧ col >= 0 ∧ col < grid.cols {
        ≔ idx = row * grid.cols + col;
        grid.cells[idx] = Cell·new(ch, fg, bg, true);
    }
}

// Get a cell at (row, col)
rite Grid·get(grid, row, col) {
    ⎇ row >= 0 ∧ row < grid.rows ∧ col >= 0 ∧ col < grid.cols {
        ≔ idx = row * grid.cols + col;
        ↩ grid.cells[idx]
    }
    ↩ Cell·new(" ", 7, 0, false)
}

// Count dirty cells
rite Grid·dirty_count(grid) {
    ≔ mut count = 0;
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ⟳ i < total {
        ⎇ grid.cells[i].dirty == true {
            count = count + 1;
        }
        i = i + 1;
    }
    ↩ count
}

// Clear all dirty flags
rite Grid·clear_dirty(grid) {
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ⟳ i < total {
        grid.cells[i] = Cell·new(grid.cells[i].ch, grid.cells[i].fg, grid.cells[i].bg, false);
        i = i + 1;
    }
}

// ============================================================================
// Section 5: Rendering
// ============================================================================

// Draw a border around a region in the grid
rite render_border(grid, region, title) {
    ≔ x = region.x;
    ≔ y = region.y;
    ≔ w = region.w;
    ≔ h = region.h;

    // Top edge
    Grid·set(grid, y, x, BOX_TL, 6, 0);
    ≔ mut c = 1;
    ⟳ c < w - 1 {
        Grid·set(grid, y, x + c, BOX_H, 6, 0);
        c = c + 1;
    }
    Grid·set(grid, y, x + w - 1, BOX_TR, 6, 0);

    // Bottom edge
    Grid·set(grid, y + h - 1, x, BOX_BL, 6, 0);
    c = 1;
    ⟳ c < w - 1 {
        Grid·set(grid, y + h - 1, x + c, BOX_H, 6, 0);
        c = c + 1;
    }
    Grid·set(grid, y + h - 1, x + w - 1, BOX_BR, 6, 0);

    // Side edges
    ≔ mut r = 1;
    ⟳ r < h - 1 {
        Grid·set(grid, y + r, x, BOX_V, 6, 0);
        Grid·set(grid, y + r, x + w - 1, BOX_V, 6, 0);
        r = r + 1;
    }

    // Title in top border (if provided and fits)
    ⎇ title != "" {
        ≔ max_title_len = w - 4;
        ⎇ max_title_len > 0 {
            ≔ mut ti = 0;
            ⟳ ti < max_title_len ∧ ti < len(title) {
                Grid·set(grid, y, x + 2 + ti, to_string(char_at(title, ti)), 15, 0);
                ti = ti + 1;
            }
        }
    }
}

// Write text content into the interior of a region
rite render_content(grid, region, text) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_w = region.w - 2;
    ≔ inner_h = region.h - 2;

    ≔ mut row = 0;
    ≔ mut col = 0;
    ≔ mut i = 0;
    ⟳ i < len(text) ∧ row < inner_h {
        ≔ ch = to_string(char_at(text, i));
        ⎇ ch == "\n" {
            row = row + 1;
            col = 0;
        } ⎉ {
            ⎇ col < inner_w {
                Grid·set(grid, inner_y + row, inner_x + col, ch, 7, 0);
                col = col + 1;
            }
        }
        i = i + 1;
    }
}

// Render status bar at the bottom of the grid
rite render_status_bar(grid, text) {
    ≔ row = grid.rows - 1;
    ≔ mut c = 0;
    // Fill with inverse video spaces
    ⟳ c < grid.cols {
        Grid·set(grid, row, c, " ", 0, 7);
        c = c + 1;
    }
    // Write status text
    ≔ mut i = 0;
    ⟳ i < len(text) ∧ i < grid.cols {
        Grid·set(grid, row, i, to_string(char_at(text, i)), 0, 7);
        i = i + 1;
    }
}

// Flush only dirty cells to stdout using ANSI escape sequences
rite flush_dirty(grid) {
    ≔ mut buf = "";
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ⟳ i < total {
        ⎇ grid.cells[i].dirty == true {
            ≔ row = i / grid.cols;
            ≔ col = i % grid.cols;
            // Move cursor: ESC[row;colH (1-indexed)
            buf = buf + CSI + to_string(row + 1) + ";" + to_string(col + 1) + "H";
            // Set colors
            buf = buf + CSI + "38;5;" + to_string(grid.cells[i].fg) + "m";
            buf = buf + CSI + "48;5;" + to_string(grid.cells[i].bg) + "m";
            // Write character
            buf = buf + grid.cells[i].ch;
        }
        i = i + 1;
    }
    // Reset colors
    buf = buf + CSI + "0m";
    ⎇ buf != CSI + "0m" {
        Sys·write(1, buf, len(buf));
    }
    Grid·clear_dirty(grid);
}

// ============================================================================
// Section 6: Input Handling
// ============================================================================

// Input state machine
rite InputState·new() {
    ≔ state = {
        leader_active: false,
        mouse_mode: true,
        escape_buf: "",
        in_escape: false
    };
    ↩ state
}

// Process a single input byte, returns action string
// Actions: "passthrough", "leader_activate", "focus_next", "focus_prev",
//          "quit", "none", "mouse:X:Y"
rite process_input(input_state, byte, pane_count) {
    // In escape sequence
    ⎇ input_state.in_escape == true {
        input_state.escape_buf = input_state.escape_buf + from_char_code(byte);
        // Check for mouse SGR: ESC[<Btn;X;YM or m
        ⎇ byte == 77 ∨ byte == 109 {
            // Parse mouse event (simplified)
            ≔ result = "mouse:" + input_state.escape_buf;
            input_state.in_escape = false;
            input_state.escape_buf = "";
            ↩ result
        }
        // Check for end of escape sequence
        ⎇ byte >= 64 ∧ byte <= 126 {
            input_state.in_escape = false;
            input_state.escape_buf = "";
        }
        ↩ "none"
    }

    // ESC byte starts escape sequence
    ⎇ byte == 27 {
        input_state.in_escape = true;
        input_state.escape_buf = "";
        ↩ "none"
    }

    // Leader mode handling
    ⎇ input_state.leader_active == true {
        input_state.leader_active = false;

        // 'n' = next pane
        ⎇ byte == 110 {
            ↩ "focus_next"
        }
        // 'p' = previous pane
        ⎇ byte == 112 {
            ↩ "focus_prev"
        }
        // 'q' = quit
        ⎇ byte == 113 {
            ↩ "quit"
        }
        // 'k' = scroll back (up)
        ⎇ byte == 107 {
            ↩ "scroll_up"
        }
        // 'j' = scroll forward (down)
        ⎇ byte == 106 {
            ↩ "scroll_down"
        }
        // 'c' = new pane (future)
        // 'x' = close pane (future)
        ↩ "none"
    }

    // Leader key (Ctrl-B)
    ⎇ byte == LEADER_KEY {
        input_state.leader_active = true;
        ↩ "leader_activate"
    }

    // Normal key — passthrough to focused pane
    ↩ "passthrough"
}

// Find which pane a mouse click at (mx, my) belongs to
rite find_pane_at(panes, mx, my) {
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ≔ r = panes[i].region;
        ⎇ mx >= r.x ∧ mx < r.x + r.w ∧ my >= r.y ∧ my < r.y + r.h {
            ↩ i
        }
        i = i + 1;
    }
    ↩ -1
}

// ============================================================================
// Section 7: Terminal Control
// ============================================================================

rite terminal_init() {
    // Enter alt screen
    Sys·write(1, ESC + "[?1049h", 8);
    // Enable mouse tracking (SGR mode)
    Sys·write(1, ESC + "[?1006h", 8);
    Sys·write(1, ESC + "[?1003h", 8);
    // Hide cursor
    Sys·write(1, ESC + "[?25l", 6);
    // Clear screen
    Sys·write(1, ESC + "[2J", 4);
}

rite terminal_shutdown() {
    // Show cursor
    Sys·write(1, ESC + "[?25h", 6);
    // Disable mouse tracking
    Sys·write(1, ESC + "[?1003l", 8);
    Sys·write(1, ESC + "[?1006l", 8);
    // Leave alt screen
    Sys·write(1, ESC + "[?1049l", 8);
}

// ============================================================================
// Section 8: Shutdown
// ============================================================================

rite shutdown_panes(panes) {
    // Phase 1: Send SIGTERM to all children
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            Sys·kill(panes[i].pid, SIGTERM());
        }
        i = i + 1;
    }

    // Phase 2: Wait briefly for graceful exit
    // In real mode, we'd loop checking waitpid with WNOHANG
    // For now, do a single waitpid pass
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            ≔ wait = Sys·waitpid(panes[i].pid, WNOHANG());
            ⎇ wait.pid > 0 {
                panes[i].alive = false;
            }
        }
        i = i + 1;
    }

    // Phase 3: SIGKILL any remaining
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            Sys·kill(panes[i].pid, SIGKILL());
            Sys·waitpid(panes[i].pid, 0);
            panes[i].alive = false;
        }
        i = i + 1;
    }

    // Close all PTY fds
    i = 0;
    ⟳ i < len(panes) {
        Sys·close(panes[i].master_fd);
        Sys·close(panes[i].slave_fd);
        i = i + 1;
    }
}

// ============================================================================
// Section 8b: System Monitor Plugin
// ============================================================================

// Format large numbers with K/M suffixes
rite format_number(n) {
    ≔ mut result = to_string(n);
    ⎇ n >= 1000000 {
        ≔ m = n / 1000;
        result = to_string(m / 1000) + "." + to_string((m % 1000) / 100) + "M";
    } ⎉ {
        ⎇ n >= 1000 {
            result = to_string(n / 1000) + "." + to_string((n % 1000) / 100) + "K";
        }
    }
    ↩ result
}

// Load Claude Code stats from ~/.claude/stats-cache.json
rite monitor_load_stats() {
    ≔ home = env("HOME");
    ≔ stats_path = home + "/.claude/stats-cache.json";

    ⎇ fs_exists(stats_path) == false {
        ↩ null
    }

    ≔ raw = fs_read(stats_path);
    ≔ stats = json_parse(raw);
    ↩ stats
}

// Render monitor data into a VTerm
rite monitor_render(vt, stats) {
    // Clear VTerm
    ≔ mut ei = 0;
    ⟳ ei < len(vt.cells) {
        vt.cells[ei] = {ch: " ", fg: 7, bg: 0};
        ei = ei + 1;
    }
    vt.cursor_row = 0;
    vt.cursor_col = 0;

    ⎇ stats == null {
        // No data available
        vterm_feed(vt, " Claude Code Monitor\n");
        vterm_feed(vt, " No data available\n");
        ↩ 0
    }

    // Header
    vterm_feed(vt, " Claude Code Monitor\n");

    // Separator
    ≔ mut si = 0;
    ≔ mut sep = " ";
    ⟳ si < vt.cols - 2 {
        sep = sep + "\xe2\x94\x80";
        si = si + 1;
    }
    vterm_feed(vt, sep + "\n");

    // Total sessions/messages
    ≔ mut sessions_str = "?";
    ≔ ts = map_get(stats, "totalSessions");
    ⎇ ts != null {
        sessions_str = to_string(ts);
    }
    ≔ mut msgs_str = "?";
    ≔ tm = map_get(stats, "totalMessages");
    ⎇ tm != null {
        msgs_str = format_number(tm);
    }

    vterm_feed(vt, " Sessions: " + sessions_str + "\n");
    vterm_feed(vt, " Messages: " + msgs_str + "\n");
    vterm_feed(vt, "\n");

    // Model usage
    ≔ mu = map_get(stats, "modelUsage");
    ⎇ mu != null {
        vterm_feed(vt, " Model Usage\n");
        vterm_feed(vt, sep + "\n");
        ≔ model_keys = map_keys(mu);
        ≔ mut mi = 0;
        ⟳ mi < len(model_keys) {
            ≔ model_name = model_keys[mi];
            ≔ model = map_get(mu, model_name);
            ⎇ model != null {
                ≔ in_tok = map_get(model, "inputTokens");
                ≔ out_tok = map_get(model, "outputTokens");
                ≔ mut total_tok = 0;
                ⎇ in_tok != null { total_tok = total_tok + in_tok; }
                ⎇ out_tok != null { total_tok = total_tok + out_tok; }
                vterm_feed(vt, " " + model_name + " " + format_number(total_tok) + "\n");
            }
            mi = mi + 1;
        }
    }

    ↩ 0
}

// ============================================================================
// Section 9: Main Event Loop
// ============================================================================

rite main() {
    // Load configuration
    ≔ cfg = load_config();
    ≔ grid_rows = cfg.grid_rows;
    ≔ grid_cols = cfg.grid_cols;

    // Query real terminal dimensions
    ≔ winsize = term_get_winsize(1);
    ≔ mut screen_w = winsize.cols;
    ≔ mut screen_h = winsize.rows;

    // Initialize terminal
    terminal_init();

    // Register signal handlers
    Sys·signal_register(SIGWINCH());
    Sys·signal_register(SIGTERM());
    Sys·signal_register(SIGINT());
    Sys·signal_register(SIGCHLD());

    // Calculate layout
    ≔ mut regions = layout_grid(grid_rows, grid_cols, screen_w, screen_h);

    // Create panes
    ≔ panes = [];
    ≔ mut i = 0;
    ⟳ i < len(regions) {
        push(panes, Pane·new(i, regions[i]));
        i = i + 1;
    }

    // Create screen buffer
    ≔ mut screen = Grid·new(screen_h, screen_w);

    // Input state
    ≔ input = InputState·new();
    ≔ mut focus = 0;
    ≔ mut running = true;

    // HMR state
    ≔ mut hmr_counter = 0;
    ≔ mut hmr_last_mtime = fs_mtime(SELF_PATH);

    // Initial render
    i = 0;
    ⟳ i < len(panes) {
        ≔ mut title = panes[i].title;
        ⎇ i == focus {
            title = "[" + title + "]";
        }
        render_border(screen, panes[i].region, title);
        i = i + 1;
    }
    render_status_bar(screen, " Morgoth v" + VERSION + " | Ctrl-B: leader | q: quit | n/p: focus");
    flush_dirty(screen);

    // Main event loop
    ⟳ running == true {
        // Check for signals
        ⎇ Sys·signal_pending(SIGTERM()) == true ∨ Sys·signal_pending(SIGINT()) == true {
            running = false;
        }

        // Check for SIGWINCH (terminal resize)
        ⎇ Sys·signal_pending(SIGWINCH()) == true {
            // Re-query terminal size
            ≔ new_ws = term_get_winsize(1);
            screen_w = new_ws.cols;
            screen_h = new_ws.rows;

            // Recalculate layout
            regions = layout_grid(grid_rows, grid_cols, screen_w, screen_h);

            // Recreate screen buffer
            screen = Grid·new(screen_h, screen_w);

            // Update pane regions, resize PTYs, recreate VTerms
            ≔ mut ri = 0;
            ⟳ ri < len(panes) {
                panes[ri].region = regions[ri];
                panes[ri].vterm = VTerm·new(regions[ri].h - 2, regions[ri].w - 2);
                ⎇ panes[ri].alive == true {
                    Pty·set_size(panes[ri].master_fd, regions[ri].h, regions[ri].w);
                }
                ri = ri + 1;
            }

            // Full redraw
            ≔ mut di = 0;
            ⟳ di < len(panes) {
                ≔ mut t = panes[di].title;
                ⎇ di == focus {
                    t = "[" + t + "]";
                }
                render_border(screen, panes[di].region, t);
                di = di + 1;
            }
            render_status_bar(screen, " Morgoth v" + VERSION + " | Ctrl-B: leader | q: quit | n/p: focus");
            flush_dirty(screen);
        }

        // Poll stdin for user input
        ⎇ Sys·poll_fd(0, 0) == true {
            ≔ input_data = Sys·read_string(0, 256);
            ⎇ input_data != "" {
                // Process each byte
                ≔ mut bi = 0;
                ⟳ bi < len(input_data) {
                    ≔ byte = char_code_at(input_data, bi);
                    ≔ action = process_input(input, byte, len(panes));

                    ⎇ action == "quit" {
                        running = false;
                    }
                    ⎇ action == "focus_next" {
                        focus = (focus + 1) % len(panes);
                        // Re-render borders to show focus
                        ≔ mut pi = 0;
                        ⟳ pi < len(panes) {
                            ≔ mut t = panes[pi].title;
                            ⎇ pi == focus {
                                t = "[" + t + "]";
                            }
                            render_border(screen, panes[pi].region, t);
                            pi = pi + 1;
                        }
                        flush_dirty(screen);
                    }
                    ⎇ action == "focus_prev" {
                        ⎇ focus == 0 {
                            focus = len(panes) - 1;
                        } ⎉ {
                            focus = focus - 1;
                        }
                        // Re-render borders
                        ≔ mut pi = 0;
                        ⟳ pi < len(panes) {
                            ≔ mut t = panes[pi].title;
                            ⎇ pi == focus {
                                t = "[" + t + "]";
                            }
                            render_border(screen, panes[pi].region, t);
                            pi = pi + 1;
                        }
                        flush_dirty(screen);
                    }
                    ⎇ action == "scroll_up" {
                        ≔ vt = panes[focus].vterm;
                        ⎇ vt.scroll_offset < len(vt.scrollback) {
                            vt.scroll_offset = vt.scroll_offset + 1;
                        }
                        vterm_blit(vt, screen, panes[focus].region);
                        // Show scroll indicator in border
                        ≔ sb_title = "[" + to_string(vt.scroll_offset) + "/" + to_string(len(vt.scrollback)) + "]";
                        render_border(screen, panes[focus].region, sb_title);
                        flush_dirty(screen);
                    }
                    ⎇ action == "scroll_down" {
                        ≔ vt = panes[focus].vterm;
                        ⎇ vt.scroll_offset > 0 {
                            vt.scroll_offset = vt.scroll_offset - 1;
                        }
                        vterm_blit(vt, screen, panes[focus].region);
                        ⎇ vt.scroll_offset > 0 {
                            ≔ sb_title = "[" + to_string(vt.scroll_offset) + "/" + to_string(len(vt.scrollback)) + "]";
                            render_border(screen, panes[focus].region, sb_title);
                        } ⎉ {
                            render_border(screen, panes[focus].region, "[" + panes[focus].title + "]");
                        }
                        flush_dirty(screen);
                    }
                    ⎇ action == "passthrough" {
                        // Forward to focused pane's PTY master
                        ≔ ch = to_string(char_at(input_data, bi));
                        Sys·write(panes[focus].master_fd, ch, 1);
                    }

                    bi = bi + 1;
                }
            }
        }

        // Poll each pane's PTY for output
        i = 0;
        ⟳ i < len(panes) {
            ⎇ panes[i].alive == true {
                ⎇ Sys·poll_fd(panes[i].master_fd, 0) == true {
                    ≔ pty_data = Sys·read_string(panes[i].master_fd, 4096);
                    ⎇ pty_data != "" {
                        // Feed PTY output through VTerm emulator
                        vterm_feed(panes[i].vterm, pty_data);
                        vterm_blit(panes[i].vterm, screen, panes[i].region);
                        flush_dirty(screen);
                    }
                }
            }
            i = i + 1;
        }

        // HMR: check for source file changes every ~500ms
        hmr_counter = hmr_counter + 1;
        ⎇ hmr_counter >= HMR_CHECK_INTERVAL {
            hmr_counter = 0;
            ≔ hmr_current_mtime = fs_mtime(SELF_PATH);
            ⎇ hmr_current_mtime != hmr_last_mtime ∧ hmr_current_mtime > 0 {
                hmr_last_mtime = hmr_current_mtime;
                Dev·reload(SELF_PATH);
            }
        }

        // Sleep to avoid busy-waiting
        sleep(POLL_INTERVAL_MS);
    }

    // Shutdown
    shutdown_panes(panes);
    terminal_shutdown();
}
