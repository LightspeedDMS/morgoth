// ============================================================================
// Morgoth — Terminal Multiplexer for Claude Code
// Written in Sigil
//
// Copyright 2026 Lightspeed DMS, LLC
// Licensed under Apache License 2.0 or MIT License, at your option.
// See LICENSE-APACHE and LICENSE-MIT at the repository root.
//
// Phase 1: Core Implementation
// - Single and multi-pane terminal with PTY management
// - Grid-based layout engine
// - Diff-based rendering with box-drawing borders
// - Leader key input routing
// - Graceful shutdown with signal handling
// ============================================================================

// ============================================================================
// Section 1: Constants
// ============================================================================

≔ VERSION = "0.1.0";
≔ LEADER_KEY = 2;          // Ctrl-B (0x02)
≔ ESC = "\x1b";
≔ CSI = "\x1b[";
≔ DEFAULT_SHELL = "/bin/bash";
≔ POLL_INTERVAL_MS = 16;   // ~60fps target
≔ PTY_READ_CHUNK = 16384;  // 16KB per read
≔ PTY_FRAME_BUDGET = 65536; // 64KB max per pane per iteration
≔ SHUTDOWN_TIMEOUT_MS = 3000;
≔ HMR_CHECK_INTERVAL = 30; // Check every ~500ms (30 * 16ms)
≔ ESC_BUF_MAX = 4096;      // Max VTerm escape buffer length
≔ INPUT_ESC_BUF_MAX = 256;  // Max input escape buffer length
≔ SELF_PATH_ENV = Sys·getenv("MORGOTH_SRC");
≔ SELF_PATH = ⎇ SELF_PATH_ENV != null ∧ SELF_PATH_ENV != "" { SELF_PATH_ENV } ⎉ { "src/morgoth.sg" };
≔ IDLE_THRESHOLD = 120;    // ~2s at 16ms; ticks of no PTY output before pane is "idle"

// Box-drawing characters (Unicode)
≔ BOX_H  = "─";
≔ BOX_V  = "│";
≔ BOX_TL = "┌";
≔ BOX_TR = "┐";
≔ BOX_BL = "└";
≔ BOX_BR = "┘";
≔ BOX_TJ = "┬";
≔ BOX_BJ = "┴";
≔ BOX_LJ = "├";
≔ BOX_RJ = "┤";
≔ BOX_X  = "┼";

// Double-line box-drawing characters (Unicode) for focused panes
≔ BOX2_H  = "═";
≔ BOX2_V  = "║";
≔ BOX2_TL = "╔";
≔ BOX2_TR = "╗";
≔ BOX2_BL = "╚";
≔ BOX2_BR = "╝";

// ============================================================================
// Section 2: Data Structures
// ============================================================================

// Struct type declarations
Σ Cell { ch: String, fg: Int, bg: Int, dirty: Bool }
Σ Region { x: Int, y: Int, w: Int, h: Int }
Σ GridCell { x: Int, y: Int, ch: String, fg: Int, bg: Int, dirty: Bool }
Σ Grid { cells: Array, rows: Int, cols: Int }
Σ VTerm {
    cells: Array, rows: Int, cols: Int,
    cursor_row: Int, cursor_col: Int,
    attr_fg: Int, attr_bg: Int,
    esc_state: EscapeState, esc_buf: String,
    scroll_top: Int, scroll_bottom: Int,
    saved_row: Int, saved_col: Int,
    scrollback: Array, scrollback_max: Int,
    scroll_offset: Int,
    alt_cells: Array,
    alt_cursor_row: Int, alt_cursor_col: Int,
    alt_attr_fg: Int, alt_attr_bg: Int,
    in_alt_screen: Bool, cursor_visible: Bool,
    app_cursor_keys: Bool, auto_wrap: Bool,
    bracketed_paste: Bool,
    mouse_mode: Int, mouse_sgr: Bool,
    origin_mode: Bool, title: String
}
Σ Pane {
    id: String, region: Region,
    master_fd: Int, slave_fd: Int, pid: Int, alive: Bool,
    title: String, role: String,
    inbox: Array, fifo_path: String, fifo_fd: Int,
    vterm: VTerm, pane_type: String,
    last_pty_tick: Int, current_task_id: String
}
Σ CopyModeState {
    active: Bool, cursor_row: Int, cursor_col: Int, viewport_row: Int,
    selecting: Bool, select_start_row: Int, select_start_col: Int,
    line_mode: Bool, text_lines: Array,
    search_active: Bool, search_query: String,
    search_matches: Array, search_current: Int,
    search_saved_row: Int, search_saved_col: Int, search_saved_viewport: Int
}
Σ InputState {
    leader_active: Bool, mouse_mode: Int,
    escape_buf: String, in_escape: Bool, last_escape_buf: String,
    confirming_close: Bool, confirming_quit: Bool,
    showing_help: Bool, showing_picker: Bool,
    picker_profiles: Array, picker_selected: Int,
    active_profile: String, leader_key: Int,
    bindings: Map, bcast: Bool,
    showing_tasks: Bool, copy_mode: CopyModeState
}
Σ Config {
    leader_key: Int, hmr: Bool, shell: String,
    max_panes: Int, session_restore: Bool,
    terminal_w: Int, terminal_h: Int, bindings: Map
}
Σ Task { id: String, text: String, status: String, pane_id: String, created_ts: String, done_ts: String }
Σ MqMessage { sender: String, recipient: String, kind: String, payload: String, ts: String }

// Escape state enum for VTerm state machine
ᛈ EscapeState { Normal, Escape, Csi, Osc, OscEsc, Dcs, DcsEsc, Charset }

// A Cell in the screen buffer
⊢ Cell {
    rite new(ch, fg, bg, dirty) {
        ≔ cell = Cell {
            ch: ch,
            fg: fg,
            bg: bg,
            dirty: dirty
        };
        ↩ cell
    }
}

// A rectangular region on screen
⊢ Region {
    rite new(x, y, w, h) {
        ≔ r = Region {
            x: x,
            y: y,
            w: w,
            h: h
        };
        ↩ r
    }
}

// A Pane: owns a PTY, a shell process, and a screen region
rite Pane·new(region, shell) {
    ≔ pty = Pty·open();
    Pty·set_size(pty.master_fd, region.h - 2, region.w - 2);

    ≔ pid = Sys·spawn_pty(shell, [], pty.slave_fd);

    // Parent closes slave fd after spawn (child inherits it via fork)
    Sys·close(pty.slave_fd);

    // VTerm interior dimensions (region minus border)
    ≔ vt = VTerm·new(region.h - 2, region.w - 2);

    ≔ pane = Pane {
        id: uuid_v4(),
        region: region,
        master_fd: pty.master_fd,
        slave_fd: -1,
        pid: pid,
        alive: true,
        title: "bash",
        role: "terminal",
        inbox: [],
        fifo_path: "",
        fifo_fd: -1,
        vterm: vt,
        pane_type: "terminal",
        last_pty_tick: 0,
        current_task_id: null
    };
    ↩ pane
}

// A Monitor Pane: no PTY, renders system info
rite MonitorPane·new(region) {
    ≔ vt = VTerm·new(region.h - 2, region.w - 2);

    ≔ pane = Pane {
        id: uuid_v4(),
        region: region,
        master_fd: -1,
        slave_fd: -1,
        pid: -1,
        alive: false,
        title: "monitor",
        role: "monitor",
        inbox: [],
        fifo_path: "",
        fifo_fd: -1,
        vterm: vt,
        pane_type: "monitor",
        last_pty_tick: -1,
        current_task_id: null
    };
    ↩ pane
}

// ============================================================================
// Section 2b: Message Queue — Per-Pane In-Process Delivery
// ============================================================================

// Detect the role of a pane from its OSC title
rite detect_role(title) {
    ⎇ contains(title, "Claude") ∨ contains(title, "✳") { ↩ "claude"; }
    ↩ "terminal";
}

// Construct a message object
// Note: "from"/"to" are reserved in Sigil — use "sender"/"recipient"
rite mq_message(from_id, to_id, kind, payload) {
    MqMessage { sender: from_id, recipient: to_id, kind: kind, payload: payload,
                ts: to_string(Sys·clock_gettime()) }
}

// Deliver a message to a pane's inbox (and persist it)
rite mq_send(panes, from_id, to_id, kind, payload) {
    ≔ msg = mq_message(from_id, to_id, kind, payload);
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].id == to_id {
            push(panes[i].inbox, msg);
        }
        i = i + 1;
    }
    mq_persist(msg);
}


// Persist a message to messages.jsonl
rite mq_persist(msg) {
    ≔ line = "{\"sender\":\"" + msg.sender + "\",\"recipient\":\"" + msg.recipient +
             "\",\"kind\":\"" + msg.kind + "\",\"payload\":\"" + msg.payload +
             "\",\"ts\":\"" + msg.ts + "\"}\n";
    fs_append(mq_messages_path(), line);
}

// Yank selected text: OSC 52 clipboard + deliver to focused claude pane via MQ
rite copy_yank_to_claude(panes, focus, text) {
    write_clipboard(text);
    ≔ mut i = 0;
    ≔ mut found = false;
    ⟳ i < len(panes) ∧ found == false {
        ⎇ panes[i].role == "claude" ∧ panes[i].alive == true {
            mq_send(panes, panes[focus].id, panes[i].id, "paste", text);
            found = true;
        }
        i = i + 1;
    }
}

// ============================================================================
// Section 2d: External MQ Interface — FIFOs, Socket, Persistence, Registry
// ============================================================================

// Path helpers (computed at call time from HOME)
rite mq_messages_path() { env("HOME") + "/.morgoth/messages.jsonl" }
rite mq_registry_path() { env("HOME") + "/.morgoth/registry.json" }
rite mq_fifo_dir()      { env("HOME") + "/.morgoth/fifos" }
rite mq_socket_path()   { env("HOME") + "/.morgoth/morgoth.sock" }

// Write Morgoth agent manifest to ~/.morgoth/manifest.json (Phase 26)
// Allows Claude Code agents running inside Morgoth panes to discover the MQ socket.
rite write_manifest(panes) {
    ≔ home = env("HOME");
    ≔ mut n_claude = 0;
    ≔ mut mi = 0;
    ⟳ mi < len(panes) {
        ⎇ panes[mi].role == "claude" ∧ panes[mi].alive == true { n_claude = n_claude + 1; }
        mi = mi + 1;
    }
    ≔ content = "{\"version\":\"0.2.0\",\"socket\":\"" + mq_socket_path() +
                "\",\"registry\":\"" + mq_registry_path() +
                "\",\"fifos\":\"" + mq_fifo_dir() +
                "\",\"claude_panes\":" + to_string(n_claude) + "}";
    fs_write(home + "/.morgoth/manifest.json", content);
}

// Write pane registry to ~/.morgoth/registry.json
rite write_registry(panes) {
    ≔ mut entries = [];
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            push(entries, "{\"id\":\"" + panes[i].id + "\",\"role\":\"" +
                          panes[i].role + "\",\"title\":\"" + panes[i].title +
                          "\",\"fifo\":\"" + panes[i].fifo_path + "\"}");
        }
        i = i + 1;
    }
    ≔ content = "[" + join(entries, ",") + "]\n";
    fs_write(mq_registry_path(), content);
}

// Create a per-pane FIFO and open it non-blocking for reading
rite create_pane_fifo(pane) {
    ≔ path = mq_fifo_dir() + "/" + pane.id;
    mkfifo(path, 384);
    ≔ fd = Sys·open(path, O_RDONLY() + O_NONBLOCK());
    pane.fifo_path = path;
    pane.fifo_fd   = fd;
}

// Create Unix domain socket at mq_socket_path, return listening fd
rite setup_mq_socket() {
    ≔ sock_path = mq_socket_path();
    ⎇ fs_exists(sock_path) == true { fs_remove(sock_path); }
    ≔ fd = Sys·socket(1, 1, 0);
    ⎇ fd < 0 { ↩ -1; }
    ≔ ret = Sys·bind_unix(fd, sock_path);
    ⎇ ret < 0 { Sys·close(fd); ↩ -1; }
    Sys·listen(fd, 8);
    ↩ fd;
}

// Accept one client on socket, parse JSON message, dispatch via mq_send
// Special recipient "notify" (or kind "notify") routes to pane[0].inbox as a status bar message.
rite mq_process_external(panes, sock_fd) {
    ≔ client = Sys·accept(sock_fd, 0, 0);
    ⎇ client < 0 { ↩ null; }
    ≔ data~ = Sys·read_string(client, 4096);
    ⎇ data == "" { Sys·close(client); ↩ null; }
    ≔ msg = json_parse(data);
    ⎇ type_of(msg) == "map" {
        ≔ recip   = map_get(msg, "recipient");
        ≔ kind    = map_get(msg, "kind");
        ≔ payload = map_get(msg, "payload");
        ⎇ kind == "query" {
            // Synchronous RPC: write JSON response before closing client fd
            ≔ qwhat = ⎇ payload != null { payload } ⎉ { "panes" };
            ⎇ qwhat == "panes" {
                ≔ mut qresp = "[";
                ≔ mut qpi = 0;
                ⟳ qpi < len(panes) {
                    ≔ qp = panes[qpi];
                    ≔ qentry = json_stringify({
                        id: qp.id, role: qp.role, title: qp.title,
                        pane_type: qp.pane_type, alive: qp.alive,
                        current_task_id: qp.current_task_id, fifo: qp.fifo_path
                    });
                    ⎇ qpi > 0 { qresp = qresp + ","; }
                    qresp = qresp + qentry;
                    qpi = qpi + 1;
                }
                qresp = qresp + "]";
                Sys·write_string(client, qresp + "\n");
            } ⎉ { ⎇ qwhat == "tasks" {
                ≔ qtasks = task_load();
                Sys·write_string(client, json_stringify(qtasks) + "\n");
            } ⎉ { ⎇ qwhat == "manifest" {
                ≔ mpath = env("HOME") + "/.morgoth/manifest.json";
                ⎇ fs_exists(mpath) == true {
                    Sys·write_string(client, fs_read(mpath) + "\n");
                } ⎉ {
                    Sys·write_string(client, "{}\n");
                }
            } ⎉ {
                Sys·write_string(client, "{\"error\":\"unknown query: " + qwhat + "\"}\n");
            } } }
        } ⎉ { ⎇ recip == "notify" ∨ kind == "notify" {
            // Route to pane[0].inbox as notify kind — inbox drain loop handles rendering
            ⎇ len(panes) > 0 ∧ payload != null {
                push(panes[0].inbox, { kind: "notify", payload: payload });
            }
        } ⎉ { ⎇ kind == "task_add" ∧ payload != null {
            ≔ new_task = task_new(payload);
            ≔ mut atq = task_load();
            push(atq, new_task);
            task_save(atq);
            ⎇ len(panes) > 0 {
                push(panes[0].inbox, { kind: "notify", payload: "Task added: " + substring(payload, 0, 40) });
            }
        } ⎉ { ⎇ kind == "task_done" ∧ payload != null {
            ≔ mut dtq = task_load();
            ≔ mut tdni = 0;
            ⟳ tdni < len(dtq) {
                ⎇ map_get(dtq[tdni], "id") == payload {
                    ≔ tn_txt = map_get(dtq[tdni], "text");
                    ≔ tn_pid = map_get(dtq[tdni], "pane_id");
                    ≔ tn_cts = map_get(dtq[tdni], "created_ts");
                    dtq[tdni] = { id: payload, text: tn_txt,
                                  status: "done", pane_id: tn_pid,
                                  created_ts: tn_cts,
                                  done_ts: to_string(Sys·clock_gettime()) };
                }
                tdni = tdni + 1;
            }
            task_save(dtq);
            // Route pane clearing through inbox (main scope owns panes array)
            ⎇ len(panes) > 0 {
                push(panes[0].inbox, { kind: "task_done_internal", payload: payload });
            }
        } ⎉ {
            ⎇ recip != null ∧ kind != null ∧ payload != null {
                mq_send(panes, "external", recip, kind, payload);
            }
        } } } }
    }
    Sys·close(client);
}

// Replay messages.jsonl into pane inboxes on startup
// Replay messages.jsonl into pane inboxes, then clear the file.
// Uses direct inbox push (not mq_send) to avoid re-persisting replayed messages.
// Pane UUIDs are fresh each startup, so only messages queued in the same
// session will match; unmatched messages are silently discarded.
rite mq_load_pending(panes) {
    ⎇ fs_exists(mq_messages_path()) == false { ↩ null; }
    ≔ content = fs_read(mq_messages_path());
    // Clear the file immediately so it doesn't grow unboundedly across restarts
    fs_write(mq_messages_path(), "");
    ⎇ content == "" { ↩ null; }
    ≔ lines = split(content, "\n");
    ≔ mut i = 0;
    ⟳ i < len(lines) {
        ≔ line = lines[i];
        ⎇ line != "" {
            ≔ msg = json_parse(line);
            ⎇ type_of(msg) == "map" {
                ≔ recip   = map_get(msg, "recipient");
                ≔ kind    = map_get(msg, "kind");
                ≔ payload = map_get(msg, "payload");
                ⎇ recip != null ∧ kind != null ∧ payload != null {
                    // Push directly — bypass mq_persist to avoid re-writing replayed msgs
                    ≔ mut pi = 0;
                    ⟳ pi < len(panes) {
                        ⎇ panes[pi].id == recip {
                            push(panes[pi].inbox, { kind: kind, payload: payload });
                        }
                        pi = pi + 1;
                    }
                }
            }
        }
        i = i + 1;
    }
}

// ============================================================================
// Section 2e: Task Queue — Shared Agent Work Queue
// ============================================================================

rite task_queue_path() { env("HOME") + "/.morgoth/tasks.json" }

rite task_new(text) {
    Task { id: uuid_v4(), text: text, status: "pending",
           pane_id: null, created_ts: to_string(Sys·clock_gettime()), done_ts: null }
}

rite task_load() {
    ≔ path = task_queue_path();
    ⎇ fs_exists(path) == false { ↩ []; }
    ≔ raw = fs_read(path);
    ⎇ len(raw) == 0 ∨ starts_with(raw, "[") == false { ↩ []; }
    ≔ parsed = json_parse(raw);
    ⎇ type_of(parsed) != "array" ∧ type_of(parsed) != "list" { ↩ []; }
    ↩ parsed
}

rite task_save(tasks) { fs_write(task_queue_path(), json_stringify(tasks)); }

rite task_find_pending(tasks) {
    ≔ mut i = 0;
    ⟳ i < len(tasks) {
        ⎇ map_get(tasks[i], "status") == "pending" { ↩ tasks[i]; }
        i = i + 1;
    }
    ↩ null
}

// NOTE: task_mark_dispatched/task_mark_done cannot be helper functions because
// array slot assignment (tasks[i] = {...}) does NOT propagate through function
// call boundaries in Sigil. These updates must be inlined at each call site
// where the tasks array is declared in the same scope.

// ============================================================================
// Section 2c: VTerm — Virtual Terminal Emulator
// ============================================================================

⊢ VTerm {
// Create a new VTerm with given interior dimensions
rite new(rows, cols) {
    ≔ total = rows * cols;
    ≔ mut cells = [];
    ≔ mut i = 0;
    ⟳ i < total {
        push(cells, {ch: " ", fg: 7, bg: 0});
        i = i + 1;
    }
    ≔ vt = VTerm {
        cells: cells,
        rows: rows,
        cols: cols,
        cursor_row: 0,
        cursor_col: 0,
        attr_fg: 7,
        attr_bg: 0,
        esc_state: EscapeState·Normal,
        esc_buf: "",
        scroll_top: 0,
        scroll_bottom: rows - 1,
        saved_row: 0,
        saved_col: 0,
        scrollback: [],
        scrollback_max: 1000,
        scroll_offset: 0,
        alt_cells: [],
        alt_cursor_row: 0,
        alt_cursor_col: 0,
        alt_attr_fg: 7,
        alt_attr_bg: 0,
        in_alt_screen: false,
        cursor_visible: true,
        app_cursor_keys: false,
        auto_wrap: true,
        bracketed_paste: false,
        mouse_mode: 0,
        mouse_sgr: false,
        origin_mode: false,
        title: ""
    };
    ↩ vt
}

// Scroll the VTerm up by one line (evict top line of scroll region)
rite scroll_up(self) {
    // Save evicted line to scrollback (only in main screen)
    ⎇ self.in_alt_screen == false {
        ≔ mut evicted = [];
        ≔ mut ec = 0;
        ⟳ ec < self.cols {
            ≔ idx = self.scroll_top * self.cols + ec;
            push(evicted, self.cells[idx]);
            ec = ec + 1;
        }
        push(self.scrollback, evicted);
        // Trim scrollback if over max
        ⎇ len(self.scrollback) > self.scrollback_max {
            // Remove oldest by rebuilding (drop first element)
            ≔ mut trimmed = [];
            ≔ mut ti = 1;
            ⟳ ti < len(self.scrollback) {
                push(trimmed, self.scrollback[ti]);
                ti = ti + 1;
            }
            self.scrollback = trimmed;
        }
    }

    // Shift lines up within scroll region
    ≔ mut row = self.scroll_top;
    ⟳ row < self.scroll_bottom {
        ≔ mut col = 0;
        ⟳ col < self.cols {
            ≔ dst = row * self.cols + col;
            ≔ src = (row + 1) * self.cols + col;
            self.cells[dst] = self.cells[src];
            col = col + 1;
        }
        row = row + 1;
    }
    // Clear the bottom line of scroll region
    ≔ mut col = 0;
    ⟳ col < self.cols {
        ≔ idx = self.scroll_bottom * self.cols + col;
        self.cells[idx] = {ch: " ", fg: 7, bg: 0};
        col = col + 1;
    }
}

// Resize the VTerm grid in-place, preserving scrollback
    rite resize(self, new_rows, new_cols) {
    ≔ old_rows = self.rows;
    ≔ old_cols = self.cols;

    // 1. Push overflow rows to scrollback (shrink only, main screen only)
    ⎇ new_rows < old_rows ∧ self.in_alt_screen == false {
        ≔ overflow = old_rows - new_rows;
        ≔ mut i = 0;
        ⟳ i < overflow {
            ≔ mut row_cells = [];
            ≔ mut c = 0;
            ⟳ c < old_cols {
                push(row_cells, self.cells[i * old_cols + c]);
                c = c + 1;
            }
            push(self.scrollback, row_cells);
            i = i + 1;
        }
        ⟳ len(self.scrollback) > self.scrollback_max {
            ≔ mut trimmed = [];
            ≔ mut ti = 1;
            ⟳ ti < len(self.scrollback) {
                push(trimmed, self.scrollback[ti]);
                ti = ti + 1;
            }
            self.scrollback = trimmed;
        }
    }

    // 2. Build new flat cell array
    ≔ mut new_cells = [];
    ≔ mut r = 0;
    ⟳ r < new_rows {
        ≔ old_r = r + (old_rows - new_rows);
        ≔ mut c = 0;
        ⟳ c < new_cols {
            ⎇ old_r >= 0 ∧ old_r < old_rows ∧ c < old_cols {
                push(new_cells, self.cells[old_r * old_cols + c]);
            } ⎉ {
                push(new_cells, {ch: " ", fg: 7, bg: 0});
            }
            c = c + 1;
        }
        r = r + 1;
    }

    // 3. Update state
    self.cells = new_cells;
    self.rows = new_rows;
    self.cols = new_cols;
    self.scroll_top = 0;
    self.scroll_bottom = new_rows - 1;
    self.scroll_offset = 0;

    // 4. Clamp cursor
    ⎇ self.cursor_row >= new_rows { self.cursor_row = new_rows - 1; }
    ⎇ self.cursor_col >= new_cols { self.cursor_col = new_cols - 1; }

    // 5. Discard alt screen (rebuilt on next enter)
    self.alt_cells = [];
}

// Write a printable character at the cursor position
// ch should be a string (use to_string(char_at(...)) when feeding)
rite put_char(self, ch) {
    // Fullwidth char at last column: wrap early (can't split across lines)
    ⎇ is_fullwidth(ch) == true ∧ self.cursor_col == self.cols - 1 ∧ self.auto_wrap == true {
        self.cursor_col = self.cols;
    }
    // Handle line wrap (respects auto_wrap flag)
    ⎇ self.cursor_col >= self.cols {
        ⎇ self.auto_wrap == true {
            self.cursor_col = 0;
            self.cursor_row = self.cursor_row + 1;
            ⎇ self.cursor_row > self.scroll_bottom {
                self.scroll_up();
                self.cursor_row = self.scroll_bottom;
            }
        } ⎉ {
            // No wrap: stay at last column
            self.cursor_col = self.cols - 1;
        }
    }

    ≔ idx = self.cursor_row * self.cols + self.cursor_col;
    ⎇ idx >= 0 ∧ idx < len(self.cells) {
        self.cells[idx] = {ch: ch, fg: self.attr_fg, bg: self.attr_bg};
    }
    // Fullwidth characters occupy 2 columns
    ⎇ is_fullwidth(ch) == true {
        ⎇ self.cursor_col + 1 < self.cols {
            ≔ idx2 = self.cursor_row * self.cols + self.cursor_col + 1;
            ⎇ idx2 >= 0 ∧ idx2 < len(self.cells) {
                self.cells[idx2] = {ch: "", fg: self.attr_fg, bg: self.attr_bg};
            }
        }
        self.cursor_col = self.cursor_col + 2;
    } ⎉ {
        self.cursor_col = self.cursor_col + 1;
    }
}

} // end ⊢ VTerm (part 1)

// Parse CSI parameters string into array of ints (standalone utility)
rite vterm_parse_params(buf) {
    ≔ mut params = [];
    ⎇ buf != "" {
        ≔ parts = split(buf, ";");
        ≔ mut i = 0;
        ⟳ i < len(parts) {
            ⎇ parts[i] == "" {
                push(params, 0);
            } ⎉ {
                push(params, to_int(parts[i]));
            }
            i = i + 1;
        }
    }
    params
}

⊢ VTerm {
// Dispatch a CSI command
rite csi_dispatch(self, cmd, buf) {
    // DEC private mode: CSI ? prefix
    ≔ mut dec_handled = false;
    ⎇ len(buf) > 0 ∧ starts_with(buf, "?") == true {
        ≔ stripped = substring(buf, 1, len(buf));
        self.dec_private_dispatch(cmd, stripped);
        dec_handled = true;
    }

    // SGR mouse from child process: CSI < prefix — strip and ignore (mouse events from
    // child output are display-only; we don't re-interpret them in our own VTerm)
    ⎇ dec_handled == false ∧ len(buf) > 0 ∧ starts_with(buf, "<") == true {
        dec_handled = true;
    }

  ⎇ dec_handled == false {
    ≔ params = vterm_parse_params(buf);
    ≔ mut n = 0;
    ⎇ len(params) > 0 {
        n = params[0];
    }

    ⌥ cmd {
        "m" => {
            // SGR - Set Graphics Rendition
            ⎇ len(params) == 0 {
                // CSI m = reset
                self.attr_fg = 7;
                self.attr_bg = 0;
            } ⎉ {
                ≔ mut pi = 0;
                ⟳ pi < len(params) {
                    ≔ p = params[pi];
                    ⎇ p == 0 {
                        self.attr_fg = 7;
                        self.attr_bg = 0;
                    }
                    ⎇ p == 1 {
                        // Bold — brighten fg by adding 8
                        ⎇ self.attr_fg < 8 {
                            self.attr_fg = self.attr_fg + 8;
                        }
                    }
                    // Italic (3) and underline (4) — accept silently
                    ⎇ p == 3 ∨ p == 4 {
                        // Visual attributes not tracked separately
                    }
                    // Inverse video (7) — swap fg/bg
                    ⎇ p == 7 {
                        ≔ tmp_fg = self.attr_fg;
                        self.attr_fg = self.attr_bg;
                        self.attr_bg = tmp_fg;
                    }
                    // Reverse inverse (27) — swap back
                    ⎇ p == 27 {
                        ≔ tmp_fg = self.attr_fg;
                        self.attr_fg = self.attr_bg;
                        self.attr_bg = tmp_fg;
                    }
                    // Standard foreground: 30-37
                    ⎇ p >= 30 ∧ p <= 37 {
                        self.attr_fg = p - 30;
                    }
                    // Default foreground (39)
                    ⎇ p == 39 {
                        self.attr_fg = 7;
                    }
                    // Standard background: 40-47
                    ⎇ p >= 40 ∧ p <= 47 {
                        self.attr_bg = p - 40;
                    }
                    // Default background (49)
                    ⎇ p == 49 {
                        self.attr_bg = 0;
                    }
                    // 256-color foreground: 38;5;N
                    ⎇ p == 38 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 5 ∧ pi + 2 < len(params) {
                        self.attr_fg = params[pi + 2];
                        pi = pi + 2;
                    }
                    // 256-color background: 48;5;N
                    ⎇ p == 48 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 5 ∧ pi + 2 < len(params) {
                        self.attr_bg = params[pi + 2];
                        pi = pi + 2;
                    }
                    // True color foreground: 38;2;R;G;B (packed int: 256 + R*65536 + G*256 + B)
                    ⎇ p == 38 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 2 ∧ pi + 4 < len(params) {
                        self.attr_fg = 256 + params[pi + 2] * 65536 + params[pi + 3] * 256 + params[pi + 4];
                        pi = pi + 4;
                    }
                    // True color background: 48;2;R;G;B (packed int: 256 + R*65536 + G*256 + B)
                    ⎇ p == 48 ∧ pi + 1 < len(params) ∧ params[pi + 1] == 2 ∧ pi + 4 < len(params) {
                        self.attr_bg = 256 + params[pi + 2] * 65536 + params[pi + 3] * 256 + params[pi + 4];
                        pi = pi + 4;
                    }
                    // Bright foreground: 90-97
                    ⎇ p >= 90 ∧ p <= 97 {
                        self.attr_fg = p - 90 + 8;
                    }
                    // Bright background: 100-107
                    ⎇ p >= 100 ∧ p <= 107 {
                        self.attr_bg = p - 100 + 8;
                    }
                    pi = pi + 1;
                }
            }
        }
        "H" | "f" => {
            // CUP - Cursor Position: CSI row;col H
            ≔ mut row = 1;
            ≔ mut col = 1;
            ⎇ len(params) >= 1 ∧ params[0] > 0 {
                row = params[0];
            }
            ⎇ len(params) >= 2 ∧ params[1] > 0 {
                col = params[1];
            }
            self.cursor_row = row - 1;
            self.cursor_col = col - 1;
            // Clamp
            ⎇ self.cursor_row >= self.rows {
                self.cursor_row = self.rows - 1;
            }
            ⎇ self.cursor_col >= self.cols {
                self.cursor_col = self.cols - 1;
            }
        }
        "J" => {
            // ED - Erase Display: CSI n J
            ⎇ n == 0 {
                // Erase from cursor to end
                ≔ mut r = self.cursor_row;
                ⟳ r < self.rows {
                    ≔ mut c_start = 0;
                    ⎇ r == self.cursor_row {
                        c_start = self.cursor_col;
                    }
                    ≔ mut c = c_start;
                    ⟳ c < self.cols {
                        self.cells[r * self.cols + c] = {ch: " ", fg: 7, bg: 0};
                        c = c + 1;
                    }
                    r = r + 1;
                }
            }
            ⎇ n == 1 {
                // Erase from start to cursor
                ≔ mut r = 0;
                ⟳ r <= self.cursor_row {
                    ≔ mut c_end = self.cols;
                    ⎇ r == self.cursor_row {
                        c_end = self.cursor_col + 1;
                    }
                    ≔ mut c = 0;
                    ⟳ c < c_end {
                        self.cells[r * self.cols + c] = {ch: " ", fg: 7, bg: 0};
                        c = c + 1;
                    }
                    r = r + 1;
                }
            }
            ⎇ n == 2 ∨ n == 3 {
                // Erase all
                ≔ mut ei = 0;
                ⟳ ei < len(self.cells) {
                    self.cells[ei] = {ch: " ", fg: 7, bg: 0};
                    ei = ei + 1;
                }
            }
        }
        "K" => {
            // EL - Erase Line: CSI n K
            ≔ row_start = self.cursor_row * self.cols;
            ⎇ n == 0 {
                // Erase from cursor to end of line
                ≔ mut c = self.cursor_col;
                ⟳ c < self.cols {
                    self.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
            }
            ⎇ n == 1 {
                // Erase from start of line to cursor
                ≔ mut c = 0;
                ⟳ c <= self.cursor_col {
                    self.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
            }
            ⎇ n == 2 {
                // Erase entire line
                ≔ mut c = 0;
                ⟳ c < self.cols {
                    self.cells[row_start + c] = {ch: " ", fg: 7, bg: 0};
                    c = c + 1;
                }
            }
        }
        "A" => {
            // CUU - Cursor Up: CSI n A
            ≔ mut amount = 1;
            ⎇ n > 0 {
                amount = n;
            }
            self.cursor_row = self.cursor_row - amount;
            ⎇ self.cursor_row < 0 {
                self.cursor_row = 0;
            }
        }
        "B" => {
            // CUD - Cursor Down: CSI n B
            ≔ mut amount = 1;
            ⎇ n > 0 {
                amount = n;
            }
            self.cursor_row = self.cursor_row + amount;
            ⎇ self.cursor_row >= self.rows {
                self.cursor_row = self.rows - 1;
            }
        }
        "C" => {
            // CUF - Cursor Forward: CSI n C
            ≔ mut amount = 1;
            ⎇ n > 0 {
                amount = n;
            }
            self.cursor_col = self.cursor_col + amount;
            ⎇ self.cursor_col >= self.cols {
                self.cursor_col = self.cols - 1;
            }
        }
        "D" => {
            // CUB - Cursor Back: CSI n D
            ≔ mut amount = 1;
            ⎇ n > 0 {
                amount = n;
            }
            self.cursor_col = self.cursor_col - amount;
            ⎇ self.cursor_col < 0 {
                self.cursor_col = 0;
            }
        }
        "G" => {
            // CHA - Cursor Horizontal Absolute: CSI n G
            ≔ mut col = 1;
            ⎇ n > 0 {
                col = n;
            }
            self.cursor_col = col - 1;
            ⎇ self.cursor_col >= self.cols {
                self.cursor_col = self.cols - 1;
            }
        }
        "d" => {
            // VPA - Vertical Position Absolute: CSI n d
            ≔ mut row = 1;
            ⎇ n > 0 {
                row = n;
            }
            self.cursor_row = row - 1;
            ⎇ self.cursor_row >= self.rows {
                self.cursor_row = self.rows - 1;
            }
        }
        "r" => {
            // DECSTBM - Set Top/Bottom Margins: CSI top;bottom r
            ≔ mut top = 1;
            ≔ mut bottom = self.rows;
            ⎇ len(params) >= 1 ∧ params[0] > 0 {
                top = params[0];
            }
            ⎇ len(params) >= 2 ∧ params[1] > 0 {
                bottom = params[1];
            }
            self.scroll_top = top - 1;
            self.scroll_bottom = bottom - 1;
            // Clamp
            ⎇ self.scroll_top < 0 {
                self.scroll_top = 0;
            }
            ⎇ self.scroll_bottom >= self.rows {
                self.scroll_bottom = self.rows - 1;
            }
            // Move cursor to home
            self.cursor_row = 0;
            self.cursor_col = 0;
        }
        "s" => {
            // Save cursor: CSI s
            self.saved_row = self.cursor_row;
            self.saved_col = self.cursor_col;
        }
        "u" => {
            // Restore cursor: CSI u
            self.cursor_row = self.saved_row;
            self.cursor_col = self.saved_col;
        }
        "L" => {
            // IL - Insert Lines: CSI n L
            ≔ mut count = 1;
            ⎇ n > 0 { count = n; }
            // Shift lines down from cursor row, clear inserted lines
            ≔ mut ci = 0;
            ⟳ ci < count {
                ≔ mut row = self.scroll_bottom;
                ⟳ row > self.cursor_row {
                    ≔ mut col = 0;
                    ⟳ col < self.cols {
                        self.cells[row * self.cols + col] = self.cells[(row - 1) * self.cols + col];
                        col = col + 1;
                    }
                    row = row - 1;
                }
                // Clear the inserted line
                ≔ mut col = 0;
                ⟳ col < self.cols {
                    self.cells[self.cursor_row * self.cols + col] = {ch: " ", fg: 7, bg: 0};
                    col = col + 1;
                }
                ci = ci + 1;
            }
        }
        "M" => {
            // DL - Delete Lines: CSI n M
            ≔ mut count = 1;
            ⎇ n > 0 { count = n; }
            ≔ mut ci = 0;
            ⟳ ci < count {
                ≔ mut row = self.cursor_row;
                ⟳ row < self.scroll_bottom {
                    ≔ mut col = 0;
                    ⟳ col < self.cols {
                        self.cells[row * self.cols + col] = self.cells[(row + 1) * self.cols + col];
                        col = col + 1;
                    }
                    row = row + 1;
                }
                // Clear the bottom line
                ≔ mut col = 0;
                ⟳ col < self.cols {
                    self.cells[self.scroll_bottom * self.cols + col] = {ch: " ", fg: 7, bg: 0};
                    col = col + 1;
                }
                ci = ci + 1;
            }
        }
        "@" => {
            // ICH - Insert Characters: CSI n @
            ≔ mut count = 1;
            ⎇ n > 0 { count = n; }
            ≔ row_base = self.cursor_row * self.cols;
            // Shift chars right from end of line
            ≔ mut col = self.cols - 1;
            ⟳ col >= self.cursor_col + count {
                self.cells[row_base + col] = self.cells[row_base + col - count];
                col = col - 1;
            }
            // Clear inserted positions
            ≔ mut ci = 0;
            ⟳ ci < count ∧ self.cursor_col + ci < self.cols {
                self.cells[row_base + self.cursor_col + ci] = {ch: " ", fg: 7, bg: 0};
                ci = ci + 1;
            }
        }
        "P" => {
            // DCH - Delete Characters: CSI n P
            ≔ mut count = 1;
            ⎇ n > 0 { count = n; }
            ≔ row_base = self.cursor_row * self.cols;
            // Shift chars left
            ≔ mut col = self.cursor_col;
            ⟳ col + count < self.cols {
                self.cells[row_base + col] = self.cells[row_base + col + count];
                col = col + 1;
            }
            // Clear vacated positions at end
            ≔ mut ci = 0;
            ⟳ ci < count {
                ≔ clear_col = self.cols - 1 - ci;
                ⎇ clear_col >= 0 {
                    self.cells[row_base + clear_col] = {ch: " ", fg: 7, bg: 0};
                }
                ci = ci + 1;
            }
        }
        "X" => {
            // ECH - Erase Characters: CSI n X
            ≔ mut count = 1;
            ⎇ n > 0 { count = n; }
            ≔ row_base = self.cursor_row * self.cols;
            ≔ mut ci = 0;
            ⟳ ci < count ∧ self.cursor_col + ci < self.cols {
                self.cells[row_base + self.cursor_col + ci] = {ch: " ", fg: 7, bg: 0};
                ci = ci + 1;
            }
        }
        "E" => {
            // CNL - Cursor Next Line: CSI n E
            ≔ mut amount = 1;
            ⎇ n > 0 { amount = n; }
            self.cursor_row = self.cursor_row + amount;
            ⎇ self.cursor_row >= self.rows { self.cursor_row = self.rows - 1; }
            self.cursor_col = 0;
        }
        "F" => {
            // CPL - Cursor Previous Line: CSI n F
            ≔ mut amount = 1;
            ⎇ n > 0 { amount = n; }
            self.cursor_row = self.cursor_row - amount;
            ⎇ self.cursor_row < 0 { self.cursor_row = 0; }
            self.cursor_col = 0;
        }
        _ => {}
    }
  }
}

// Enter alternate screen buffer
rite enter_alt_screen(self) {
    // Save main screen cells
    ≔ mut saved = [];
    ≔ mut i = 0;
    ⟳ i < len(self.cells) {
        push(saved, {ch: self.cells[i].ch, fg: self.cells[i].fg, bg: self.cells[i].bg});
        i = i + 1;
    }
    self.alt_cells = saved;
    // Save cursor and attributes
    self.alt_cursor_row = self.cursor_row;
    self.alt_cursor_col = self.cursor_col;
    self.alt_attr_fg = self.attr_fg;
    self.alt_attr_bg = self.attr_bg;
    // Clear screen
    ≔ mut ci = 0;
    ⟳ ci < len(self.cells) {
        self.cells[ci] = {ch: " ", fg: 7, bg: 0};
        ci = ci + 1;
    }
    self.cursor_row = 0;
    self.cursor_col = 0;
    self.in_alt_screen = true;
}

// Leave alternate screen buffer
rite leave_alt_screen(self) {
    // Restore main screen cells
    ⎇ len(self.alt_cells) > 0 {
        ≔ mut i = 0;
        ⟳ i < len(self.alt_cells) ∧ i < len(self.cells) {
            self.cells[i] = self.alt_cells[i];
            i = i + 1;
        }
    }
    // Restore cursor and attributes
    self.cursor_row = self.alt_cursor_row;
    self.cursor_col = self.alt_cursor_col;
    self.attr_fg = self.alt_attr_fg;
    self.attr_bg = self.alt_attr_bg;
    self.alt_cells = [];
    self.in_alt_screen = false;
}

// Set a DEC private mode on or off
rite set_dec_mode(self, mode, enabled) {
    // ?1 - Application cursor keys
    ⎇ mode == 1 {
        self.app_cursor_keys = enabled;
    }
    // ?6 - Origin mode
    ⎇ mode == 6 {
        self.origin_mode = enabled;
    }
    // ?7 - Auto-wrap
    ⎇ mode == 7 {
        self.auto_wrap = enabled;
    }
    // ?25 - Cursor visible
    ⎇ mode == 25 {
        self.cursor_visible = enabled;
    }
    // ?1000 - Mouse tracking (normal)
    ⎇ mode == 1000 {
        ⎇ enabled == true {
            self.mouse_mode = 1000;
        } ⎉ {
            self.mouse_mode = 0;
        }
    }
    // ?1002 - Mouse button tracking
    ⎇ mode == 1002 {
        ⎇ enabled == true {
            self.mouse_mode = 1002;
        } ⎉ {
            self.mouse_mode = 0;
        }
    }
    // ?1003 - Mouse any-event tracking
    ⎇ mode == 1003 {
        ⎇ enabled == true {
            self.mouse_mode = 1003;
        } ⎉ {
            self.mouse_mode = 0;
        }
    }
    // ?1006 - SGR mouse mode
    ⎇ mode == 1006 {
        self.mouse_sgr = enabled;
    }
    // ?1049 - Alternate screen buffer (save/restore)
    ⎇ mode == 1049 {
        ⎇ enabled == true {
            self.enter_alt_screen();
        } ⎉ {
            self.leave_alt_screen();
        }
    }
    // ?2004 - Bracketed paste
    ⎇ mode == 2004 {
        self.bracketed_paste = enabled;
    }
}

// Dispatch DEC private mode sequence (after ? stripped)
rite dec_private_dispatch(self, cmd, buf) {
    ≔ params = vterm_parse_params(buf);
    ≔ mut enabled = false;
    ⎇ cmd == "h" {
        enabled = true;
    }
    ≔ mut i = 0;
    ⟳ i < len(params) {
        self.set_dec_mode(params[i], enabled);
        i = i + 1;
    }
}

// Reverse index: move cursor up; if at scroll_top, shift lines down
rite reverse_index(self) {
    ⎇ self.cursor_row == self.scroll_top {
        // Shift lines down within scroll region
        ≔ mut row = self.scroll_bottom;
        ⟳ row > self.scroll_top {
            ≔ mut col = 0;
            ⟳ col < self.cols {
                ≔ dst = row * self.cols + col;
                ≔ src = (row - 1) * self.cols + col;
                self.cells[dst] = self.cells[src];
                col = col + 1;
            }
            row = row - 1;
        }
        // Clear the top line of scroll region
        ≔ mut col = 0;
        ⟳ col < self.cols {
            self.cells[self.scroll_top * self.cols + col] = {ch: " ", fg: 7, bg: 0};
            col = col + 1;
        }
    } ⎉ {
        ⎇ self.cursor_row > 0 {
            self.cursor_row = self.cursor_row - 1;
        }
    }
}

// Strip control characters from a string (keep printable only)
rite sanitize_title(s) {
    ≔ mut result = "";
    ≔ mut i = 0;
    ⟳ i < len(s) {
        ≔ code = char_code_at(s, i);
        ⎇ code >= 32 ∧ code != 127 {
            result = result + to_string(char_at(s, i));
        }
        i = i + 1;
    }
    ↩ result
}

// Dispatch an OSC sequence
rite osc_dispatch(self, buf) {
    // Find the first semicolon to separate command from payload
    ≔ mut sep_idx = -1;
    ≔ mut si = 0;
    ⟳ si < len(buf) {
        ⎇ to_string(char_at(buf, si)) == ";" {
            ⎇ sep_idx == -1 {
                sep_idx = si;
            }
        }
        si = si + 1;
    }
    ⎇ sep_idx >= 0 {
        ≔ cmd_str = substring(buf, 0, sep_idx);
        ≔ payload = substring(buf, sep_idx + 1, len(buf));
        // OSC 0 and OSC 2 set title (sanitize to remove control chars)
        ⎇ cmd_str == "0" ∨ cmd_str == "2" {
            self.title = sanitize_title(payload);
        }
    }
}

// Feed a string of data through the VTerm state machine
rite feed(self, data) {
    ≔ mut i = 0;
    ⟳ i < len(data) {
        ≔ ch = to_string(char_at(data, i));
        ≔ code = char_code_at(data, i);

        // State machine: ⌥ match on EscapeState enum — exactly ONE arm fires per byte
        ⌥ self.esc_state {
            EscapeState·Csi => {
                ⎇ (code >= 64 ∧ code <= 90) ∨ (code >= 97 ∧ code <= 122) {
                    self.csi_dispatch(ch, self.esc_buf);
                    self.esc_state = EscapeState·Normal;
                    self.esc_buf = "";
                } ⎉ {
                    self.esc_buf = self.esc_buf + ch;
                    ⎇ len(self.esc_buf) > ESC_BUF_MAX {
                        self.esc_state = EscapeState·Normal;
                        self.esc_buf = "";
                    }
                }
            }
            EscapeState·Osc => {
                ⎇ code == 7 {
                    self.osc_dispatch(self.esc_buf);
                    self.esc_state = EscapeState·Normal;
                    self.esc_buf = "";
                } ⎉ { ⎇ code == 27 {
                    self.esc_state = EscapeState·OscEsc;
                } ⎉ {
                    self.esc_buf = self.esc_buf + ch;
                    ⎇ len(self.esc_buf) > ESC_BUF_MAX {
                        self.esc_state = EscapeState·Normal;
                        self.esc_buf = "";
                    }
                } }
            }
            EscapeState·OscEsc => {
                ⎇ ch == "\\" {
                    self.osc_dispatch(self.esc_buf);
                    self.esc_state = EscapeState·Normal;
                    self.esc_buf = "";
                } ⎉ {
                    self.osc_dispatch(self.esc_buf);
                    self.esc_state = EscapeState·Escape;
                    self.esc_buf = "";
                }
            }
            EscapeState·Dcs => {
                ⎇ code == 27 {
                    self.esc_state = EscapeState·DcsEsc;
                }
            }
            EscapeState·DcsEsc => {
                ⎇ ch == "\\" {
                    self.esc_state = EscapeState·Normal;
                    self.esc_buf = "";
                } ⎉ {
                    self.esc_state = EscapeState·Dcs;
                }
            }
            EscapeState·Charset => {
                self.esc_state = EscapeState·Normal;
            }
            EscapeState·Escape => {
                ⎇ ch == "[" {
                    self.esc_state = EscapeState·Csi;
                    self.esc_buf = "";
                } ⎉ { ⎇ ch == "]" {
                    self.esc_state = EscapeState·Osc;
                    self.esc_buf = "";
                } ⎉ { ⎇ ch == "P" {
                    self.esc_state = EscapeState·Dcs;
                    self.esc_buf = "";
                } ⎉ { ⎇ ch == "(" ∨ ch == ")" ∨ ch == "*" ∨ ch == "+" {
                    self.esc_state = EscapeState·Charset;
                } ⎉ { ⎇ ch == "7" {
                    self.saved_row = self.cursor_row;
                    self.saved_col = self.cursor_col;
                    self.esc_state = EscapeState·Normal;
                } ⎉ { ⎇ ch == "8" {
                    self.cursor_row = self.saved_row;
                    self.cursor_col = self.saved_col;
                    self.esc_state = EscapeState·Normal;
                } ⎉ { ⎇ ch == "M" {
                    self.reverse_index();
                    self.esc_state = EscapeState·Normal;
                } ⎉ {
                    self.esc_state = EscapeState·Normal;
                } } } } } } }
            }
            _ => {
                // Normal state — ⎇/⎉ chain so only ONE handler fires per byte
                ⎇ code == 27 {
                    self.esc_state = EscapeState·Escape;
                    self.esc_buf = "";
                } ⎉ { ⎇ code == 13 {
                    self.cursor_col = 0;
                } ⎉ { ⎇ code == 10 {
                    self.cursor_col = 0;  // LF implies CR for internal feeds
                    self.cursor_row = self.cursor_row + 1;
                    ⎇ self.cursor_row > self.scroll_bottom {
                        self.scroll_up();
                        self.cursor_row = self.scroll_bottom;
                    }
                } ⎉ { ⎇ code == 8 {
                    ⎇ self.cursor_col > 0 { self.cursor_col = self.cursor_col - 1; }
                } ⎉ { ⎇ code == 9 {
                    self.cursor_col = ((self.cursor_col / 8) + 1) * 8;
                    ⎇ self.cursor_col >= self.cols { self.cursor_col = self.cols - 1; }
                } ⎉ { ⎇ code >= 32 {
                    self.put_char(ch);
                } } } } } }
            }
        }

        i = i + 1;
    }
    // scroll_offset preserved: user stays scrolled when new output arrives
}

// Blit VTerm cells to the main Grid at the given region (inside borders)
rite blit(self, grid, region) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;

    // Check if scrolled back
    ⎇ self.scroll_offset > 0 ∧ len(self.scrollback) > 0 {
        // Render from scrollback
        ≔ mut sb_start = len(self.scrollback) - self.scroll_offset;
        ⎇ sb_start < 0 {
            sb_start = 0;
        }
        ≔ mut row = 0;
        ⟳ row < self.rows {
            ≔ sb_idx = sb_start + row;
            ⎇ sb_idx < len(self.scrollback) {
                // Render scrollback line
                ≔ line = self.scrollback[sb_idx];
                ≔ mut col = 0;
                ⟳ col < self.cols ∧ col < len(line) {
                    grid.set(inner_y + row, inner_x + col, line[col].ch, line[col].fg, line[col].bg);
                    col = col + 1;
                }
            } ⎉ {
                // Render from live buffer (for lines beyond scrollback)
                ≔ live_row = row - (len(self.scrollback) - sb_start);
                ⎇ live_row >= 0 ∧ live_row < self.rows {
                    ≔ mut col = 0;
                    ⟳ col < self.cols {
                        ≔ idx = live_row * self.cols + col;
                        grid.set(inner_y + row, inner_x + col, self.cells[idx].ch, self.cells[idx].fg, self.cells[idx].bg);
                        col = col + 1;
                    }
                }
            }
            row = row + 1;
        }
    } ⎉ {
        // Live view — render directly from VTerm cells
        ≔ mut row = 0;
        ⟳ row < self.rows {
            ≔ mut col = 0;
            ⟳ col < self.cols {
                ≔ idx = row * self.cols + col;
                ⎇ idx < len(self.cells) {
                    grid.set(inner_y + row, inner_x + col, self.cells[idx].ch, self.cells[idx].fg, self.cells[idx].bg);
                }
                col = col + 1;
            }
            row = row + 1;
        }
    }
}

} // end ⊢ VTerm (part 2)

// ============================================================================
// Section 2c: Configuration
// ============================================================================

// Load config from ~/.morgoth/config.json, return defaults if missing
rite load_config() {
    ≔ home = env("HOME");
    ≔ config_path = home + "/.morgoth/config.json";

    ≔ mut cfg = {
        shell: "/bin/bash",
        scrollback_lines: 1000,
        leader_key: 2,
        hmr: false,
        max_panes: 12,
        session_restore: true
    };

    // Use $SHELL env var as default (overridden by config.json if set)
    // Concatenate with "" to coerce evidential → plain string before fs_exists
    ≔ env_shell = env("SHELL");
    ⎇ env_shell != null {
        cfg.shell = "" + env_shell;
    }

    ⎇ fs_exists(config_path) == true {
        ≔ raw = fs_read(config_path);
        // Guard: only parse if non-empty and starts with "{"
        ⎇ len(raw) > 0 ∧ starts_with(raw, "{") == true {
            ≔ j = json_parse(raw);

            // grid and panes keys are ignored (Phase 9: profiles replace static config)
            ≔ j_shell = map_get(j, "shell");
            ⎇ j_shell != null { cfg.shell = j_shell; }
            ≔ j_scrollback = map_get(j, "scrollback_lines");
            ⎇ j_scrollback != null { cfg.scrollback_lines = j_scrollback; }
            ≔ j_leader = map_get(j, "leader_key");
            ⎇ j_leader != null { cfg.leader_key = j_leader; }
            ≔ j_hmr = map_get(j, "hmr");
            ⎇ j_hmr != null { cfg.hmr = j_hmr; }
            ≔ j_max = map_get(j, "max_panes");
            ⎇ j_max != null { cfg.max_panes = j_max; }
            ≔ j_session_restore = map_get(j, "session_restore");
            ⎇ j_session_restore != null { cfg.session_restore = j_session_restore; }
        }
    }

    // MORGOTH_HMR_OVERRIDE=1 forces HMR on (set by launch.sh --hmr flag)
    ⎇ Sys·getenv("MORGOTH_HMR_OVERRIDE") == "1" { cfg.hmr = true; }

    // Validate shell path
    cfg.shell = validate_shell(cfg.shell);

    ↩ cfg
}

// Validate that a shell path exists; fall back to DEFAULT_SHELL
rite validate_shell(shell) {
    ⎇ fs_exists(shell) == true {
        ↩ shell
    }
    ↩ DEFAULT_SHELL
}

// Load startup pane types from profile (or default to single terminal)
// Clamps to max_panes to prevent resource exhaustion
rite load_profile(max_panes) {
    ≔ home = env("HOME");
    ≔ profile_path = home + "/.morgoth/profiles/default.json";
    ≔ mut panes = [];
    push(panes, "terminal");
    ⎇ fs_exists(profile_path) == true {
        ≔ raw = fs_read(profile_path);
        // Profile format is a plain JSON array: ["terminal","monitor"]
        ⎇ len(raw) > 0 ∧ starts_with(raw, "[") == true {
            ≔ j_panes = json_parse(raw);
            ⎇ j_panes != null ∧ len(j_panes) > 0 {
                panes = j_panes;
            }
        }
    }
    // Clamp to max_panes
    ⎇ len(panes) > max_panes {
        ≔ mut clamped = [];
        ≔ mut ci = 0;
        ⟳ ci < max_panes {
            push(clamped, panes[ci]);
            ci = ci + 1;
        }
        panes = clamped;
    }
    ↩ panes
}

// Save current pane layout to profile
rite save_profile(panes) {
    ≔ home = env("HOME");
    ≔ dir_path = home + "/.morgoth/profiles";
    ⎇ fs_exists(dir_path) == false {
        fs_mkdir(dir_path);
    }
    ≔ mut types = [];
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        push(types, panes[i].pane_type);
        i = i + 1;
    }
    ≔ json = json_stringify(types);
    fs_write(dir_path + "/default.json", json);
}

// ============================================================================
// Section 2b: Session Persistence (Phase 18)
// ============================================================================

// Load configurable keybindings from ~/.morgoth/config.json (Phase 20)
// Returns object with byte codes for each configurable leader action.
// Defaults match hardcoded values from prior phases.
rite load_bindings() {
    ≔ mut b = {
        new_terminal: 99,
        new_monitor:  109,
        close_pane:   120,
        zoom_toggle:  122,
        copy_mode:    91,
        save_profile: 83,
        help:         63
    };
    ≔ home = env("HOME");
    ≔ config_path = home + "/.morgoth/config.json";
    ⎇ fs_exists(config_path) == true {
        ≔ raw = fs_read(config_path);
        ⎇ len(raw) > 0 ∧ starts_with(raw, "{") == true {
            ≔ j = json_parse(raw);
            ≔ jb = map_get(j, "bindings");
            ⎇ jb != null {
                ≔ v = map_get(jb, "new_terminal");
                ⎇ v != null ∧ len(v) > 0 { b.new_terminal = char_code_at(v, 0); }
                ≔ v = map_get(jb, "new_monitor");
                ⎇ v != null ∧ len(v) > 0 { b.new_monitor = char_code_at(v, 0); }
                ≔ v = map_get(jb, "close_pane");
                ⎇ v != null ∧ len(v) > 0 { b.close_pane = char_code_at(v, 0); }
                ≔ v = map_get(jb, "zoom_toggle");
                ⎇ v != null ∧ len(v) > 0 { b.zoom_toggle = char_code_at(v, 0); }
                ≔ v = map_get(jb, "copy_mode");
                ⎇ v != null ∧ len(v) > 0 { b.copy_mode = char_code_at(v, 0); }
                ≔ v = map_get(jb, "save_profile");
                ⎇ v != null ∧ len(v) > 0 { b.save_profile = char_code_at(v, 0); }
                ≔ v = map_get(jb, "help");
                ⎇ v != null ∧ len(v) > 0 { b.help = char_code_at(v, 0); }
            }
        }
    }
    ↩ b
}

// Extract scrollback buffer as plain text lines (scrollback rows only, not visible area)
rite extract_scrollback_text(vt) {
    ≔ mut lines = [];
    ≔ mut si = 0;
    ⟳ si < len(vt.scrollback) {
        ≔ mut line = "";
        ≔ mut ci = 0;
        ⟳ ci < len(vt.scrollback[si]) {
            ⎇ vt.scrollback[si][ci].ch != "" {
                line = line + vt.scrollback[si][ci].ch;
            }
            ci = ci + 1;
        }
        push(lines, line);
        si = si + 1;
    }
    ↩ lines
}

// Save session to ~/.morgoth/session.json: pane types + scrollback text
rite save_session(panes) {
    ≔ home = env("HOME");
    ≔ dir_path = home + "/.morgoth";
    ⎇ fs_exists(dir_path) == false {
        fs_mkdir(dir_path);
    }
    ≔ mut sess_panes = [];
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ≔ mut sb_lines = [];
        ⎇ panes[i].pane_type == "terminal" {
            sb_lines = extract_scrollback_text(panes[i].vterm);
        }
        push(sess_panes, {pane_type: panes[i].pane_type, scrollback: sb_lines});
        i = i + 1;
    }
    ≔ session = {panes: sess_panes};
    ≔ json = json_stringify(session);
    fs_write(dir_path + "/session.json", json);
}

// Load session from ~/.morgoth/session.json
// Returns array of {pane_type, scrollback} maps, or null if no session file
rite load_session() {
    ≔ home = env("HOME");
    ≔ session_path = home + "/.morgoth/session.json";
    ⎇ fs_exists(session_path) == false {
        ↩ null
    }
    ≔ raw = fs_read(session_path);
    ⎇ len(raw) == 0 ∨ starts_with(raw, "{") == false {
        ↩ null
    }
    ≔ j = json_parse(raw);
    ≔ sess_panes = map_get(j, "panes");
    ⎇ sess_panes == null {
        ↩ null
    }
    ↩ sess_panes
}

⊢ VTerm {
// Restore scrollback into a VTerm from saved text lines
// lines: array of strings, one per scrollback row
rite restore_scrollback(self, lines) {
    ≔ mut si = 0;
    ⟳ si < len(lines) {
        ≔ line = lines[si];
        ≔ mut cells = [];
        ≔ mut ci = 0;
        ⟳ ci < len(line) {
            ≔ ch = to_string(char_at(line, ci));
            push(cells, {ch: ch, fg: 7, bg: 0, dirty: false});
            ci = ci + 1;
        }
        // Pad row to terminal width
        ⟳ len(cells) < self.cols {
            push(cells, {ch: " ", fg: 7, bg: 0, dirty: false});
        }
        push(self.scrollback, cells);
        // Trim scrollback to max
        ⟳ len(self.scrollback) > self.scrollback_max {
            ≔ mut trimmed = [];
            ≔ mut ti = 1;
            ⟳ ti < len(self.scrollback) {
                push(trimmed, self.scrollback[ti]);
                ti = ti + 1;
            }
            self.scrollback = trimmed;
        }
        si = si + 1;
    }
}
} // end ⊢ VTerm (part 3)

// ============================================================================
// Section 2c: Named Profiles (Phase 19)
// ============================================================================

// List available profile names from ~/.morgoth/profiles/
// Returns array of profile name strings (without .json extension)
rite list_profiles() {
    ≔ home = env("HOME");
    ≔ dir = home + "/.morgoth/profiles";
    ≔ mut names = [];
    ⎇ fs_exists(dir) == false {
        push(names, "default");
        ↩ names
    }
    ≔ files = fs_list(dir);
    ≔ mut i = 0;
    ⟳ i < len(files) {
        ≔ fname = files[i];
        ⎇ ends_with(fname, ".json") == true {
            ≔ name = substring(fname, 0, len(fname) - 5);
            push(names, name);
        }
        i = i + 1;
    }
    ⎇ len(names) == 0 {
        push(names, "default");
    }
    ↩ names
}

// Load a named profile (generic version of load_profile)
rite load_named_profile(name, max_panes) {
    ≔ home = env("HOME");
    ≔ profile_path = home + "/.morgoth/profiles/" + name + ".json";
    ≔ mut panes = [];
    push(panes, "terminal");
    ⎇ fs_exists(profile_path) == true {
        ≔ raw = fs_read(profile_path);
        ⎇ len(raw) > 0 ∧ starts_with(raw, "[") == true {
            ≔ j_panes = json_parse(raw);
            ⎇ j_panes != null ∧ len(j_panes) > 0 {
                panes = j_panes;
            }
        }
    }
    ⎇ len(panes) > max_panes {
        ≔ mut clamped = [];
        ≔ mut ci = 0;
        ⟳ ci < max_panes {
            push(clamped, panes[ci]);
            ci = ci + 1;
        }
        panes = clamped;
    }
    ↩ panes
}

// Save current pane layout to a named profile
rite save_named_profile(name, panes) {
    ≔ home = env("HOME");
    ≔ dir_path = home + "/.morgoth/profiles";
    ⎇ fs_exists(dir_path) == false {
        fs_mkdir(dir_path);
    }
    ≔ mut types = [];
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        push(types, panes[i].pane_type);
        i = i + 1;
    }
    ≔ json = json_stringify(types);
    fs_write(dir_path + "/" + name + ".json", json);
}

// Render profile picker overlay in center of focused pane region
rite render_profile_picker(grid, region, profiles, selected) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_w = region.w - 2;
    ≔ inner_h = region.h - 2;

    // Clear interior
    ≔ mut r = 0;
    ⟳ r < inner_h {
        ≔ mut c = 0;
        ⟳ c < inner_w {
            grid.set(inner_y + r, inner_x + c, " ", 7, 0);
            c = c + 1;
        }
        r = r + 1;
    }

    // Title line
    ≔ title_str = "-- Profiles (Enter=load, ESC=cancel) --";
    ≔ mut ci = 0;
    ⟳ ci < len(title_str) ∧ ci < inner_w {
        grid.set(inner_y, inner_x + ci, to_string(char_at(title_str, ci)), 14, 0);
        ci = ci + 1;
    }

    // Profile list (starting at row 1)
    ≔ mut pi = 0;
    ⟳ pi < len(profiles) ∧ pi + 1 < inner_h {
        ≔ pname = profiles[pi];
        ≔ mut line = "";
        ⎇ pi == selected {
            line = "> " + pname;
        } ⎉ {
            line = "  " + pname;
        }
        ≔ mut fg = 7;
        ⎇ pi == selected { fg = 11; }
        ≔ mut lc = 0;
        ⟳ lc < len(line) ∧ lc < inner_w {
            grid.set(inner_y + 1 + pi, inner_x + lc, to_string(char_at(line, lc)), fg, 0);
            lc = lc + 1;
        }
        pi = pi + 1;
    }
}

// ============================================================================
// Section 3: Layout Engine
// ============================================================================

// Auto-size grid dimensions to minimize aspect ratio distortion
// Uses ceiling division: (n + d - 1) / d since Sigil int division truncates
rite recompute_grid(num_panes, screen_h, screen_w) {
    ≔ usable_h = screen_h - 1;
    ≔ mut best_rows = 1;
    ≔ mut best_cols = num_panes;
    ≔ mut best_diff = 999999;
    ≔ mut r = 1;
    ⟳ r * r <= num_panes {
        ≔ c = (num_panes + r - 1) / r;
        ≔ pane_h = usable_h / r;
        ≔ pane_w = screen_w / c;
        ≔ mut diff = pane_w - pane_h * 2;
        ⎇ diff < 0 { diff = 0 - diff; }
        ⎇ diff < best_diff {
            best_diff = diff;
            best_rows = r;
            best_cols = c;
        }
        r = r + 1;
    }
    ↩ { rows: best_rows, cols: best_cols }
}

// Relayout all panes: recompute grid, resize vterms, propagate PTY sizes, redraw
rite relayout_panes(panes, screen_w, screen_h, screen, focus) {
    ≔ grid = recompute_grid(len(panes), screen_h, screen_w);
    ≔ regions = layout_grid(grid.rows, grid.cols, screen_w, screen_h);
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        panes[i].region = regions[i];
        panes[i].vterm.resize(regions[i].h - 2, regions[i].w - 2);
        ⎇ panes[i].alive == true {
            Pty·set_size(panes[i].master_fd, regions[i].h - 2, regions[i].w - 2);
        }
        panes[i].vterm.blit(screen, panes[i].region);
        ≔ t = pane_title(panes[i], i, focus);
        ≔ tc = border_colors(panes[i].pane_type, i == focus);
        render_border(screen, panes[i].region, t, tc.border_fg, tc.title_fg, i == focus);
        i = i + 1;
    }
    flush_dirty(screen);
    ↩ { grid_rows: grid.rows, grid_cols: grid.cols }
}

// Like relayout_panes but uses explicit grid dimensions (Phase 21 forced split)
rite relayout_panes_forced(panes, screen_w, screen_h, screen, focus, rows, cols) {
    ≔ regions = layout_grid(rows, cols, screen_w, screen_h);
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ≔ ri = i;
        ⎇ ri < len(regions) {
            panes[i].region = regions[ri];
            panes[i].vterm.resize(regions[ri].h - 2, regions[ri].w - 2);
            ⎇ panes[i].alive == true {
                Pty·set_size(panes[i].master_fd, regions[ri].h - 2, regions[ri].w - 2);
            }
        }
        panes[i].vterm.blit(screen, panes[i].region);
        ≔ t = pane_title(panes[i], i, focus);
        ≔ tc = border_colors(panes[i].pane_type, i == focus);
        render_border(screen, panes[i].region, t, tc.border_fg, tc.title_fg, i == focus);
        i = i + 1;
    }
    flush_dirty(screen);
}

// Calculate grid layout regions for a rows x cols grid
// screen_w, screen_h = total terminal dimensions
// Returns array of Region structs (row-major order)
// Bottom row reserved for status bar
rite layout_grid(rows, cols, screen_w, screen_h) {
    ≔ usable_h = screen_h - 1;  // Reserve status bar

    ≔ base_h = usable_h / rows;
    ≔ remainder_h = usable_h % rows;

    ≔ base_w = screen_w / cols;
    ≔ remainder_w = screen_w % cols;

    ≔ regions = [];
    ≔ mut y_offset = 0;

    ≔ mut r = 0;
    ⟳ r < rows {
        ≔ mut h = base_h;
        // Give remainder to last row
        ⎇ r == rows - 1 {
            h = base_h + remainder_h;
        }

        ≔ mut x_offset = 0;
        ≔ mut c = 0;
        ⟳ c < cols {
            ≔ mut w = base_w;
            // Give remainder to last column
            ⎇ c == cols - 1 {
                w = base_w + remainder_w;
            }

            push(regions, Region·new(x_offset, y_offset, w, h));

            x_offset = x_offset + w;
            c = c + 1;
        }

        y_offset = y_offset + h;
        r = r + 1;
    }

    regions
}

// ============================================================================
// Section 4: Screen Buffer (Grid)
// ============================================================================

⊢ Grid {
    // Create a flat cell buffer for the screen
    rite new(rows, cols) {
        ≔ total = rows * cols;
        ≔ cells = [];
        ≔ mut i = 0;
        ⟳ i < total {
            push(cells, Cell·new(" ", 7, 0, true));
            i = i + 1;
        }
        ≔ grid = Grid {
            rows: rows,
            cols: cols,
            cells: cells
        };
        ↩ grid
    }

    // Set a cell at (row, col) in the grid — only marks dirty if content changed
    rite set(self, row, col, ch, fg, bg) {
        ⎇ row >= 0 ∧ row < self.rows ∧ col >= 0 ∧ col < self.cols {
            ≔ idx = row * self.cols + col;
            ≔ c = self.cells[idx];
            ⎇ c.ch != ch ∨ c.fg != fg ∨ c.bg != bg {
                self.cells[idx] = Cell·new(ch, fg, bg, true);
            }
        }
    }

    // Get a cell at (row, col)
    rite get(self, row, col) {
        ≔ mut result = Cell·new(" ", 7, 0, false);
        ⎇ row >= 0 ∧ row < self.rows ∧ col >= 0 ∧ col < self.cols {
            ≔ idx = row * self.cols + col;
            result = self.cells[idx];
        }
        result
    }

    // Count dirty cells
    rite dirty_count(self) {
        ≔ mut count = 0;
        ≔ total = self.rows * self.cols;
        ≔ mut i = 0;
        ⟳ i < total {
            ⎇ self.cells[i].dirty == true {
                count = count + 1;
            }
            i = i + 1;
        }
        count
    }

    // Clear all dirty flags — in-place mutation, no allocations
    rite clear_dirty(self) {
        ≔ total = self.rows * self.cols;
        ≔ mut i = 0;
        ⟳ i < total {
            self.cells[i].dirty = false;
            i = i + 1;
        }
    }
}

// ============================================================================
// Section 5: Rendering
// ============================================================================

// Build a pane title string with index prefix, bracketed when focused
rite pane_title(pane, index, focus) {
    ≔ num = to_string(index + 1);
    ≔ base = num + ":" + pane.title;
    ⎇ index == focus { ↩ "[" + base + "]" }
    ↩ base
}

// Return border and title foreground colors for a pane type + focus state
rite border_colors(pane_type, is_focused) {
    ⎇ pane_type == "monitor" {
        ⎇ is_focused == true { ↩ {border_fg: 13, title_fg: 15} }
        ↩ {border_fg: 5, title_fg: 5}
    }
    ⎇ is_focused == true { ↩ {border_fg: 14, title_fg: 15} }
    ↩ {border_fg: 7, title_fg: 7}
}

// Draw a border around a region in the grid
rite render_border(grid, region, title, border_fg, title_fg, is_focused) {
    ≔ x = region.x;
    ≔ y = region.y;
    ≔ w = region.w;
    ≔ h = region.h;

    // Select box-drawing chars based on focus
    ≔ mut bh = BOX_H;
    ≔ mut bv = BOX_V;
    ≔ mut btl = BOX_TL;
    ≔ mut btr = BOX_TR;
    ≔ mut bbl = BOX_BL;
    ≔ mut bbr = BOX_BR;
    ⎇ is_focused == true {
        bh = BOX2_H;
        bv = BOX2_V;
        btl = BOX2_TL;
        btr = BOX2_TR;
        bbl = BOX2_BL;
        bbr = BOX2_BR;
    }

    // Top edge
    grid.set(y, x, btl, border_fg, 0);
    ≔ mut c = 1;
    ⟳ c < w - 1 {
        grid.set(y, x + c, bh, border_fg, 0);
        c = c + 1;
    }
    grid.set(y, x + w - 1, btr, border_fg, 0);

    // Bottom edge
    grid.set(y + h - 1, x, bbl, border_fg, 0);
    c = 1;
    ⟳ c < w - 1 {
        grid.set(y + h - 1, x + c, bh, border_fg, 0);
        c = c + 1;
    }
    grid.set(y + h - 1, x + w - 1, bbr, border_fg, 0);

    // Side edges
    ≔ mut r = 1;
    ⟳ r < h - 1 {
        grid.set(y + r, x, bv, border_fg, 0);
        grid.set(y + r, x + w - 1, bv, border_fg, 0);
        r = r + 1;
    }

    // Title in top border (if provided and fits)
    ⎇ title != "" {
        ≔ max_title_cols = w - 4;
        ⎇ max_title_cols > 0 {
            ≔ mut ti = 0;
            ≔ mut tw = 0;
            ⟳ ti < len(title) ∧ tw < max_title_cols {
                ≔ tch = to_string(char_at(title, ti));
                grid.set(y, x + 2 + tw, tch, title_fg, 0);
                ⎇ is_fullwidth(tch) == true {
                    // Placeholder for second column of fullwidth char
                    ⎇ tw + 1 < max_title_cols {
                        grid.set(y, x + 2 + tw + 1, "", title_fg, 0);
                    }
                    tw = tw + 2;
                } ⎉ {
                    tw = tw + 1;
                }
                ti = ti + 1;
            }
        }
    }
}

// Write text content into the interior of a region
rite render_content(grid, region, text) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_w = region.w - 2;
    ≔ inner_h = region.h - 2;

    ≔ mut row = 0;
    ≔ mut col = 0;
    ≔ mut i = 0;
    ⟳ i < len(text) ∧ row < inner_h {
        ≔ ch = to_string(char_at(text, i));
        ⎇ ch == "\n" {
            row = row + 1;
            col = 0;
        } ⎉ {
            ⎇ col < inner_w {
                grid.set(inner_y + row, inner_x + col, ch, 7, 0);
                col = col + 1;
            }
        }
        i = i + 1;
    }
}

// Build dynamic status bar text
rite build_status_text(focus, panes, mode) {
    ≔ ptype = panes[focus].pane_type;
    ≔ idx = to_string(focus + 1) + "/" + to_string(len(panes));
    ≔ mut text = " Morgoth v" + VERSION + " | [" + idx + "] " + ptype;
    ⎇ mode == "copy" {
        text = text + " | hjkl move  Space select  / search  Enter copy  q exit";
    } ⎉ { ⎇ mode == "search" {
        text = text + " | type to search  Enter accept  Esc cancel";
    } ⎉ {
        text = text + " | c: new  x: close  z: zoom  /: search  q: quit";
    } }
    ↩ text
}

// Build complete keybinding reference for help overlay
rite build_help_text() {
    ≔ mut t = "Morgoth Keybindings\n";
    t = t + "-------------------\n";
    t = t + "^B+n    Next pane\n";
    t = t + "^B+p    Previous pane\n";
    t = t + "^B+1-9  Focus pane N\n";
    t = t + "^B+c    New terminal\n";
    t = t + "^B+m    New monitor\n";
    t = t + "^B+x    Close pane\n";
    t = t + "^B+z    Zoom toggle\n";
    t = t + "^B+[    Copy mode\n";
    t = t + "^B+/    Search\n";
    t = t + "^B+S    Save profile\n";
    t = t + "^B+q    Quit\n";
    t = t + "^B+?    This help\n";
    t = t + "^B+^B   Send ^B to pane\n";
    t = t + "^B+</>  Swap pane\n";
    t = t + "^B+B    Broadcast toggle\n";
    t = t + "^B+T    Task queue overlay\n";
    ↩ t
}

// Render status bar at the bottom of the grid
rite render_status_bar(grid, text) {
    ≔ row = grid.rows - 1;
    ≔ mut c = 0;
    // Fill with inverse video spaces
    ⟳ c < grid.cols {
        grid.set(row, c, " ", 0, 7);
        c = c + 1;
    }
    // Write status text
    ≔ mut i = 0;
    ⟳ i < len(text) ∧ i < grid.cols {
        grid.set(row, i, to_string(char_at(text, i)), 0, 7);
        i = i + 1;
    }
}

// Render styled status bar with mode pill, pane info, hints, and version
rite render_status_bar_styled(grid, focus, panes, mode) {
    ≔ row = grid.rows - 1;
    ≔ mut col = 0;
    // Fill row with spaces (fg=7, bg=0)
    ⟳ col < grid.cols {
        grid.set(row, col, " ", 7, 0);
        col = col + 1;
    }
    col = 0;

    // 1. Mode pill
    ≔ mut pill = " NORMAL ";
    ≔ mut pill_bg = 2;
    ⎇ mode == "copy" {
        pill = " COPY ";
        pill_bg = 3;
    } ⎉ { ⎇ mode == "search" {
        pill = " SEARCH ";
        pill_bg = 5;
    } ⎉ { ⎇ mode == "confirm" {
        pill = " CONFIRM ";
        pill_bg = 1;
    } ⎉ { ⎇ mode == "leader" {
        pill = " LEADER ";
        pill_bg = 4;
    } } } }
    ≔ mut pi = 0;
    ⟳ pi < len(pill) ∧ col < grid.cols {
        grid.set(row, col, to_string(char_at(pill, pi)), 0, pill_bg);
        col = col + 1;
        pi = pi + 1;
    }

    // 2. Pane info
    ≔ pane_info = " [" + to_string(focus + 1) + "/" + to_string(len(panes)) + "] " + panes[focus].pane_type + " ";
    ≔ mut ii = 0;
    ⟳ ii < len(pane_info) ∧ col < grid.cols {
        grid.set(row, col, to_string(char_at(pane_info, ii)), 15, 0);
        col = col + 1;
        ii = ii + 1;
    }

    // 3. Separator
    ⎇ col < grid.cols {
        grid.set(row, col, "│", 8, 0);
        col = col + 1;
    }

    // 4. Key hints
    ≔ mut hints = "";
    ⎇ mode == "copy" {
        hints = " hjkl move  Space select  / search  Enter copy  q exit";
    } ⎉ { ⎇ mode == "search" {
        hints = " type to search  Enter accept  Esc cancel";
    } ⎉ { ⎇ mode == "confirm" {
        hints = " y/Y/Enter: confirm  n: cancel";
    } ⎉ {
        hints = " ^B+c: new  ^B+x: close  ^B+z: zoom  ^B+/: search  ^B+q: quit";
    } } }
    ≔ mut hi = 0;
    ⟳ hi < len(hints) ∧ col < grid.cols {
        grid.set(row, col, to_string(char_at(hints, hi)), 7, 0);
        col = col + 1;
        hi = hi + 1;
    }

    // 5. Right-aligned version
    ≔ ver = "Morgoth v" + VERSION + " ";
    ≔ ver_start = grid.cols - len(ver);
    ⎇ ver_start > col {
        ≔ mut vi = 0;
        ⟳ vi < len(ver) {
            grid.set(row, ver_start + vi, to_string(char_at(ver, vi)), 8, 0);
            vi = vi + 1;
        }
    }
}

// Overlay BROADCAST indicator on the status bar (Phase 26)
// Call after render_status_bar_styled when input.bcast == true
rite render_bcast_pill(grid) {
    ≔ row = grid.rows - 1;
    ≔ badge = " BROADCAST ";
    // Place right of version string (left of it, actually at a fixed offset from right)
    ≔ badge_start = grid.cols - len(badge) - 12;  // leave room for version
    ⎇ badge_start < 0 { badge_start = 0; }
    ≔ mut bi = 0;
    ⟳ bi < len(badge) ∧ badge_start + bi < grid.cols {
        grid.set(row, badge_start + bi, to_string(char_at(badge, bi)), 15, 1);
        bi = bi + 1;
    }
}

// Flush only dirty cells to stdout using ANSI escape sequences
// Batches consecutive cells on the same row to avoid redundant cursor positioning
// which can interfere with multi-byte UTF-8 character rendering.
// Uses concat_all for O(n) string building instead of O(n^2) concatenation.
rite flush_dirty(grid) {
    ≔ mut parts = [];
    ≔ total = grid.rows * grid.cols;
    ≔ mut i = 0;
    ≔ mut last_row = -1;
    ≔ mut last_col = -1;
    ≔ mut last_fg = -1;
    ≔ mut last_bg = -1;
    ⟳ i < total {
        ⎇ grid.cells[i].dirty == true ∧ grid.cells[i].ch != "" {
            ≔ row = i / grid.cols;
            ≔ col = i % grid.cols;
            // Only reposition cursor if not consecutive with previous cell
            ⎇ row != last_row ∨ col != last_col + 1 {
                push(parts, CSI + to_string(row + 1) + ";" + to_string(col + 1) + "H");
            }
            // Only emit color codes if they changed
            ⎇ grid.cells[i].fg != last_fg {
                ≔ fg = grid.cells[i].fg;
                ⎇ fg >= 256 {
                    ≔ raw_fg = fg - 256;
                    push(parts, CSI + "38;2;" + to_string(raw_fg / 65536) + ";" + to_string((raw_fg % 65536) / 256) + ";" + to_string(raw_fg % 256) + "m");
                } ⎉ {
                    push(parts, CSI + "38;5;" + to_string(fg) + "m");
                }
                last_fg = grid.cells[i].fg;
            }
            ⎇ grid.cells[i].bg != last_bg {
                ≔ bg = grid.cells[i].bg;
                ⎇ bg >= 256 {
                    ≔ raw_bg = bg - 256;
                    push(parts, CSI + "48;2;" + to_string(raw_bg / 65536) + ";" + to_string((raw_bg % 65536) / 256) + ";" + to_string(raw_bg % 256) + "m");
                } ⎉ {
                    push(parts, CSI + "48;5;" + to_string(bg) + "m");
                }
                last_bg = grid.cells[i].bg;
            }
            // Write character
            push(parts, grid.cells[i].ch);
            last_row = row;
            last_col = col;
        }
        i = i + 1;
    }
    // Reset colors
    push(parts, CSI + "0m");
    ⎇ len(parts) > 1 {
        ≔ buf = concat_all(parts);
        Sys·write(1, buf, len(buf));
    }
    grid.clear_dirty();
}

// ============================================================================
// Section 6b: Copy Mode Functions
// ============================================================================

rite extract_text_lines(vt) {
    ≔ mut lines = [];
    // Scrollback lines (each is array of {ch, fg, bg} cells)
    ≔ mut si = 0;
    ⟳ si < len(vt.scrollback) {
        ≔ mut line = "";
        ≔ mut ci = 0;
        ⟳ ci < len(vt.scrollback[si]) {
            ⎇ vt.scrollback[si][ci].ch != "" {
                line = line + vt.scrollback[si][ci].ch;
            }
            ci = ci + 1;
        }
        push(lines, line);
        si = si + 1;
    }
    // Visible lines from flat cells array
    ≔ mut row = 0;
    ⟳ row < vt.rows {
        ≔ mut line = "";
        ≔ mut col = 0;
        ⟳ col < vt.cols {
            ≔ idx = row * vt.cols + col;
            ⎇ idx < len(vt.cells) ∧ vt.cells[idx].ch != "" {
                line = line + vt.cells[idx].ch;
            }
            col = col + 1;
        }
        push(lines, line);
        row = row + 1;
    }
    ↩ lines
}

rite extract_selection(cm) {
    ≔ mut sr = cm.select_start_row;
    ≔ mut sc = cm.select_start_col;
    ≔ mut er = cm.cursor_row;
    ≔ mut ec = cm.cursor_col;
    // Normalize: start before end
    ⎇ sr > er ∨ (sr == er ∧ sc > ec) {
        ≔ tr = sr;
        ≔ tc = sc;
        sr = er;
        sc = ec;
        er = tr;
        ec = tc;
    }
    ≔ mut result = "";
    ⎇ cm.line_mode == true {
        ≔ mut r = sr;
        ⟳ r <= er {
            ⎇ r > sr { result = result + "\n"; }
            result = result + cm.text_lines[r];
            r = r + 1;
        }
    } ⎉ {
        ⎇ sr == er {
            result = substring(cm.text_lines[sr], sc, ec + 1);
        } ⎉ {
            result = substring(cm.text_lines[sr], sc, len(cm.text_lines[sr]));
            ≔ mut r = sr + 1;
            ⟳ r < er {
                result = result + "\n" + cm.text_lines[r];
                r = r + 1;
            }
            result = result + "\n" + substring(cm.text_lines[er], 0, ec + 1);
        }
    }
    ↩ result
}

rite write_clipboard(text) {
    ≔ encoded = base64_encode(text);
    ≔ osc = ESC + "]52;c;" + encoded + ESC + "\\";
    Sys·write(1, osc, len(osc));
}

// Search functions
rite find_all_matches(text_lines, query) {
    ≔ mut matches = [];
    ⎇ query == "" { ↩ matches }
    ≔ mut case_sensitive = false;
    ≔ mut qi = 0;
    ⟳ qi < len(query) {
        ≔ c = char_code_at(query, qi);
        ⎇ c >= 65 ∧ c <= 90 { case_sensitive = true; }
        qi = qi + 1;
    }
    ≔ mut search_q = query;
    ⎇ case_sensitive == false { search_q = lower(query); }
    ≔ mut row = 0;
    ⟳ row < len(text_lines) {
        ≔ mut line = text_lines[row];
        ⎇ case_sensitive == false { line = lower(line); }
        ≔ mut col = 0;
        ≔ mut remaining = line;
        ⟳ len(remaining) >= len(search_q) {
            ≔ idx = index_of(remaining, search_q);
            ⎇ idx >= 0 {
                push(matches, {row: row, col: col + idx});
                col = col + idx + 1;
                remaining = substring(line, col, len(line));
            } ⎉ {
                remaining = "";
            }
        }
        row = row + 1;
    }
    ↩ matches
}

rite nearest_match(matches, cursor_row, direction) {
    ⎇ len(matches) == 0 { ↩ -1 }
    ⎇ direction == "backward" {
        ≔ mut i = len(matches) - 1;
        ⟳ i >= 0 {
            ⎇ matches[i].row <= cursor_row { ↩ i }
            i = i - 1;
        }
        ↩ len(matches) - 1
    }
    ≔ mut i = 0;
    ⟳ i < len(matches) {
        ⎇ matches[i].row >= cursor_row { ↩ i }
        i = i + 1;
    }
    ↩ 0
}

rite is_search_match(cm, row, col) {
    ≔ qlen = len(cm.search_query);
    ⎇ qlen == 0 { ↩ {hit: false, current: false} }
    ≔ mut i = 0;
    ⟳ i < len(cm.search_matches) {
        ≔ m = cm.search_matches[i];
        ⎇ row == m.row ∧ col >= m.col ∧ col < m.col + qlen {
            ↩ {hit: true, current: i == cm.search_current}
        }
        i = i + 1;
    }
    ↩ {hit: false, current: false}
}

// Cursor movement
rite copy_move_up(cm) {
    ⎇ cm.cursor_row > 0 {
        cm.cursor_row = cm.cursor_row - 1;
        copy_clamp_col(cm);
    }
}

rite copy_move_down(cm) {
    ⎇ cm.cursor_row < len(cm.text_lines) - 1 {
        cm.cursor_row = cm.cursor_row + 1;
        copy_clamp_col(cm);
    }
}

rite copy_move_left(cm) {
    ⎇ cm.cursor_col > 0 { cm.cursor_col = cm.cursor_col - 1; }
}

rite copy_move_right(cm) {
    ≔ line_len = len(cm.text_lines[cm.cursor_row]);
    ⎇ cm.cursor_col < line_len - 1 {
        cm.cursor_col = cm.cursor_col + 1;
    }
}

rite copy_word_forward(cm) {
    ≔ line = cm.text_lines[cm.cursor_row];
    ≔ mut col = cm.cursor_col;
    // Skip non-space
    ⟳ col < len(line) ∧ to_string(char_at(line, col)) != " " {
        col = col + 1;
    }
    // Skip space
    ⟳ col < len(line) ∧ to_string(char_at(line, col)) == " " {
        col = col + 1;
    }
    ⎇ col >= len(line) ∧ cm.cursor_row < len(cm.text_lines) - 1 {
        cm.cursor_row = cm.cursor_row + 1;
        cm.cursor_col = 0;
    } ⎉ {
        ⎇ col < len(line) { cm.cursor_col = col; }
    }
}

rite copy_word_backward(cm) {
    ≔ mut col = cm.cursor_col;
    ⎇ col > 0 { col = col - 1; }
    ≔ line = cm.text_lines[cm.cursor_row];
    // Skip space backward
    ⟳ col > 0 ∧ to_string(char_at(line, col)) == " " {
        col = col - 1;
    }
    // Skip non-space backward
    ⟳ col > 0 ∧ to_string(char_at(line, col - 1)) != " " {
        col = col - 1;
    }
    cm.cursor_col = col;
}

rite copy_clamp_col(cm) {
    ⎇ len(cm.text_lines) > 0 ∧ cm.cursor_row < len(cm.text_lines) {
        ≔ ll = len(cm.text_lines[cm.cursor_row]);
        ⎇ ll > 0 ∧ cm.cursor_col >= ll {
            cm.cursor_col = ll - 1;
        }
        ⎇ ll == 0 {
            cm.cursor_col = 0;
        }
    }
}

rite copy_adjust_viewport(cm, inner_h) {
    ⎇ cm.cursor_row < cm.viewport_row {
        cm.viewport_row = cm.cursor_row;
    }
    ⎇ cm.cursor_row >= cm.viewport_row + inner_h {
        cm.viewport_row = cm.cursor_row - inner_h + 1;
    }
}

// Selection highlight check
rite is_selected(cm, row, col) {
    ⎇ cm.selecting == false { ↩ false }
    ≔ mut sr = cm.select_start_row;
    ≔ mut sc = cm.select_start_col;
    ≔ mut er = cm.cursor_row;
    ≔ mut ec = cm.cursor_col;
    ⎇ sr > er ∨ (sr == er ∧ sc > ec) {
        ≔ tr = sr;
        ≔ tc = sc;
        sr = er;
        sc = ec;
        er = tr;
        ec = tc;
    }
    ⎇ cm.line_mode == true {
        ↩ row >= sr ∧ row <= er
    }
    ⎇ row < sr ∨ row > er { ↩ false }
    ⎇ row == sr ∧ row == er { ↩ col >= sc ∧ col <= ec }
    ⎇ row == sr { ↩ col >= sc }
    ⎇ row == er { ↩ col <= ec }
    ↩ true
}

// Render copy mode overlay
rite render_copy_mode(grid, region, cm) {
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_h = region.h - 2;
    ≔ inner_w = region.w - 2;

    ≔ mut row = 0;
    ⟳ row < inner_h {
        ≔ text_row = cm.viewport_row + row;
        ≔ mut col = 0;
        ⟳ col < inner_w {
            ≔ mut ch = " ";
            ≔ mut fg = 7;
            ≔ mut bg = 0;
            ⎇ text_row < len(cm.text_lines) {
                ⎇ col < len(cm.text_lines[text_row]) {
                    ch = to_string(char_at(cm.text_lines[text_row], col));
                }
            }
            // Selection highlight (reverse video)
            ⎇ is_selected(cm, text_row, col) == true {
                ≔ tmp = fg;
                fg = bg;
                bg = tmp;
            }
            // Search match highlight
            ≔ minfo = is_search_match(cm, text_row, col);
            ⎇ minfo.hit == true {
                ⎇ minfo.current == true {
                    fg = 15;
                    bg = 3;
                } ⎉ {
                    fg = 0;
                    bg = 6;
                }
            }
            // Cursor (bright white on black)
            ⎇ text_row == cm.cursor_row ∧ col == cm.cursor_col {
                fg = 0;
                bg = 15;
            }
            grid.set(inner_y + row, inner_x + col, ch, fg, bg);
            col = col + 1;
        }
        row = row + 1;
    }
    // Search prompt on last inner row
    ⎇ cm.search_active == true {
        ≔ mut prompt = "/" + cm.search_query;
        ⎇ len(cm.search_matches) > 0 {
            prompt = prompt + " [" + to_string(cm.search_current + 1) + "/" + to_string(len(cm.search_matches)) + "]";
        } ⎉ {
            ⎇ cm.search_query != "" {
                prompt = prompt + " [Pattern not found]";
            }
        }
        ≔ mut pi = 0;
        ⟳ pi < inner_w {
            ≔ mut pch = " ";
            ⎇ pi < len(prompt) {
                pch = to_string(char_at(prompt, pi));
            }
            grid.set(inner_y + inner_h - 1, inner_x + pi, pch, 15, 0);
            pi = pi + 1;
        }
    }
}

// Render help overlay centered in a pane region
rite render_task_overlay(grid, region, tasks) {
    ≔ inner_x = region.x + 1; ≔ inner_y = region.y + 1;
    ≔ inner_w = region.w - 2; ≔ inner_h = region.h - 2;
    // Clear
    ≔ mut r = 0;
    ⟳ r < inner_h {
        ≔ mut c = 0;
        ⟳ c < inner_w { grid.set(inner_y + r, inner_x + c, " ", 7, 0); c = c + 1; }
        r = r + 1;
    }
    // Count by status
    ≔ mut n_p = 0; ≔ mut n_d = 0; ≔ mut n_done = 0; ≔ mut ci = 0;
    ⟳ ci < len(tasks) {
        ≔ s = map_get(tasks[ci], "status");
        ⎇ s == "pending"    { n_p    = n_p    + 1; }
        ⎇ s == "dispatched" { n_d    = n_d    + 1; }
        ⎇ s == "done"       { n_done = n_done + 1; }
        ci = ci + 1;
    }
    // Header (cyan)
    ≔ header = "-- Tasks: " + to_string(n_p) + " pending  " + to_string(n_d) +
               " active  " + to_string(n_done) + " done  (any key=close) --";
    ≔ mut hc = 0;
    ⟳ hc < len(header) ∧ hc < inner_w {
        grid.set(inner_y, inner_x + hc, to_string(char_at(header, hc)), 14, 0);
        hc = hc + 1;
    }
    // Non-done task rows (pending=fg15, dispatched=fg11)
    ≔ mut row = 1; ≔ mut ti = 0;
    ⟳ ti < len(tasks) ∧ row < inner_h {
        ≔ status = map_get(tasks[ti], "status");
        ⎇ status != "done" {
            ≔ mut glyph = ">"; ≔ mut fg = 15;
            ⎇ status == "dispatched" { glyph = "~"; fg = 11; }
            ≔ mut ttext = map_get(tasks[ti], "text");
            ≔ max_t = inner_w - 2;
            ⎇ len(ttext) > max_t { ttext = substring(ttext, 0, max_t - 1) + ">"; }
            ≔ line = glyph + " " + ttext;
            ≔ mut lc = 0;
            ⟳ lc < len(line) ∧ lc < inner_w {
                grid.set(inner_y + row, inner_x + lc, to_string(char_at(line, lc)), fg, 0);
                lc = lc + 1;
            }
            row = row + 1;
        }
        ti = ti + 1;
    }
}

rite render_help_overlay(grid, region) {
    ≔ help = build_help_text();
    ≔ inner_x = region.x + 1;
    ≔ inner_y = region.y + 1;
    ≔ inner_w = region.w - 2;
    ≔ inner_h = region.h - 2;

    // Clear interior
    ≔ mut r = 0;
    ⟳ r < inner_h {
        ≔ mut c = 0;
        ⟳ c < inner_w {
            grid.set(inner_y + r, inner_x + c, " ", 7, 0);
            c = c + 1;
        }
        r = r + 1;
    }

    // Render help text
    ≔ mut row = 0;
    ≔ mut col = 0;
    ≔ mut i = 0;
    ⟳ i < len(help) ∧ row < inner_h {
        ≔ ch = to_string(char_at(help, i));
        ⎇ ch == "\n" {
            row = row + 1;
            col = 0;
        } ⎉ {
            ⎇ col < inner_w {
                grid.set(inner_y + row, inner_x + col, ch, 14, 0);
                col = col + 1;
            }
        }
        i = i + 1;
    }
}

// ============================================================================
// Section 6: Input Handling
// ============================================================================

// Copy mode state
⊢ CopyModeState {
    rite new() {
        ↩ CopyModeState {
            active: false,
            cursor_row: 0,
            cursor_col: 0,
            viewport_row: 0,
            selecting: false,
            select_start_row: 0,
            select_start_col: 0,
            line_mode: false,
            text_lines: [],
            search_active: false,
            search_query: "",
            search_matches: [],
            search_current: -1,
            search_saved_row: 0,
            search_saved_col: 0,
            search_saved_viewport: 0
        }
    }
}

// Input state machine
⊢ InputState {
    rite new(leader_key, bindings) {
        ≔ state = InputState {
            leader_active: false,
            mouse_mode: true,
            escape_buf: "",
            in_escape: false,
            last_escape_buf: "",
            confirming_close: false,
            confirming_quit: false,
            showing_help: false,
            showing_picker: false,
            picker_profiles: [],
            picker_selected: 0,
            active_profile: "default",
            leader_key: leader_key,
            bindings: bindings,
            bcast: false,
            showing_tasks: false,
            copy_mode: CopyModeState·new()
        };
        ↩ state
    }
}

// Process a single input byte, returns action string
// Actions: "passthrough", "leader_activate", "focus_next", "focus_prev",
//          "quit", "none", "mouse:X:Y"
rite process_input(input_state, byte) {
    // Copy mode intercept — before any other input handling
    ⎇ input_state.copy_mode.active == true {
        ≔ cm = input_state.copy_mode;
        // Search input intercept — captures all input when search is active
        ⎇ cm.search_active == true {
            ⌥ byte {
                27 => {
                    // ESC: cancel search, restore position
                    cm.search_active = false;
                    cm.search_query = "";
                    cm.search_matches = [];
                    cm.search_current = -1;
                    cm.cursor_row = cm.search_saved_row;
                    cm.cursor_col = cm.search_saved_col;
                    cm.viewport_row = cm.search_saved_viewport;
                    ↩ "copy_render"
                }
                13 => {
                    // Enter: accept search, keep position
                    cm.search_active = false;
                    ↩ "copy_render"
                }
                127 | 8 => {
                    // Backspace: remove last char
                    ⎇ len(cm.search_query) > 0 {
                        cm.search_query = substring(cm.search_query, 0, len(cm.search_query) - 1);
                    }
                    cm.search_matches = find_all_matches(cm.text_lines, cm.search_query);
                    cm.search_current = nearest_match(cm.search_matches, cm.cursor_row, "backward");
                    ⎇ cm.search_current >= 0 {
                        cm.cursor_row = cm.search_matches[cm.search_current].row;
                        cm.cursor_col = cm.search_matches[cm.search_current].col;
                    }
                    ↩ "copy_render"
                }
                14 => {
                    // Ctrl-N: next match during search
                    ⎇ len(cm.search_matches) > 0 {
                        cm.search_current = (cm.search_current + 1) % len(cm.search_matches);
                        cm.cursor_row = cm.search_matches[cm.search_current].row;
                        cm.cursor_col = cm.search_matches[cm.search_current].col;
                    }
                    ↩ "copy_render"
                }
                16 => {
                    // Ctrl-P: previous match during search
                    ⎇ len(cm.search_matches) > 0 {
                        cm.search_current = cm.search_current - 1;
                        ⎇ cm.search_current < 0 { cm.search_current = len(cm.search_matches) - 1; }
                        cm.cursor_row = cm.search_matches[cm.search_current].row;
                        cm.cursor_col = cm.search_matches[cm.search_current].col;
                    }
                    ↩ "copy_render"
                }
                _ => {
                    ⎇ byte >= 32 ∧ byte < 127 {
                        // Printable: append to query
                        cm.search_query = cm.search_query + from_char_code(byte);
                        cm.search_matches = find_all_matches(cm.text_lines, cm.search_query);
                        cm.search_current = nearest_match(cm.search_matches, cm.cursor_row, "backward");
                        ⎇ cm.search_current >= 0 {
                            cm.cursor_row = cm.search_matches[cm.search_current].row;
                            cm.cursor_col = cm.search_matches[cm.search_current].col;
                        }
                        ↩ "copy_render"
                    }
                }
            }
            ↩ "none"
        }
        // Normal copy mode keys
        ⌥ byte {
            47 => {
                // '/' — enter search
                cm.search_active = true;
                cm.search_query = "";
                cm.search_matches = [];
                cm.search_current = -1;
                cm.search_saved_row = cm.cursor_row;
                cm.search_saved_col = cm.cursor_col;
                cm.search_saved_viewport = cm.viewport_row;
                ↩ "copy_render"
            }
            110 => {
                // 'n' — next match
                ⎇ len(cm.search_matches) > 0 {
                    cm.search_current = (cm.search_current + 1) % len(cm.search_matches);
                    cm.cursor_row = cm.search_matches[cm.search_current].row;
                    cm.cursor_col = cm.search_matches[cm.search_current].col;
                }
                ↩ "copy_render"
            }
            78 => {
                // 'N' — previous match
                ⎇ len(cm.search_matches) > 0 {
                    cm.search_current = cm.search_current - 1;
                    ⎇ cm.search_current < 0 { cm.search_current = len(cm.search_matches) - 1; }
                    cm.cursor_row = cm.search_matches[cm.search_current].row;
                    cm.cursor_col = cm.search_matches[cm.search_current].col;
                }
                ↩ "copy_render"
            }
            104 => { copy_move_left(cm); ↩ "copy_render" }
            106 => { copy_move_down(cm); ↩ "copy_render" }
            107 => { copy_move_up(cm); ↩ "copy_render" }
            108 => { copy_move_right(cm); ↩ "copy_render" }
            48 => {
                cm.cursor_col = 0;
                ↩ "copy_render"
            }
            36 => {
                ⎇ cm.cursor_row < len(cm.text_lines) {
                    ≔ ll = len(cm.text_lines[cm.cursor_row]);
                    ⎇ ll > 0 { cm.cursor_col = ll - 1; }
                }
                ↩ "copy_render"
            }
            103 => {
                cm.cursor_row = 0;
                cm.cursor_col = 0;
                ↩ "copy_render"
            }
            71 => {
                cm.cursor_row = len(cm.text_lines) - 1;
                cm.cursor_col = 0;
                ↩ "copy_render"
            }
            21 => {
                ≔ mut half = (cm.cursor_row - cm.viewport_row) / 2;
                ⎇ half < 1 { half = 5; }
                cm.cursor_row = cm.cursor_row - half;
                ⎇ cm.cursor_row < 0 { cm.cursor_row = 0; }
                copy_clamp_col(cm);
                ↩ "copy_render"
            }
            4 => {
                ≔ mut half = (len(cm.text_lines) - cm.viewport_row) / 2;
                ⎇ half < 1 { half = 5; }
                cm.cursor_row = cm.cursor_row + half;
                ⎇ cm.cursor_row >= len(cm.text_lines) {
                    cm.cursor_row = len(cm.text_lines) - 1;
                }
                copy_clamp_col(cm);
                ↩ "copy_render"
            }
            119 => { copy_word_forward(cm); ↩ "copy_render" }
            98 => { copy_word_backward(cm); ↩ "copy_render" }
            32 => {
                ⎇ cm.selecting == true {
                    cm.selecting = false;
                } ⎉ {
                    cm.selecting = true;
                    cm.select_start_row = cm.cursor_row;
                    cm.select_start_col = cm.cursor_col;
                }
                ↩ "copy_render"
            }
            86 => {
                cm.line_mode = cm.line_mode == false;
                ⎇ cm.line_mode == true ∧ cm.selecting == false {
                    cm.selecting = true;
                    cm.select_start_row = cm.cursor_row;
                    cm.select_start_col = 0;
                } ⎉ {
                    ⎇ cm.line_mode == true ∧ cm.selecting == true {
                        cm.select_start_col = 0;
                    }
                }
                ↩ "copy_render"
            }
            13 => { ↩ "copy_yank" }
            113 => { ↩ "copy_exit" }
            27 => {
                ⎇ cm.selecting == true {
                    cm.selecting = false;
                    ↩ "copy_render"
                }
                ↩ "copy_exit"
            }
            _ => {}
        }
        ↩ "none"
    }

    // Quit confirmation intercept
    ⎇ input_state.confirming_quit == true {
        input_state.confirming_quit = false;
        ⎇ byte == 121 ∨ byte == 89 ∨ byte == 13 { ↩ "quit_confirm" }
        ↩ "quit_cancel"
    }

    // Close confirmation intercept
    ⎇ input_state.confirming_close == true {
        input_state.confirming_close = false;
        ⎇ byte == 121 ∨ byte == 89 ∨ byte == 13 { ↩ "close_confirm" }
        ↩ "close_cancel"
    }

    // Help dismiss — any key dismisses the overlay
    ⎇ input_state.showing_help == true {
        input_state.showing_help = false;
        ↩ "help_dismiss"
    }

    // Tasks overlay dismiss — any key dismisses
    ⎇ input_state.showing_tasks == true {
        input_state.showing_tasks = false;
        ↩ "tasks_dismiss"
    }

    // Profile picker intercept — j/k navigate, Enter loads, Esc cancels
    ⎇ input_state.showing_picker == true {
        ⎇ byte == 27 {
            input_state.showing_picker = false;
            ↩ "picker_close"
        }
        ⎇ byte == 13 {
            ↩ "picker_load"
        }
        ⎇ byte == 106 {
            // j — next profile
            ⎇ input_state.picker_selected + 1 < len(input_state.picker_profiles) {
                input_state.picker_selected = input_state.picker_selected + 1;
            }
            ↩ "picker_move"
        }
        ⎇ byte == 107 {
            // k — prev profile
            ⎇ input_state.picker_selected > 0 {
                input_state.picker_selected = input_state.picker_selected - 1;
            }
            ↩ "picker_move"
        }
        ↩ "none"
    }

    ≔ mut action = "passthrough";

    // In escape sequence
    ⎇ input_state.in_escape == true {
        input_state.escape_buf = input_state.escape_buf + from_char_code(byte);
        action = "none";
        // Cap: prevent unbounded buffer growth
        ⎇ len(input_state.escape_buf) > INPUT_ESC_BUF_MAX {
            input_state.in_escape = false;
            input_state.escape_buf = "";
            ↩ "none"
        }
        // Check for mouse SGR: ESC[<Btn;X;YM or m (buf starts with "[<")
        ⎇ (byte == 77 ∨ byte == 109) ∧ len(input_state.escape_buf) > 2 ∧ starts_with(input_state.escape_buf, "[<") == true {
            action = "mouse:" + input_state.escape_buf;
            input_state.in_escape = false;
            input_state.escape_buf = "";
        } ⎉ {
            // Check for end of non-mouse escape sequence (terminal byte 64-126, need >=2 chars to skip CSI introducer [)
            ⎇ byte >= 64 ∧ byte <= 126 ∧ len(input_state.escape_buf) >= 2 {
                input_state.last_escape_buf = input_state.escape_buf;
                input_state.in_escape = false;
                input_state.escape_buf = "";
                action = "forward_esc";
            }
        }
    } ⎉ {
        // ESC byte starts escape sequence
        ⎇ byte == 27 {
            input_state.in_escape = true;
            input_state.escape_buf = "";
            action = "none";
        } ⎉ {
            // Leader mode handling
            ⎇ input_state.leader_active == true {
                input_state.leader_active = false;
                action = "unknown_leader";
                ⎇ byte == 110 { action = "focus_next"; }
                ⎇ byte == 112 { action = "profile_picker_open"; }
                ⎇ byte == 113 { action = "quit_request"; }
                ⎇ byte == 107 { action = "scroll_up"; }
                ⎇ byte == 106 { action = "scroll_down"; }
                ⎇ byte == input_state.bindings.new_terminal  { action = "create_terminal"; }
                ⎇ byte == input_state.bindings.new_monitor   { action = "create_monitor"; }
                ⎇ byte == input_state.bindings.close_pane    { action = "close_pane"; }
                ⎇ byte == 124 { action = "split_vertical"; }
                ⎇ byte == 45  { action = "split_horizontal"; }
                ⎇ byte == 60  { action = "pane_swap_prev"; }
                ⎇ byte == 62  { action = "pane_swap_next"; }
                ⎇ byte == 66  { action = "bcast_toggle"; }
                ⎇ byte == 84  { action = "tasks_toggle"; }    // 'T' = 84
                ⎇ byte == input_state.bindings.zoom_toggle   { action = "zoom_toggle"; }
                ⎇ byte == input_state.bindings.save_profile  { action = "save_named_profile"; }
                ⎇ byte == input_state.bindings.copy_mode     { action = "copy_enter"; }
                ⎇ byte == 47  { action = "search_enter"; }
                ⎇ byte == input_state.bindings.help          { action = "help_toggle"; }
                ⎇ byte == input_state.leader_key { action = "passthrough_leader"; }
                ⎇ byte >= 49 ∧ byte <= 57 { action = "focus_" + to_string(byte - 48); }
            } ⎉ {
                // Leader key
                ⎇ byte == input_state.leader_key {
                    input_state.leader_active = true;
                    action = "leader_activate";
                }
                // else: action stays "passthrough"
            }
        }
    }

    action
}

// Find which pane a mouse click at (mx, my) belongs to
rite find_pane_at(panes, mx, my) {
    ≔ mut result = -1;
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ≔ r = panes[i].region;
        ⎇ mx >= r.x ∧ mx < r.x + r.w ∧ my >= r.y ∧ my < r.y + r.h {
            result = i;
        }
        i = i + 1;
    }
    result
}

// ============================================================================
// Section 7: Terminal Control
// ============================================================================

rite terminal_init() {
    // Save terminal state before switching to raw mode
    ≔ saved = term_get_termios(0);
    term_set_raw_mode(0);
    // Enter alt screen
    Sys·write(1, ESC + "[?1049h", 8);
    // Enable mouse tracking (SGR mode)
    Sys·write(1, ESC + "[?1006h", 8);
    Sys·write(1, ESC + "[?1003h", 8);
    // Hide cursor
    Sys·write(1, ESC + "[?25l", 6);
    // Clear screen
    Sys·write(1, ESC + "[2J", 4);
    ↩ saved;
}

rite terminal_shutdown(saved_termios) {
    // Show cursor
    Sys·write(1, ESC + "[?25h", 6);
    // Disable mouse tracking
    Sys·write(1, ESC + "[?1003l", 8);
    Sys·write(1, ESC + "[?1006l", 8);
    // Leave alt screen
    Sys·write(1, ESC + "[?1049l", 8);
    // Restore original terminal state (cooked mode)
    term_restore_termios(0, saved_termios);
}

// ============================================================================
// Section 8: Shutdown
// ============================================================================

rite shutdown_panes(panes) {
    // Phase 1: Send SIGTERM to all children
    ≔ mut i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            Sys·kill(panes[i].pid, SIGTERM());
        }
        i = i + 1;
    }

    // Phase 2: Wait briefly for graceful exit
    // In real mode, we'd loop checking waitpid with WNOHANG
    // For now, do a single waitpid pass
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            ≔ wait = Sys·waitpid(panes[i].pid, WNOHANG());
            ⎇ wait.pid > 0 {
                panes[i].alive = false;
            }
        }
        i = i + 1;
    }

    // Phase 3: SIGKILL any remaining
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].alive == true {
            Sys·kill(panes[i].pid, SIGKILL());
            Sys·waitpid(panes[i].pid, 0);
            panes[i].alive = false;
        }
        i = i + 1;
    }

    // Close all PTY fds
    i = 0;
    ⟳ i < len(panes) {
        ⎇ panes[i].master_fd >= 0 {
            Sys·close(panes[i].master_fd);
        }
        ⎇ panes[i].slave_fd >= 0 {
            Sys·close(panes[i].slave_fd);
        }
        i = i + 1;
    }
}

// ============================================================================
// Section 8b: System Monitor Plugin
// ============================================================================

// Format large numbers with K/M suffixes
rite format_number(n) {
    ≔ mut result = to_string(n);
    ⎇ n >= 1000000 {
        ≔ m = n / 1000;
        result = to_string(m / 1000) + "." + to_string((m % 1000) / 100) + "M";
    } ⎉ {
        ⎇ n >= 1000 {
            result = to_string(n / 1000) + "." + to_string((n % 1000) / 100) + "K";
        }
    }
    result
}

// Load Claude Code stats, git branch, and current task
rite monitor_load_stats() {
    ≔ home = env("HOME");

    // Claude stats
    ≔ stats_path = home + "/.claude/stats-cache.json";
    ≔ mut stats = null;
    ⎇ fs_exists(stats_path) == true {
        ≔ raw = fs_read(stats_path);
        ⎇ len(raw) > 0 ∧ starts_with(raw, "{") == true {
            stats = json_parse(raw);
        }
    }

    // Git branch — read last result, then spawn refresh for next iteration
    ≔ git_branch_file = "/tmp/morgoth-branch.txt";
    ≔ mut git_branch = "";
    ⎇ fs_exists(git_branch_file) == true {
        ≔ raw = fs_read(git_branch_file);
        git_branch = raw;
        ≔ bl = len(git_branch);
        ⎇ bl > 0 ∧ char_code_at(git_branch, bl - 1) == 10 {
            git_branch = substring(git_branch, 0, bl - 1);
        }
    }
    Sys·spawn_bg("sh", ["-c", "git rev-parse --abbrev-ref HEAD 2>/dev/null > /tmp/morgoth-branch.txt"]);

    // Current Claude task (~/.claude/current-task)
    ≔ task_path = home + "/.claude/current-task";
    ≔ mut claude_task = "";
    ⎇ fs_exists(task_path) == true {
        ≔ raw = fs_read(task_path);
        claude_task = raw;
        ≔ tl = len(claude_task);
        ⎇ tl > 0 ∧ char_code_at(claude_task, tl - 1) == 10 {
            claude_task = substring(claude_task, 0, tl - 1);
        }
    }

    ↩ { stats: stats, git_branch: git_branch, claude_task: claude_task }
}

// Render monitor data into a VTerm
// info: { stats, git_branch, claude_task } from monitor_load_stats()
// panes: live panes array (used to count claude-role panes for MQ section)
rite monitor_render(vt, info, panes) {
    // Clear VTerm
    ≔ mut ei = 0;
    ⟳ ei < len(vt.cells) {
        vt.cells[ei] = {ch: " ", fg: 7, bg: 0};
        ei = ei + 1;
    }
    vt.cursor_row = 0;
    vt.cursor_col = 0;

    // Separator line
    ≔ mut si = 0;
    ≔ mut sep = " ";
    ⟳ si < vt.cols - 2 {
        sep = sep + BOX_H;
        si = si + 1;
    }

    // Header
    vt.feed(" Claude Code Monitor\n");
    vt.feed(sep + "\n");

    // Git branch
    ⎇ info.git_branch != "" {
        vt.feed(" Branch: " + info.git_branch + "\n");
    } ⎉ {
        vt.feed(" Branch: (none)\n");
    }

    // Current task
    ⎇ info.claude_task != "" {
        // Truncate to fit pane width
        ≔ max_task = vt.cols - 10;
        ≔ mut task_str = info.claude_task;
        ⎇ len(task_str) > max_task {
            task_str = substring(task_str, 0, max_task) + "…";
        }
        vt.feed(" Task:   " + task_str + "\n");
    }

    vt.feed("\n");

    ⎇ info.stats == null {
        vt.feed(" No claude stats available\n");
    } ⎉ {
        ≔ stats = info.stats;

        // Total sessions/messages
        ≔ mut sessions_str = "?";
        ≔ ts = map_get(stats, "totalSessions");
        ⎇ ts != null {
            sessions_str = to_string(ts);
        }
        ≔ mut msgs_str = "?";
        ≔ tm = map_get(stats, "totalMessages");
        ⎇ tm != null {
            msgs_str = format_number(tm);
        }

        vt.feed(" Sessions: " + sessions_str + "\n");
        vt.feed(" Messages: " + msgs_str + "\n");
        vt.feed("\n");

        // Model usage
        ≔ mu = map_get(stats, "modelUsage");
        ⎇ mu != null {
            vt.feed(" Model Usage\n");
            vt.feed(sep + "\n");
            ≔ model_keys = map_keys(mu);
            ≔ mut mi = 0;
            ⟳ mi < len(model_keys) {
                ≔ model_name = model_keys[mi];
                ≔ model = map_get(mu, model_name);
                ⎇ model != null {
                    ≔ in_tok = map_get(model, "inputTokens");
                    ≔ out_tok = map_get(model, "outputTokens");
                    ≔ mut total_tok = 0;
                    ⎇ in_tok != null { total_tok = total_tok + in_tok; }
                    ⎇ out_tok != null { total_tok = total_tok + out_tok; }
                    vt.feed(" " + model_name + " " + format_number(total_tok) + "\n");
                }
                mi = mi + 1;
            }
        }
    }

    // MQ section: count alive Claude-role panes (Phase 26)
    ≔ mut n_claude_panes = 0;
    ≔ mut mqpi = 0;
    ⟳ mqpi < len(panes) {
        ⎇ panes[mqpi].role == "claude" ∧ panes[mqpi].alive == true {
            n_claude_panes = n_claude_panes + 1;
        }
        mqpi = mqpi + 1;
    }
    vt.feed("\n");
    vt.feed(" MQ  " + to_string(n_claude_panes) + " Claude  " + mq_socket_path() + "\n");

    // Task queue section
    ≔ tq_mon = task_load();
    ⎇ len(tq_mon) > 0 {
        ≔ mut tq_p = 0; ≔ mut tq_d = 0; ≔ mut tq_done = 0;
        ≔ mut tqi = 0;
        ⟳ tqi < len(tq_mon) {
            ≔ ts = map_get(tq_mon[tqi], "status");
            ⎇ ts == "pending"    { tq_p    = tq_p    + 1; }
            ⎇ ts == "dispatched" { tq_d    = tq_d    + 1; }
            ⎇ ts == "done"       { tq_done = tq_done + 1; }
            tqi = tqi + 1;
        }
        vt.feed(" Tasks  " + to_string(tq_p) + " pending  " +
                       to_string(tq_d) + " active  " + to_string(tq_done) + " done\n");
    }
}

// ============================================================================
// Section 9: Main Event Loop
// ============================================================================

rite main() {
    // Load configuration
    ≔ cfg = load_config();

    // Load startup pane types from profile (or default single terminal)
    ≔ pane_types = load_profile(cfg.max_panes);
    ≔ grid = recompute_grid(len(pane_types), 24, 80);
    ≔ mut grid_rows = grid.rows;
    ≔ mut grid_cols = grid.cols;

    // Query real terminal dimensions
    ≔ winsize = term_get_winsize(1);
    ≔ mut screen_w = winsize.cols;
    ≔ mut screen_h = winsize.rows;

    // Recompute grid with actual terminal dimensions
    ≔ real_grid = recompute_grid(len(pane_types), screen_h, screen_w);
    grid_rows = real_grid.rows;
    grid_cols = real_grid.cols;

    // Initialize terminal (returns saved termios handle for restore on shutdown)
    ≔ saved_termios = terminal_init();

    // Register signal handlers
    Sys·signal_register(SIGWINCH());
    Sys·signal_register(SIGTERM());
    Sys·signal_register(SIGINT());
    Sys·signal_register(SIGCHLD());

    // Calculate layout
    ≔ mut regions = layout_grid(grid_rows, grid_cols, screen_w, screen_h);

    // Create panes from profile types
    ≔ mut panes = [];
    ≔ mut i = 0;
    ⟳ i < len(pane_types) {
        ⎇ pane_types[i] == "monitor" {
            push(panes, MonitorPane·new(regions[i]));
        } ⎉ {
            push(panes, Pane·new(regions[i], cfg.shell));
        }
        i = i + 1;
    }

    // Setup MQ infrastructure: FIFO dir, per-pane FIFOs, Unix socket
    // Synchronous dir creation — fs_mkdir is a no-op if dir already exists
    fs_mkdir(env("HOME") + "/.morgoth");
    fs_mkdir(mq_fifo_dir());
    ≔ mut mq_fi = 0;
    ⟳ mq_fi < len(panes) {
        ⎇ panes[mq_fi].pane_type == "terminal" {
            create_pane_fifo(panes[mq_fi]);
        }
        mq_fi = mq_fi + 1;
    }
    ≔ mut mq_sock_fd = setup_mq_socket();
    write_registry(panes);
    write_manifest(panes);
    mq_load_pending(panes);

    // Create screen buffer
    ≔ mut screen = Grid·new(screen_h, screen_w);

    // Input state
    ≔ bindings = load_bindings();
    ≔ input = InputState·new(cfg.leader_key, bindings);
    ≔ mut focus = 0;
    ≔ mut running = true;
    ≔ mut zoomed = false;

    // Forced grid state (Phase 21) — 0 = auto, nonzero = user-specified split layout
    ≔ mut forced_rows = 0;
    ≔ mut forced_cols = 0;

    // HMR state
    ≔ mut hmr_counter = 0;
    ≔ mut hmr_last_mtime = 0;
    ⎇ cfg.hmr == true ∧ fs_exists(SELF_PATH) == true {
        hmr_last_mtime = fs_mtime(SELF_PATH);
    }

    // Monitor refresh counter
    ≔ mut monitor_counter = 0;
    // Tick counter for idle detection
    ≔ mut tick_counter = 0;

    // Initial render
    i = 0;
    ⟳ i < len(panes) {
        ≔ title = pane_title(panes[i], i, focus);
        ≔ tc = border_colors(panes[i].pane_type, i == focus);
        render_border(screen, panes[i].region, title, tc.border_fg, tc.title_fg, i == focus);
        i = i + 1;
    }
    render_status_bar_styled(screen, focus, panes, "normal");
    flush_dirty(screen);

    // Session restore prompt (Phase 18)
    ⎇ cfg.session_restore == true {
        ≔ sess_data = load_session();
        ⎇ sess_data != null {
            render_status_bar(screen, " Restore last session? [y/N]  (3s)");
            flush_dirty(screen);
            // Read one response byte; empty string if timeout
            ≔ mut resp = "";
            ⎇ Sys·poll_fd(0, 3000) == true {
                resp = Sys·read_string(0, 1);
            }
            // Drain stdin: discard any bytes that arrived alongside or after
            // the response (e.g. CR, terminal escape replies, pipe injection).
            // Without this, residual bytes are forwarded to the focused pane
            // as passthrough on the first main-loop iteration.
            ⟳ Sys·poll_fd(0, 0) == true {
                Sys·read_string(0, 256);
            }
            ⎇ resp == "y" ∨ resp == "Y" {
                ≔ mut ri = 0;
                ⟳ ri < len(panes) ∧ ri < len(sess_data) {
                    ≔ saved = sess_data[ri];
                    ≔ saved_sb = map_get(saved, "scrollback");
                    ⎇ saved_sb != null ∧ len(saved_sb) > 0 {
                        panes[ri].vterm.restore_scrollback(saved_sb);
                    }
                    ri = ri + 1;
                }
                render_status_bar(screen, " Session restored.");
                flush_dirty(screen);
            } ⎉ {
                render_status_bar_styled(screen, focus, panes, "normal");
                flush_dirty(screen);
            }
        }
    }

    // Main event loop
    ≔ mut had_activity_prev = false;
    ⟳ running == true {
        // Check for signals
        ⎇ Sys·signal_pending(SIGTERM()) == true ∨ Sys·signal_pending(SIGINT()) == true {
            running = false;
        }

        // Check for SIGWINCH (terminal resize)
        ⎇ Sys·signal_pending(SIGWINCH()) == true {
            // Re-query terminal size
            ≔ new_ws = term_get_winsize(1);
            screen_w = new_ws.cols;
            screen_h = new_ws.rows;

            // Reset zoom on resize
            zoomed = false;

            // Reset forced grid if it no longer fits the pane count
            ⎇ forced_rows > 0 ∧ forced_cols > 0 {
                ⎇ forced_rows * forced_cols < len(panes) {
                    forced_rows = 0;
                    forced_cols = 0;
                }
            }

            // Recreate screen buffer and relayout all panes
            screen = Grid·new(screen_h, screen_w);
            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
            grid_rows = gl.grid_rows;
            grid_cols = gl.grid_cols;
            render_status_bar_styled(screen, focus, panes, "normal");
            flush_dirty(screen);
        }

        // Build fd list for batch poll: stdin + alive terminal panes + FIFOs + socket
        ≔ mut poll_fds_arr = [];
        ≔ mut pane_fd_map = [];
        push(poll_fds_arr, 0);
        i = 0;
        ⟳ i < len(panes) {
            ⎇ panes[i].alive == true ∧ panes[i].pane_type == "terminal" {
                push(poll_fds_arr, panes[i].master_fd);
                push(pane_fd_map, i);
            }
            i = i + 1;
        }
        // Per-pane FIFOs (for external producers)
        ≔ mut fifo_fd_map = [];
        i = 0;
        ⟳ i < len(panes) {
            ⎇ panes[i].alive == true ∧ panes[i].fifo_fd >= 0 {
                push(poll_fds_arr, panes[i].fifo_fd);
                push(fifo_fd_map, i);
            }
            i = i + 1;
        }
        // Unix socket (for structured external clients)
        ⎇ mq_sock_fd >= 0 { push(poll_fds_arr, mq_sock_fd); }

        // One batch poll per iteration — blocks up to POLL_INTERVAL_MS when idle
        ≔ mut poll_timeout = 0;
        ⎇ had_activity_prev == false { poll_timeout = POLL_INTERVAL_MS; }
        ≔ poll_ready = Sys·poll_fds(poll_fds_arr, poll_timeout);

        ≔ mut had_activity = false;

        // Poll stdin for user input
        ⎇ poll_ready[0] == true {
            ≔ input_data~ = Sys·read_string(0, 256);
            ⎇ input_data != "" {
                had_activity = true;
                // Process each byte
                ≔ mut bi = 0;
                ⟳ bi < len(input_data) {
                    ≔ byte = char_code_at(input_data, bi);
                    ≔ action = process_input(input, byte);

                    // Action dispatch
                    ⌥ action {
                    "quit_request" => {
                        input.confirming_quit = true;
                        render_status_bar_styled(screen, focus, panes, "confirm");
                        render_status_bar(screen, " Quit Morgoth? y/n");
                        flush_dirty(screen);
                    }
                    "quit_confirm" => {
                        ⎇ cfg.session_restore == true {
                            save_session(panes);
                        }
                        running = false;
                    }
                    "quit_cancel" => {
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "focus_next" => {
                        focus = (focus + 1) % len(panes);
                        ≔ mut pi = 0;
                        ⟳ pi < len(panes) {
                            ≔ t = pane_title(panes[pi], pi, focus);
                            ≔ tc = border_colors(panes[pi].pane_type, pi == focus);
                            render_border(screen, panes[pi].region, t, tc.border_fg, tc.title_fg, pi == focus);
                            pi = pi + 1;
                        }
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "focus_prev" => {
                        ⎇ focus == 0 {
                            focus = len(panes) - 1;
                        } ⎉ {
                            focus = focus - 1;
                        }
                        ≔ mut pi = 0;
                        ⟳ pi < len(panes) {
                            ≔ t = pane_title(panes[pi], pi, focus);
                            ≔ tc = border_colors(panes[pi].pane_type, pi == focus);
                            render_border(screen, panes[pi].region, t, tc.border_fg, tc.title_fg, pi == focus);
                            pi = pi + 1;
                        }
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "scroll_up" => {
                        ≔ vt = panes[focus].vterm;
                        ⎇ vt.scroll_offset < len(vt.scrollback) {
                            vt.scroll_offset = vt.scroll_offset + 1;
                        }
                        vt.blit(screen, panes[focus].region);
                        ≔ sb_title = "[" + to_string(focus + 1) + ":" + to_string(vt.scroll_offset) + "/" + to_string(len(vt.scrollback)) + "]";
                        ≔ sc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, sb_title, sc.border_fg, sc.title_fg, true);
                        flush_dirty(screen);
                    }
                    "scroll_down" => {
                        ≔ vt = panes[focus].vterm;
                        ⎇ vt.scroll_offset > 0 {
                            vt.scroll_offset = vt.scroll_offset - 1;
                        }
                        vt.blit(screen, panes[focus].region);
                        ≔ sc = border_colors(panes[focus].pane_type, true);
                        ⎇ vt.scroll_offset > 0 {
                            ≔ sb_title = "[" + to_string(focus + 1) + ":" + to_string(vt.scroll_offset) + "/" + to_string(len(vt.scrollback)) + "]";
                            render_border(screen, panes[focus].region, sb_title, sc.border_fg, sc.title_fg, true);
                        } ⎉ {
                            render_border(screen, panes[focus].region, pane_title(panes[focus], focus, focus), sc.border_fg, sc.title_fg, true);
                        }
                        flush_dirty(screen);
                    }
                    "passthrough" => {
                        ≔ ch = to_string(char_at(input_data, bi));
                        ⎇ input.bcast == true {
                            // Broadcast: write to all alive terminal panes
                            ≔ mut bri = 0;
                            ⟳ bri < len(panes) {
                                ⎇ panes[bri].alive == true ∧ panes[bri].pane_type == "terminal" {
                                    Sys·write(panes[bri].master_fd, ch, 1);
                                }
                                bri = bri + 1;
                            }
                        } ⎉ {
                            ⎇ panes[focus].master_fd >= 0 {
                                Sys·write(panes[focus].master_fd, ch, 1);
                            }
                        }
                    }
                    "forward_esc" => {
                        ⎇ panes[focus].master_fd >= 0 {
                            ≔ esc_seq = from_char_code(27) + input.last_escape_buf;
                            Sys·write(panes[focus].master_fd, esc_seq, len(esc_seq));
                        }
                    }
                    "create_terminal" => {
                        ⎇ len(panes) < cfg.max_panes {
                            ≔ tmp_region = Region·new(0, 0, 40, 12);
                            push(panes, Pane·new(tmp_region, cfg.shell));
                            focus = len(panes) - 1;
                            screen = Grid·new(screen_h, screen_w);
                            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                            grid_rows = gl.grid_rows;
                            grid_cols = gl.grid_cols;
                            zoomed = false;
                            render_status_bar_styled(screen, focus, panes, "normal");
                            flush_dirty(screen);
                        } ⎉ {
                            render_status_bar(screen, " Max panes (" + to_string(cfg.max_panes) + ") reached");
                            flush_dirty(screen);
                        }
                    }
                    "create_monitor" => {
                        ⎇ len(panes) < cfg.max_panes {
                            ≔ tmp_region = Region·new(0, 0, 40, 12);
                            push(panes, MonitorPane·new(tmp_region));
                            focus = len(panes) - 1;
                            screen = Grid·new(screen_h, screen_w);
                            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                            grid_rows = gl.grid_rows;
                            grid_cols = gl.grid_cols;
                            zoomed = false;
                            render_status_bar_styled(screen, focus, panes, "normal");
                            flush_dirty(screen);
                        } ⎉ {
                            render_status_bar(screen, " Max panes (" + to_string(cfg.max_panes) + ") reached");
                            flush_dirty(screen);
                        }
                    }
                    "close_pane" => {
                        ⎇ len(panes) > 1 {
                            input.confirming_close = true;
                            render_status_bar_styled(screen, focus, panes, "confirm");
                            render_status_bar(screen, " Close pane? y/n");
                            flush_dirty(screen);
                        } ⎉ {
                            render_status_bar(screen, " Last pane. ^B+q to quit.");
                            flush_dirty(screen);
                        }
                    }
                    "close_confirm" => {
                        // Kill the focused pane's process and close fds
                        ⎇ panes[focus].alive == true {
                            Sys·kill(panes[focus].pid, SIGTERM());
                            Sys·waitpid(panes[focus].pid, 0);
                        }
                        ⎇ panes[focus].master_fd >= 0 {
                            Sys·close(panes[focus].master_fd);
                        }
                        ⎇ panes[focus].slave_fd >= 0 {
                            Sys·close(panes[focus].slave_fd);
                        }
                        // Rebuild panes array excluding closed index
                        ≔ mut new_panes = [];
                        ≔ mut ci = 0;
                        ⟳ ci < len(panes) {
                            ⎇ ci != focus {
                                push(new_panes, panes[ci]);
                            }
                            ci = ci + 1;
                        }
                        panes = new_panes;
                        // Adjust focus
                        ⎇ focus >= len(panes) {
                            focus = len(panes) - 1;
                        }
                        // Relayout — reset forced grid on close
                        forced_rows = 0;
                        forced_cols = 0;
                        screen = Grid·new(screen_h, screen_w);
                        ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                        grid_rows = gl.grid_rows;
                        grid_cols = gl.grid_cols;
                        zoomed = false;
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "close_cancel" => {
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "split_vertical" => {
                        // Add terminal; force same rows, +1 col (Phase 21)
                        ⎇ len(panes) < cfg.max_panes {
                            ≔ cur_rows = grid_rows;
                            ≔ cur_cols = grid_cols;
                            ⎇ forced_rows > 0 { cur_rows = forced_rows; }
                            ⎇ forced_cols > 0 { cur_cols = forced_cols; }
                            forced_cols = cur_cols + 1;
                            ≔ np = len(panes) + 1;
                            forced_rows = (np + forced_cols - 1) / forced_cols;
                            ≔ tmp_r = Region·new(0, 0, 40, 12);
                            push(panes, Pane·new(tmp_r, cfg.shell));
                            focus = len(panes) - 1;
                            screen = Grid·new(screen_h, screen_w);
                            relayout_panes_forced(panes, screen_w, screen_h, screen, focus, forced_rows, forced_cols);
                            grid_rows = forced_rows;
                            grid_cols = forced_cols;
                            zoomed = false;
                            render_status_bar_styled(screen, focus, panes, "normal");
                            flush_dirty(screen);
                        } ⎉ {
                            render_status_bar(screen, " Max panes (" + to_string(cfg.max_panes) + ") reached");
                            flush_dirty(screen);
                        }
                    }
                    "split_horizontal" => {
                        // Add terminal; force +1 row, same cols (Phase 21)
                        ⎇ len(panes) < cfg.max_panes {
                            ≔ cur_rows = grid_rows;
                            ≔ cur_cols = grid_cols;
                            ⎇ forced_rows > 0 { cur_rows = forced_rows; }
                            ⎇ forced_cols > 0 { cur_cols = forced_cols; }
                            forced_rows = cur_rows + 1;
                            ≔ np = len(panes) + 1;
                            forced_cols = (np + forced_rows - 1) / forced_rows;
                            ≔ tmp_r = Region·new(0, 0, 40, 12);
                            push(panes, Pane·new(tmp_r, cfg.shell));
                            focus = len(panes) - 1;
                            screen = Grid·new(screen_h, screen_w);
                            relayout_panes_forced(panes, screen_w, screen_h, screen, focus, forced_rows, forced_cols);
                            grid_rows = forced_rows;
                            grid_cols = forced_cols;
                            zoomed = false;
                            render_status_bar_styled(screen, focus, panes, "normal");
                            flush_dirty(screen);
                        } ⎉ {
                            render_status_bar(screen, " Max panes (" + to_string(cfg.max_panes) + ") reached");
                            flush_dirty(screen);
                        }
                    }
                    "pane_swap_prev" => {
                        // Swap focused pane with previous; inline — array slot swap only
                        // works in same scope as the panes declaration (Phase 26)
                        ⎇ len(panes) > 1 {
                            ≔ prev_i = (focus + len(panes) - 1) % len(panes);
                            ≔ tmp_pane = panes[focus];
                            panes[focus] = panes[prev_i];
                            panes[prev_i] = tmp_pane;
                            focus = prev_i;
                            screen = Grid·new(screen_h, screen_w);
                            relayout_panes(panes, screen_w, screen_h, screen, focus);
                        }
                    }
                    "pane_swap_next" => {
                        // Swap focused pane with next; inline — same reason as above
                        ⎇ len(panes) > 1 {
                            ≔ next_i = (focus + 1) % len(panes);
                            ≔ tmp_pane = panes[focus];
                            panes[focus] = panes[next_i];
                            panes[next_i] = tmp_pane;
                            focus = next_i;
                            screen = Grid·new(screen_h, screen_w);
                            relayout_panes(panes, screen_w, screen_h, screen, focus);
                        }
                    }
                    "bcast_toggle" => {
                        // Toggle bcast mode: keystrokes go to all alive terminal panes (Phase 26)
                        input.bcast = input.bcast == false;
                        render_status_bar_styled(screen, focus, panes, "normal");
                        ⎇ input.bcast == true { render_bcast_pill(screen); }
                        flush_dirty(screen);
                    }
                    "zoom_toggle" => {
                        ⎇ zoomed == true {
                            // Unzoom: relayout all panes
                            zoomed = false;
                            screen = Grid·new(screen_h, screen_w);
                            ≔ gl = relayout_panes(panes, screen_w, screen_h, screen, focus);
                            grid_rows = gl.grid_rows;
                            grid_cols = gl.grid_cols;
                            render_status_bar_styled(screen, focus, panes, "normal");
                            flush_dirty(screen);
                        } ⎉ {
                            // Zoom: focused pane fills entire screen minus status bar
                            zoomed = true;
                            ≔ zoom_region = Region·new(0, 0, screen_w, screen_h - 1);
                            panes[focus].region = zoom_region;
                            panes[focus].vterm.resize(screen_h - 3, screen_w - 2);
                            ⎇ panes[focus].alive == true {
                                Pty·set_size(panes[focus].master_fd, screen_h - 3, screen_w - 2);
                            }
                            screen = Grid·new(screen_h, screen_w);
                            panes[focus].vterm.blit(screen, panes[focus].region);
                            ≔ zt = "[" + to_string(focus + 1) + ":" + panes[focus].title + " (zoom)]";
                            ≔ zc = border_colors(panes[focus].pane_type, true);
                            render_border(screen, panes[focus].region, zt, zc.border_fg, zc.title_fg, true);
                            render_status_bar_styled(screen, focus, panes, "normal");
                            flush_dirty(screen);
                        }
                    }
                    "copy_enter" => {
                        ≔ cm = input.copy_mode;
                        cm.text_lines = extract_text_lines(panes[focus].vterm);
                        cm.active = true;
                        cm.cursor_row = len(cm.text_lines) - 1;
                        cm.cursor_col = 0;
                        cm.viewport_row = len(cm.text_lines) - (panes[focus].region.h - 2);
                        ⎇ cm.viewport_row < 0 { cm.viewport_row = 0; }
                        cm.selecting = false;
                        cm.line_mode = false;
                        render_copy_mode(screen, panes[focus].region, cm);
                        ≔ cc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, "[" + to_string(focus + 1) + ":COPY]", cc.border_fg, cc.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "copy");
                        flush_dirty(screen);
                    }
                    "copy_render" => {
                        ≔ cm = input.copy_mode;
                        ≔ inner_h = panes[focus].region.h - 2;
                        copy_adjust_viewport(cm, inner_h);
                        render_copy_mode(screen, panes[focus].region, cm);
                        ≔ crc = border_colors(panes[focus].pane_type, true);
                        ⎇ cm.search_active == true {
                            ≔ cr_title = "[" + to_string(focus + 1) + ":SEARCH] " + panes[focus].title;
                            render_border(screen, panes[focus].region, cr_title, crc.border_fg, crc.title_fg, true);
                            render_status_bar_styled(screen, focus, panes, "search");
                        } ⎉ {
                            render_border(screen, panes[focus].region, "[" + to_string(focus + 1) + ":COPY]", crc.border_fg, crc.title_fg, true);
                            render_status_bar_styled(screen, focus, panes, "copy");
                        }
                        flush_dirty(screen);
                    }
                    "copy_yank" => {
                        ≔ cm = input.copy_mode;
                        ≔ mut yank_msg = "";
                        ⎇ cm.selecting == true {
                            ≔ text = extract_selection(cm);
                            copy_yank_to_claude(panes, focus, text);
                            // Count lines in selection
                            ≔ mut sr = cm.select_start_row;
                            ≔ mut er = cm.cursor_row;
                            ⎇ sr > er { ≔ tmp = sr; sr = er; er = tmp; }
                            ≔ nlines = er - sr + 1;
                            yank_msg = " Copied " + to_string(nlines) + " line";
                            ⎇ nlines != 1 { yank_msg = yank_msg + "s"; }
                        }
                        cm.active = false;
                        cm.text_lines = [];
                        // Flush: blit current vterm state
                        panes[focus].vterm.blit(screen, panes[focus].region);
                        ≔ yc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, pane_title(panes[focus], focus, focus), yc.border_fg, yc.title_fg, true);
                        ⎇ yank_msg != "" {
                            render_status_bar(screen, yank_msg);
                        } ⎉ {
                            render_status_bar_styled(screen, focus, panes, "normal");
                        }
                        flush_dirty(screen);
                    }
                    "copy_exit" => {
                        ≔ cm = input.copy_mode;
                        cm.active = false;
                        cm.text_lines = [];
                        // Flush: blit current vterm state
                        panes[focus].vterm.blit(screen, panes[focus].region);
                        ≔ exc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, pane_title(panes[focus], focus, focus), exc.border_fg, exc.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "save_named_profile" => {
                        save_named_profile(input.active_profile, panes);
                        render_status_bar(screen, " Profile '" + input.active_profile + "' saved");
                        flush_dirty(screen);
                    }
                    "profile_picker_open" => {
                        input.picker_profiles = list_profiles();
                        input.picker_selected = 0;
                        // Set selected to current active_profile if found
                        ≔ mut fi = 0;
                        ⟳ fi < len(input.picker_profiles) {
                            ⎇ input.picker_profiles[fi] == input.active_profile {
                                input.picker_selected = fi;
                            }
                            fi = fi + 1;
                        }
                        input.showing_picker = true;
                        render_profile_picker(screen, panes[focus].region, input.picker_profiles, input.picker_selected);
                        render_border(screen, panes[focus].region, "[PROFILES]", 14, 15, true);
                        flush_dirty(screen);
                    }
                    "picker_move" => {
                        render_profile_picker(screen, panes[focus].region, input.picker_profiles, input.picker_selected);
                        render_border(screen, panes[focus].region, "[PROFILES]", 14, 15, true);
                        flush_dirty(screen);
                    }
                    "picker_load" => {
                        input.showing_picker = false;
                        ≔ sel_name = input.picker_profiles[input.picker_selected];
                        input.active_profile = sel_name;
                        ≔ new_pane_types = load_named_profile(sel_name, cfg.max_panes);
                        // Rebuild panes for new profile
                        shutdown_panes(panes);
                        panes = [];
                        ≔ new_grid = recompute_grid(len(new_pane_types), screen_h, screen_w);
                        grid_rows = new_grid.rows;
                        grid_cols = new_grid.cols;
                        ≔ mut new_regions = layout_grid(grid_rows, grid_cols, screen_w, screen_h);
                        ≔ mut npi = 0;
                        ⟳ npi < len(new_pane_types) {
                            ⎇ new_pane_types[npi] == "monitor" {
                                push(panes, MonitorPane·new(new_regions[npi]));
                            } ⎉ {
                                push(panes, Pane·new(new_regions[npi], cfg.shell));
                            }
                            npi = npi + 1;
                        }
                        focus = 0;
                        zoomed = false;
                        screen = Grid·new(screen_h, screen_w);
                        ≔ mut rpi = 0;
                        ⟳ rpi < len(panes) {
                            ≔ rt = pane_title(panes[rpi], rpi, focus);
                            ≔ rc = border_colors(panes[rpi].pane_type, rpi == focus);
                            render_border(screen, panes[rpi].region, rt, rc.border_fg, rc.title_fg, rpi == focus);
                            rpi = rpi + 1;
                        }
                        render_status_bar(screen, " Loaded profile '" + sel_name + "'");
                        flush_dirty(screen);
                    }
                    "picker_close" => {
                        panes[focus].vterm.blit(screen, panes[focus].region);
                        ≔ pcc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, pane_title(panes[focus], focus, focus), pcc.border_fg, pcc.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "search_enter" => {
                        ≔ cm = input.copy_mode;
                        cm.text_lines = extract_text_lines(panes[focus].vterm);
                        cm.active = true;
                        cm.cursor_row = len(cm.text_lines) - 1;
                        cm.cursor_col = 0;
                        ≔ se_inner_h = panes[focus].region.h - 2;
                        ⎇ len(cm.text_lines) > se_inner_h {
                            cm.viewport_row = len(cm.text_lines) - se_inner_h;
                        } ⎉ {
                            cm.viewport_row = 0;
                        }
                        cm.search_active = true;
                        cm.search_query = "";
                        cm.search_matches = [];
                        cm.search_current = -1;
                        cm.search_saved_row = cm.cursor_row;
                        cm.search_saved_col = cm.cursor_col;
                        cm.search_saved_viewport = cm.viewport_row;
                        render_copy_mode(screen, panes[focus].region, cm);
                        ≔ se_title = "[" + to_string(focus + 1) + ":SEARCH] " + panes[focus].title;
                        ≔ sec = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, se_title, sec.border_fg, sec.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "search");
                        flush_dirty(screen);
                    }
                    "help_toggle" => {
                        input.showing_help = true;
                        render_help_overlay(screen, panes[focus].region);
                        ≔ hc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, "[HELP]", hc.border_fg, hc.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "help_dismiss" => {
                        panes[focus].vterm.blit(screen, panes[focus].region);
                        ≔ hdc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, pane_title(panes[focus], focus, focus), hdc.border_fg, hdc.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "tasks_toggle" => {
                        input.showing_tasks = true;
                        ≔ tq = task_load();
                        render_task_overlay(screen, panes[focus].region, tq);
                        ≔ tc2 = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, "[TASKS]", tc2.border_fg, tc2.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "tasks_dismiss" => {
                        panes[focus].vterm.blit(screen, panes[focus].region);
                        ≔ tdc = border_colors(panes[focus].pane_type, true);
                        render_border(screen, panes[focus].region, pane_title(panes[focus], focus, focus), tdc.border_fg, tdc.title_fg, true);
                        render_status_bar_styled(screen, focus, panes, "normal");
                        flush_dirty(screen);
                    }
                    "passthrough_leader" => {
                        ⎇ panes[focus].master_fd >= 0 {
                            ≔ lch = from_char_code(input.leader_key);
                            Sys·write(panes[focus].master_fd, lch, 1);
                        }
                    }
                    "leader_activate" => {
                        render_status_bar_styled(screen, focus, panes, "leader");
                        flush_dirty(screen);
                    }
                    "unknown_leader" => {
                        render_status_bar(screen, " Unknown key. ^B+? for help.");
                        flush_dirty(screen);
                    }
                    "none" => {}
                    _ => {
                        ⎇ starts_with(action, "mouse:") == true {
                            // Parse SGR mouse: action = "mouse:[<btn;col;rowM"
                            ≔ mbuf = substring(action, 6, len(action));
                            // Extract btn, col, row from "[<btn;col;rowM/m"
                            ≔ mterm = to_string(char_at(mbuf, len(mbuf) - 1));
                            ≔ mbody = substring(mbuf, 2, len(mbuf) - 1);
                            ≔ mparts = split(mbody, ";");
                            ⎇ len(mparts) >= 3 {
                                ≔ mbtn = to_int(mparts[0]);
                                ≔ mcol = to_int(mparts[1]) - 1;
                                ≔ mrow = to_int(mparts[2]) - 1;
                                // Button 0 press (mterm == "M"): change focus
                                ⎇ mbtn == 0 ∧ mterm == "M" {
                                    ≔ clicked = find_pane_at(panes, mcol, mrow);
                                    ⎇ clicked >= 0 ∧ clicked != focus {
                                        focus = clicked;
                                        ≔ mut mpi = 0;
                                        ⟳ mpi < len(panes) {
                                            ≔ mt = pane_title(panes[mpi], mpi, focus);
                                            ≔ mtc = border_colors(panes[mpi].pane_type, mpi == focus);
                                            render_border(screen, panes[mpi].region, mt, mtc.border_fg, mtc.title_fg, mpi == focus);
                                            mpi = mpi + 1;
                                        }
                                        render_status_bar_styled(screen, focus, panes, "normal");
                                        flush_dirty(screen);
                                    }
                                    // Forward click to child PTY only if child has mouse tracking enabled
                                    ⎇ panes[focus].master_fd >= 0 ∧ panes[focus].vterm.mouse_mode > 0 {
                                        ≔ mr = panes[focus].region;
                                        ≔ icol = mcol - mr.x - 1;
                                        ≔ irow = mrow - mr.y - 1;
                                        ⎇ icol >= 0 ∧ icol < mr.w - 2 ∧ irow >= 0 ∧ irow < mr.h - 2 {
                                            ≔ fwd = from_char_code(27) + "[<" + to_string(mbtn) + ";" + to_string(icol + 1) + ";" + to_string(irow + 1) + mterm;
                                            Sys·write(panes[focus].master_fd, fwd, len(fwd));
                                        }
                                    }
                                }
                            }
                        }
                        ⎇ starts_with(action, "focus_") == true ∧ len(action) > 6 {
                            // Direct pane focus: focus_1 through focus_9
                            ≔ digit_str = substring(action, 6, len(action));
                            ≔ mut new_focus = -1;
                            ⎇ digit_str == "1" { new_focus = 0; }
                            ⎇ digit_str == "2" { new_focus = 1; }
                            ⎇ digit_str == "3" { new_focus = 2; }
                            ⎇ digit_str == "4" { new_focus = 3; }
                            ⎇ digit_str == "5" { new_focus = 4; }
                            ⎇ digit_str == "6" { new_focus = 5; }
                            ⎇ digit_str == "7" { new_focus = 6; }
                            ⎇ digit_str == "8" { new_focus = 7; }
                            ⎇ digit_str == "9" { new_focus = 8; }
                            ⎇ new_focus >= 0 ∧ new_focus < len(panes) {
                                focus = new_focus;
                                ≔ mut dpi = 0;
                                ⟳ dpi < len(panes) {
                                    ≔ dt = pane_title(panes[dpi], dpi, focus);
                                    ≔ dtc = border_colors(panes[dpi].pane_type, dpi == focus);
                                    render_border(screen, panes[dpi].region, dt, dtc.border_fg, dtc.title_fg, dpi == focus);
                                    dpi = dpi + 1;
                                }
                                render_status_bar_styled(screen, focus, panes, "normal");
                                flush_dirty(screen);
                            }
                        }
                    }
                    }

                    bi = bi + 1;
                }
            }
        }

        // Poll each terminal pane's PTY for output — drain loop with budget
        // Uses batch poll_ready results; pane_fd_map[pi] maps poll index → pane index
        ≔ mut any_pane_rendered = false;
        ≔ mut pi = 0;
        ⟳ pi < len(pane_fd_map) {
            ≔ pane_i = pane_fd_map[pi];
            ⎇ poll_ready[pi + 1] == true {
                ≔ mut pty_total = 0;
                ≔ mut pty_done = false;
                ⟳ pty_done == false ∧ pty_total < PTY_FRAME_BUDGET {
                    ⎇ Sys·poll_fd(panes[pane_i].master_fd, 0) == true {
                        ≔ chunk~ = Sys·read_string(panes[pane_i].master_fd, PTY_READ_CHUNK);
                        ⎇ chunk != "" {
                            panes[pane_i].vterm.feed(chunk);
                            pty_total = pty_total + len(chunk);
                        } ⎉ {
                            pty_done = true;
                        }
                    } ⎉ {
                        pty_done = true;
                    }
                }
                ⎇ pty_total > 0 {
                    had_activity = true;
                    panes[pane_i].last_pty_tick = tick_counter;
                    // Update pane title from VTerm if set by OSC
                    ⎇ panes[pane_i].vterm.title != "" {
                        panes[pane_i].title = sanitize_title(panes[pane_i].vterm.title);
                        panes[pane_i].role  = detect_role(panes[pane_i].title);
                        write_registry(panes);
                        write_manifest(panes);
                    }
                    // Only render if not zoomed or this is the focused pane, and not in copy mode for focused
                    ⎇ (zoomed == false ∨ pane_i == focus) ∧ (input.copy_mode.active == false ∨ pane_i != focus) {
                        panes[pane_i].vterm.blit(screen, panes[pane_i].region);
                        ≔ mut bt = pane_title(panes[pane_i], pane_i, focus);
                        ⎇ pane_i == focus ∧ zoomed == true {
                            bt = "[" + to_string(pane_i + 1) + ":" + panes[pane_i].title + " (zoom)]";
                        }
                        ≔ btc = border_colors(panes[pane_i].pane_type, pane_i == focus);
                        render_border(screen, panes[pane_i].region, bt, btc.border_fg, btc.title_fg, pane_i == focus);
                        any_pane_rendered = true;
                    }
                }
            }
            pi = pi + 1;
        }

        // Pane death check: reap exited child processes
        ≔ mut di = 0;
        ⟳ di < len(panes) {
            ⎇ panes[di].alive == true ∧ panes[di].pane_type == "terminal" {
                ≔ wait = Sys·waitpid(panes[di].pid, WNOHANG());
                ⎇ wait.pid > 0 {
                    panes[di].alive = false;
                    panes[di].title = "[exited " + to_string(wait.status) + "]";
                    // If pane had a task, reset it to pending so it can be redispatched
                    ⎇ panes[di].current_task_id != null {
                        ≔ mut dead_tq = task_load();
                        ≔ dead_tid = panes[di].current_task_id;
                        ≔ mut dtqi = 0;
                        ⟳ dtqi < len(dead_tq) {
                            ⎇ map_get(dead_tq[dtqi], "id") == dead_tid {
                                ≔ dtxt = map_get(dead_tq[dtqi], "text");
                                ≔ dcts = map_get(dead_tq[dtqi], "created_ts");
                                dead_tq[dtqi] = { id: dead_tid, text: dtxt,
                                                  status: "pending", pane_id: null,
                                                  created_ts: dcts, done_ts: null };
                            }
                            dtqi = dtqi + 1;
                        }
                        task_save(dead_tq);
                        panes[di].current_task_id = null;
                    }
                    // Render dim border to indicate dead pane (fg 8)
                    ⎇ (zoomed == false ∨ di == focus) ∧ (input.copy_mode.active == false ∨ di != focus) {
                        ≔ dead_title = pane_title(panes[di], di, focus);
                        render_border(screen, panes[di].region, dead_title, 8, 8, di == focus);
                        any_pane_rendered = true;
                    }
                }
            }
            di = di + 1;
        }

        // Process ready FIFOs (external producers writing to per-pane fifos)
        ≔ mut fii = 0;
        ⟳ fii < len(fifo_fd_map) {
            ≔ fifo_poll_idx = 1 + len(pane_fd_map) + fii;
            ⎇ poll_ready[fifo_poll_idx] == true {
                ≔ fifo_pane_i = fifo_fd_map[fii];
                ≔ data~ = Sys·read_string(panes[fifo_pane_i].fifo_fd, 4096);
                ⎇ data != "" {
                    mq_send(panes, "external", panes[fifo_pane_i].id, "paste", data);
                }
            }
            fii = fii + 1;
        }
        // Process ready Unix socket (structured external clients)
        ≔ sock_poll_idx = 1 + len(pane_fd_map) + len(fifo_fd_map);
        ⎇ mq_sock_fd >= 0 ∧ poll_ready[sock_poll_idx] == true {
            mq_process_external(panes, mq_sock_fd);
        }

        // Drain pane inboxes (in-process MQ delivery)
        ≔ mut ii = 0;
        ⟳ ii < len(panes) {
            ⎇ len(panes[ii].inbox) > 0 {
                // Inline dispatch: handle paste (write to PTY) and notify (status bar)
                ≔ mut imi = 0;
                ⟳ imi < len(panes[ii].inbox) {
                    ≔ imsg = panes[ii].inbox[imi];
                    ⎇ imsg.kind == "paste" {
                        Sys·write(panes[ii].master_fd, imsg.payload, len(imsg.payload));
                    } ⎉ { ⎇ imsg.kind == "notify" {
                        render_status_bar(screen, " " + imsg.payload);
                        flush_dirty(screen);
                    } ⎉ { ⎇ imsg.kind == "task_done_internal" {
                        ≔ mut tdi = 0;
                        ⟳ tdi < len(panes) {
                            ⎇ panes[tdi].current_task_id == imsg.payload {
                                panes[tdi].current_task_id = null;
                            }
                            tdi = tdi + 1;
                        }
                    } } }
                    imi = imi + 1;
                }
                panes[ii].inbox = [];
            }
            ii = ii + 1;
        }

        // Monitor pane refresh (~2 seconds at 16ms)
        monitor_counter = monitor_counter + 1;
        ⎇ monitor_counter >= 120 {
            monitor_counter = 0;
            ≔ mut mi = 0;
            ⟳ mi < len(panes) {
                ⎇ panes[mi].pane_type == "monitor" {
                    ≔ stats = monitor_load_stats();
                    monitor_render(panes[mi].vterm, stats, panes);
                    // Only render if not zoomed or this is the focused pane, and not in copy mode for focused
                    ⎇ (zoomed == false ∨ mi == focus) ∧ (input.copy_mode.active == false ∨ mi != focus) {
                        panes[mi].vterm.blit(screen, panes[mi].region);
                        ≔ mt = pane_title(panes[mi], mi, focus);
                        ≔ mc = border_colors(panes[mi].pane_type, mi == focus);
                        render_border(screen, panes[mi].region, mt, mc.border_fg, mc.title_fg, mi == focus);
                        any_pane_rendered = true;
                    }
                }
                mi = mi + 1;
            }
            // Auto-dispatch: find pending task, find idle Claude pane, dispatch
            ≔ mut tq_check = task_load();
            ≔ t_pending = task_find_pending(tq_check);
            ⎇ t_pending != null {
                ≔ mut adpi = 0; ≔ mut target_pi = -1;
                ⟳ adpi < len(panes) ∧ target_pi == -1 {
                    ⎇ panes[adpi].pane_type == "terminal" ∧
                      panes[adpi].role == "claude" ∧
                      panes[adpi].alive == true ∧
                      panes[adpi].current_task_id == null ∧
                      tick_counter - panes[adpi].last_pty_tick >= IDLE_THRESHOLD {
                        target_pi = adpi;
                    }
                    adpi = adpi + 1;
                }
                ⎇ target_pi >= 0 {
                    ≔ tid   = map_get(t_pending, "id");
                    ≔ ttext = map_get(t_pending, "text");
                    Sys·write(panes[target_pi].master_fd, ttext, len(ttext));
                    panes[target_pi].current_task_id = tid;
                    // Inline mark_dispatched (array slot assignment requires same scope)
                    ≔ mut mdi = 0;
                    ⟳ mdi < len(tq_check) {
                        ⎇ map_get(tq_check[mdi], "id") == tid {
                            ≔ td_txt = map_get(tq_check[mdi], "text");
                            ≔ td_cts = map_get(tq_check[mdi], "created_ts");
                            tq_check[mdi] = { id: tid, text: td_txt, status: "dispatched",
                                              pane_id: panes[target_pi].id,
                                              created_ts: td_cts, done_ts: null };
                        }
                        mdi = mdi + 1;
                    }
                    task_save(tq_check);
                    render_status_bar(screen, " Task dispatched to pane " + to_string(target_pi + 1));
                    any_pane_rendered = true;
                }
            }
            // Refresh status bar on monitor tick to clear transient messages
            ⎇ input.copy_mode.active == false ∧ input.confirming_close == false ∧ input.confirming_quit == false ∧ input.showing_help == false ∧ input.showing_picker == false ∧ input.showing_tasks == false {
                render_status_bar_styled(screen, focus, panes, "normal");
                ⎇ input.bcast == true { render_bcast_pill(screen); }
                any_pane_rendered = true;
            }
        }

        // Coalesced flush — single flush per iteration instead of per-pane
        ⎇ any_pane_rendered == true {
            flush_dirty(screen);
        }

        // HMR: check for source file changes every ~500ms
        ⎇ cfg.hmr == true {
            hmr_counter = hmr_counter + 1;
            ⎇ hmr_counter >= HMR_CHECK_INTERVAL {
                hmr_counter = 0;
                ⎇ fs_exists(SELF_PATH) == true {
                    ≔ hmr_current_mtime = fs_mtime(SELF_PATH);
                    ⎇ hmr_current_mtime != hmr_last_mtime ∧ hmr_current_mtime > 0 {
                        hmr_last_mtime = hmr_current_mtime;
                        ≔ hmr_result = Dev·reload(SELF_PATH);
                        ⎇ hmr_result == 0 {
                            render_status_bar(screen, " HMR: reloaded");
                            flush_dirty(screen);
                        } ⎉ { ⎇ hmr_result == -2 {
                            render_status_bar(screen, " HMR: parse error — check " + SELF_PATH);
                            flush_dirty(screen);
                        } ⎉ {
                            render_status_bar(screen, " HMR: IO error reading " + SELF_PATH);
                            flush_dirty(screen);
                        } }
                    }
                }
            }
        }

        // Track activity for next iteration's poll timeout
        // (poll_fds timeout replaces the per-iteration adaptive sleep)
        had_activity_prev = had_activity;
        tick_counter = tick_counter + 1;
    }

    // Shutdown — close FIFOs and MQ socket
    ≔ mut sdi = 0;
    ⟳ sdi < len(panes) {
        ⎇ panes[sdi].fifo_fd >= 0 { Sys·close(panes[sdi].fifo_fd); }
        sdi = sdi + 1;
    }
    ⎇ mq_sock_fd >= 0 { Sys·close(mq_sock_fd); }
    // Clean up registry and socket file
    ⎇ fs_exists(mq_socket_path()) == true { fs_remove(mq_socket_path()); }
    shutdown_panes(panes);
    terminal_shutdown(saved_termios);
}
